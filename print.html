<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Triangle From Scratch</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A tutorial for drawing a triangle without any outside crates.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="opening_a_window/index.html"><strong aria-hidden="true">1.</strong> Opening A Window</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="opening_a_window/win32.html"><strong aria-hidden="true">1.1.</strong> Win32</a></li><li class="chapter-item expanded "><a href="opening_a_window/win32_cleanup.html"><strong aria-hidden="true">1.2.</strong> Win32 Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="loading_opengl/index.html"><strong aria-hidden="true">2.</strong> Loading OpenGL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="loading_opengl/win32.html"><strong aria-hidden="true">2.1.</strong> Win32</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">3.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/utf16_literals.html"><strong aria-hidden="true">3.1.</strong> UTF-16 Literals</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Triangle From Scratch</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/rust-tutorials/triangle-from-scratch">GitHub Repo</a></p>
<h1><a class="header" href="#triangle-from-scratch-introduction" id="triangle-from-scratch-introduction">Triangle From Scratch: Introduction</a></h1>
<p>This is an educational series about drawing a triangle without using any outside crates.</p>
<p>Specifically, the rules are:</p>
<ol>
<li>We can only put a crate into the <code>[dependencies]</code> section of <code>Cargo.toml</code> if it's a crate that we wrote ourselves, as part of this project.</li>
<li>We <strong>can</strong> still use Rust's standard library. Since all Rust programs can import from the standard library without a <code>[dependencies]</code> entry, it's fair game.</li>
</ol>
<p>Without any external crates, we'll have to write our own operating system bindings.
It's not difficult code to write, there's just a lot of background details you need to understand first.
That's where most of our focus will go, on learning how that works.
There's a lot less focus spent on the literal &quot;triangle drawing&quot; part, which is usually fairly easy.</p>
<p>Expected subjects include:</p>
<ul>
<li>Reading OS documentation (which usually assumes you're programming in C).</li>
<li>Understanding the C header files that describe the OS's public API.</li>
<li>Writing appropriate &quot;raw&quot; Rust bindings to that public API.</li>
<li>Creating ergonomic wrapper functions to make the API easily used with the rest of Rust.</li>
<li>Having those wrapper functions be fully safe (in the Rust sense) when possible, or at least making them as error-proof as we can.</li>
</ul>
<p><strong>Reminder:</strong> The &quot;absolutely no dependencies&quot; thing is for demonstration purposes only.
If you actually want to draw a triangle within a reasonable amount of development time, please do feel free to use dependencies.
Depending on what you need to do, there's generally many good crates available.</p>
<h1><a class="header" href="#opening-a-window" id="opening-a-window">Opening A Window</a></h1>
<p>If we wanna draw a triangle, we have to have some place to <em>put</em> a triangle.</p>
<p>Generally (but not always) this means showing it in a graphical window on the screen.</p>
<p>Because operating systems all support more than one drawing API,
and because many drawing APIs can be used with more than one operating system,
we're going to separate the lessons about opening a window from the lessons about using a particular drawing API.</p>
<h1><a class="header" href="#opening-a-win32-window" id="opening-a-win32-window">Opening a Win32 Window</a></h1>
<p>On Windows, the C oriented API is called &quot;Win32&quot;.</p>
<p>There's also some C++ oriented APIs for interacting with Windows as well (called COM and WinRT).</p>
<p>It's <em>much</em> easier for Rust to bind to and interact with a C oriented API than a C++ oriented API,
so we'll start with just using Win32 to interact with Windows.</p>
<h2><a class="header" href="#search-the-web" id="search-the-web">Search The Web</a></h2>
<p>Okay, for the sake of the lesson let's pretend that <em>even I</em> don't know what to do.</p>
<p>Let's start by asking the internet nicely.
Something like <a href="https://duckduckgo.com/?q=open+a+window+win32">&quot;open a window win32&quot;</a> sounds right.
Hey look, that <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window">first result</a> is straight from Microsoft.
It's a whole little tutorial on how to open a window.
Perfect, just what we wanted.</p>
<h2><a class="header" href="#starting-the-win32-windowing-tutorial" id="starting-the-win32-windowing-tutorial">Starting The Win32 Windowing Tutorial</a></h2>
<p>Let's read the first paragraph of the <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window">windowing tutorial</a>
that we just found...</p>
<p>To summarize the opening portion:</p>
<ul>
<li>Every window needs a window class.</li>
<li>A window class is registered with the OS at runtime.</li>
<li>We need to fill in a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa">WNDCLASSA</a>
(or <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw">WNDCLASSW</a>)</li>
</ul>
<p>Whoa, slow down, hold on, what's this structure thing? And why are there two versions?</p>
<h3><a class="header" href="#ansi-and-wide" id="ansi-and-wide">ANSI and Wide</a></h3>
<p>All over the Win32 API you'll find stuff where there's an <code>A</code> version and a <code>W</code> version.
This happens with functions that process textual data, as well as with structs associated with those functions.
In this case of <code>WNDCLASSA</code> / <code>WNDCLASSW</code>, a window class has, as part of it, a menu name as well as a class name.
These names are textual, and so we get both an <code>A</code> and a <code>W</code> version.</p>
<p>The <code>A</code> and <code>W</code> letters come from the two types of string that the windows API lets you use: ANSI strings and &quot;wide&quot; strings.</p>
<ul>
<li>ANSI strings use C's <code>char</code> type.
They don't have a specified encoding.
If you store anything other than ASCII data in an ANSI string, the results vary based on context.</li>
<li>Wide strings use C's <code>wchar_t</code> type.
These strings are UTF-16 encoded.
This gives you consistent results while using all the world's writing systems.</li>
</ul>
<h4><a class="header" href="#what-does-this-mean-for-us-rust-users" id="what-does-this-mean-for-us-rust-users">What does this mean for us Rust users?</a></h4>
<p>Well, Rust string literals, and Rust's normal <code>String</code> and <code>&amp;str</code> types, are all UTF-8 encoded.
This means there's a bit of a mismatch between what Windows expects and what we've usually got.</p>
<p>UTF-8 is a <em>superset</em> of ASCII.
This means that any ASCII-only string can be stored compatibly inside a UTF-8 string.
So if we only want to use ASCII data the normal <code>String</code> and <code>&amp;str</code> types will be (mostly) compatible with <code>A</code>-type operations.</p>
<p>On the other hand, ASCII is pretty limited.
Most languages of the world aren't representable with only ASCII text.
You get English, Latin, Esperanto, Klingon, but the list runs out quick after that.
Even English doesn't get all of its fancy typographical marks in an ASCII-only context:
ellipses (…), “angled quotes”, different length dashes (– / —), and so on.</p>
<p>So we really want to be using these <code>W</code>-type operations.
This means that we have to convert UTF-8 over to UTF-16.
Oh, hey, look, <a href="https://doc.rust-lang.org/std/primitive.str.html#method.encode_utf16">that's in the standard library</a>, isn't it neat?
The only slight problem is that we can't use that in a <code>const</code> context (yet).
It's not the worst to do a little runtime data mucking here and there, so we'll accept the overhead.
The UTF-16 conversion is kinda just an &quot;unfortunate but accepted&quot; part of working with Windows.</p>
<h3><a class="header" href="#reading-a-c-struct-declaration" id="reading-a-c-struct-declaration">Reading a C struct declaration</a></h3>
<p>Okay, so now we've picked that we're going to use <code>WNDCLASSW</code>.
Let's look at the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw">MSDN definition</a>:</p>
<pre><code class="language-c">typedef struct tagWNDCLASSW {
  UINT      style;
  WNDPROC   lpfnWndProc;
  int       cbClsExtra;
  int       cbWndExtra;
  HINSTANCE hInstance;
  HICON     hIcon;
  HCURSOR   hCursor;
  HBRUSH    hbrBackground;
  LPCWSTR   lpszMenuName;
  LPCWSTR   lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;
</code></pre>
<p>Oh, gross, what the heck?
What's going on here?
Let's take it one part at a time.</p>
<ul>
<li><code>typedef</code> says that we're making a &quot;type definition&quot;.
The way it works is that first you give a base type, and then you list one or more other names you want to have as aliases.</li>
<li><code>struct tagWNDCLASSW</code> this names the first type, that we're making the aliases for.</li>
<li><code>{ ... }</code> the part in braces lists the fields of the struct.
Each line has the field's type, then the name of the field, then a <code>;</code></li>
<li><code>WNDCLASSW,</code> is the first alias we're making.
From now on, if you refer to a <code>WNDCLASSW</code>, then it's the same as if you'd referred to the whole <code>struct tagWNDCLASSW { ... }</code> declaration.
This is really good, because writing out all the fields any time we just want to talk about the type is just a pain.</li>
<li><code>*PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;</code> these are more aliases as well.
The <code>*</code> makes these pointer types, so a <code>PWNDCLASSW</code> is the same as <code>struct tagWNDCLASSW { ... } *</code> or <code>WNDCLASSW*</code>.
The prefixes on each name variant stand for &quot;Pointer&quot;, &quot;Near Pointer&quot;, and &quot;Long Pointer&quot;.
Long ago when computers had segmented memory there were differences in the pointer types.
These days computers aren't set up for that, so they're all just a normal pointer.
The different names are still around for legacy compatability.</li>
</ul>
<h3><a class="header" href="#starting-our-rust-code" id="starting-our-rust-code">Starting Our Rust Code</a></h3>
<p>I think we've got enough on our plate to start writing things down in Rust.</p>
<pre><code>Microsoft Windows [Version 10.0.19041.685]
(c) 2020 Microsoft Corporation. All rights reserved.

D:\dev\triangle-from-scratch&gt;cargo init --bin
     Created binary (application) package

D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.65s
     Running `target\debug\triangle-from-scratch.exe`
Hello, world!
</code></pre>
<p>Great.
Later on we'll put some of this into a library,
sort it into modules,
all that sort of housekeeping stuff.
For now, we'll just write into <code>main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct WNDCLASSW {
  style: UINT,
  lpfnWndProc: WNDPROC,
  cbClsExtra: int,
  cbWndExtra: int,
  hInstance: HINSTANCE,
  hIcon: HICON,
  hCursor: HCURSOR,
  hbrBackground: HBRUSH,
  lpszMenuName: LPCWSTR,
  lpszClassName: LPCWSTR,
}
<span class="boring">}
</span></code></pre></pre>
<p>Oh, excellent, and we're sure to put that little <code>repr(C)</code> at the top.
This makes sure it has the right <a href="https://doc.rust-lang.org/reference/type-layout.html">memory layout</a> for interacting with foreign code.</p>
<p>Let's give that a try:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
error[E0412]: cannot find type `UINT` in this scope
 --&gt; src\main.rs:9:10
  |
9 |   style: UINT,
  |          ^^^^ not found in this scope

error[E0412]: cannot find type `WNDPROC` in this scope
  --&gt; src\main.rs:10:16
   |
10 |   lpfnWndProc: WNDPROC,
   |                ^^^^^^^ not found in this scope

...you get the idea
</code></pre>
<p>Okay, so, that should be obvious enough in terms of the error message.
We can't declare a struct to have fields with types Rust doesn't know about.
It's just not gonna fly.</p>
<h3><a class="header" href="#how-big-is-an-int" id="how-big-is-an-int">How Big Is An Int?</a></h3>
<p>Okay, start with just the first field on the list of missing types.
Another web search for <a href="https://duckduckgo.com/?q=msdn+uint">&quot;msdn uint&quot;</a>,
and we find a handy page of <a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a>.</p>
<pre><code>UINT: An unsigned INT. The range is 0 through 4294967295 decimal.

This type is declared in WinDef.h as follows:

typedef unsigned int UINT;
</code></pre>
<p>Alright, closer to an answer.
Now we just ask <a href="https://duckduckgo.com/?q=how+big+is+an+int+on+windows">&quot;how big is an int on windows&quot;</a>,
which doesn't have any pages that immediately look useful.
What if we ask <a href="https://duckduckgo.com/?q=how+big+is+an+int+on+windows+msdn">&quot;how big is an int on windows msdn&quot;</a>?
Ah, here we go, <a href="https://docs.microsoft.com/en-us/cpp/cpp/data-type-ranges">Data Type Ranges</a>
gives us all the info we need about the size of different C types.</p>
<p>An <code>unsigned int</code> is 4 bytes, so in Rust terms it's a <code>u32</code>.
We could call our type <code>unsigned_int</code>, but the rust convention is to give C types a <code>c_</code> prefix, and also to just say <code>u</code> for &quot;unsigned&quot;.
In other words, <code>unsigned int</code> in C becomes <a href="https://doc.rust-lang.org/std/os/raw/type.c_uint.html">c_uint</a> in the Rust convention.
There's no strong reason to <em>not</em> keep with this naming convention, so we'll go with that.</p>
<p>Now we can add definitions that get us up to <code>UINT</code>,
and we can do signed ints as well while we're at it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct WNDCLASSW {
  style: UINT,
  lpfnWndProc: WNDPROC,
  cbClsExtra: c_int,
  cbWndExtra: c_int,
  hInstance: HINSTANCE,
  hIcon: HICON,
  hCursor: HCURSOR,
  hbrBackground: HBRUSH,
  lpszMenuName: LPCWSTR,
  lpszClassName: LPCWSTR,
}
type UINT = c_uint;
type c_uint = u32;
type c_int = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Three of the fields aren't underlined in red already!</p>
<h3><a class="header" href="#reading-a-c-function-declaration" id="reading-a-c-function-declaration">Reading a C function declaration</a></h3>
<p>Now we <a href="https://duckduckgo.com/?q=WNDPROC+msdn">look up WNDPROC</a>,
which is a <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc callback function</a>:</p>
<pre><code class="language-c">LRESULT CALLBACK WindowProc(
  _In_ HWND   hwnd,
  _In_ UINT   uMsg,
  _In_ WPARAM wParam,
  _In_ LPARAM lParam
);
</code></pre>
<p>Oh, no, we're back to the weird stuff again!</p>
<p>Really, it's not too bad.
We do need a few hints though:</p>
<ul>
<li><code>_In_</code> is just a note on the intended usage of that function argument.
It's a C macro which gets replaced with nothing later on, so it's basically a code comment.
These arguments move data &quot;in&quot; to the function.
Sometimes there's &quot;out&quot; arguments,
or even &quot;in-out&quot; arguments.
We'll worry about those later.</li>
<li><code>CALLBACK</code> is a C macro that gets replaced with the &quot;callback&quot; ABI attribute.
In this case, that's <code>__stdcall</code>.
How do I know that?
Well, I had to look directly in the windows include files.
Unfortunate, but occasionally necessary.
If you have visual studio installed, it should be in something like <code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0</code>.
Then I just did a grep to look for <code>CALLBACK</code> and looked around.
Lots of false hits, but the only one where <code>CALLBACK</code> gets defined as a function attribute is
<code>127:#define CALLBACK    __stdcall</code>, so that's our winner.
(NOTE: later on I found that <code>CALLBACK</code> is discussed on the
<a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a> page,
so it's much less mysterious than I thought at first.
Still, it's good to have a note on where to find the headers,
so I'm leaving this bit in here.)</li>
</ul>
<p>Alright, get that junk out of the way and what do we see?</p>
<pre><code class="language-c">LRESULT WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
</code></pre>
<p>Oh, hey, <em>we can almost read that</em>.
It helps to remember that C puts the function output type to the left of the function's name,
and also the function argument types are to the left of each argument name.
When we think back to how strut fields were declared,
this is all fairly consistent.</p>
<p>The final <em>very</em> important thing to know is that C function pointers are nullable,
while Rust <code>fn</code> pointers are always non-null.
If we want to have a nullable value on the Rust side,
we have to use <code>Option&lt;fn()&gt;</code> instead of just <code>fn()</code>.</p>
<p>So let's finally add that <code>WNDPROC</code> definition:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type WNDPROC = Option&lt;
  unsafe extern &quot;system&quot; fn(
    hwnd: HWND,
    uMsg: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
  ) -&gt; LRESULT,
&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>VS Code says we're at 12 errors. Not so bad.</p>
<h3><a class="header" href="#void-pointers" id="void-pointers">Void Pointers</a></h3>
<p>Now that we understand what we're supposed to be doing,
it's just a matter of filling in definition after definition until all the errors go away.
A lot of them are over on that <a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a> page,
so we don't even have to look too many places.</p>
<p>Next up is <code>HINSTANCE</code>:</p>
<pre><code>HINSTANCE: A handle to an instance. This is the base address of the module in memory.

HMODULE and HINSTANCE are the same today, but represented different things in 16-bit Windows.

This type is declared in WinDef.h as follows:

typedef HANDLE HINSTANCE;
</code></pre>
<p>So</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type HINSTANCE = HANDLE;
<span class="boring">}
</span></code></pre></pre>
<p>Next, <code>HANDLE</code>:</p>
<pre><code>HANDLE: A handle to an object.

This type is declared in WinNT.h as follows:

typedef PVOID HANDLE;
</code></pre>
<p>This is where it gets interesting, because now we need to have <code>PVOID</code>:</p>
<pre><code>PVOID: A pointer to any type.

This type is declared in WinNT.h as follows:

typedef void *PVOID;
</code></pre>
<p>Remember that the <code>*</code> after the type makes it a pointer variant of the type.
It also has the <code>P</code> prefix we saw before.</p>
<p>The <code>void</code> type name in C performs a sort of double duty,
but in Rust we actually don't see it very often.</p>
<ul>
<li>When <code>void</code> is used as a <em>return type</em> it means that there's no return value from a function.
In Rust we instead use the <code>()</code> type for functions that return nothing.</li>
<li>When <code>void</code> is used as a <em>pointer target type</em> it means that the pointer points to just some opaque memory.
In Rust, we don't really care for mysterious opaque memory,
and we have generics,
so we essentially never end up using void pointers.</li>
</ul>
<p>Because the <code>void*</code> type (and the <code>const void *</code> type) are the special memory handling types in C,
LLVM has particular knowledge and opinions about how they work.
To ensure that Rust has the correct type mapping for void pointers,
there's a <a href="https://doc.rust-lang.org/core/ffi/enum.c_void.html">c_void</a> type provided in the standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PVOID = *mut core::ffi::c_void;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pointer-sized-types" id="pointer-sized-types">Pointer Sized Types</a></h3>
<p>As we proceed down the list of errors,
filling them in one at a time,
things are fairly simple based on what we know to do so far,
and we get this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type HICON = HANDLE;
type HCURSOR = HICON;
type HBRUSH = HANDLE;
type LPCWSTR = *const WCHAR;
type WCHAR = wchar_t;
type wchar_t = u16;
type HWND = HANDLE;
type WPARAM = UINT_PTR;
<span class="boring">}
</span></code></pre></pre>
<p>Then we get to <code>UINT_PTR</code>, which has a slightly funny description:</p>
<pre><code>UINT_PTR: An unsigned INT_PTR.

This type is declared in BaseTsd.h as follows:

// C++
#if defined(_WIN64)
 typedef unsigned __int64 UINT_PTR;
#else
 typedef unsigned int UINT_PTR;
#endif
</code></pre>
<p>Hmm, a little confusing.
So far the types haven't cared about the architecture size.
Maybe something is up.
Let's see what <code>INT_PTR</code> says:</p>
<pre><code>INT_PTR	
A signed integer type for pointer precision. Use when casting a pointer to an integer to perform pointer arithmetic.

This type is declared in BaseTsd.h as follows:

// C++
#if defined(_WIN64) 
 typedef __int64 INT_PTR; 
#else 
 typedef int INT_PTR;
#endif
</code></pre>
<p>Ah ha, so <code>INT_PTR</code> is the signed integer type used for <em>pointer arithmetic</em>,
and <code>UINT_PTR</code> is the unsigned version of course.
Well, if they're for pointer math, that's why they care about the size of a pointer.
If you know your Rust types then you already know what we need to use.
That's right, <code>isize</code> and <code>usize</code>.
They're naturally the size of a pointer, and there's the signed and unsigned variants and everything.</p>
<p>And now we can finally get no errors with our struct declaration!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type c_int = i32;
type c_uint = u32;
type HANDLE = PVOID;
type HBRUSH = HANDLE;
type HCURSOR = HICON;
type HICON = HANDLE;
type HINSTANCE = HANDLE;
type HWND = HANDLE;
type LONG_PTR = isize;
type LPARAM = LONG_PTR;
type LPCWSTR = *const WCHAR;
type LRESULT = LONG_PTR;
type PVOID = *mut core::ffi::c_void;
type UINT = c_uint;
type UINT_PTR = usize;
type WCHAR = wchar_t;
type wchar_t = u16;
type WPARAM = UINT_PTR;

type WNDPROC = Option&lt;
  unsafe extern &quot;system&quot; fn(
    hwnd: HWND,
    uMsg: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
  ) -&gt; LRESULT,
&gt;;

#[repr(C)]
pub struct WNDCLASSW {
  style: UINT,
  lpfnWndProc: WNDPROC,
  cbClsExtra: c_int,
  cbWndExtra: c_int,
  hInstance: HINSTANCE,
  hIcon: HICON,
  hCursor: HCURSOR,
  hbrBackground: HBRUSH,
  lpszMenuName: LPCWSTR,
  lpszClassName: LPCWSTR,
}
<span class="boring">}
</span></code></pre></pre>
<p>Phew.</p>
<h2><a class="header" href="#continuing-the-windowing-tutorial" id="continuing-the-windowing-tutorial">Continuing The Windowing Tutorial</a></h2>
<p>I don't know if you recall,
but like a decade ago when this article started we had a <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window">windowing tutorial</a>
that we were working on.</p>
<h3><a class="header" href="#making-a-wndclassw-value" id="making-a-wndclassw-value">Making a <code>WNDCLASSW</code> value</a></h3>
<p>It says that we need to fill in the window procedure, the hinstance, and the class name.
The other stuff is optional, but those are essential.</p>
<p>In the sample C++ code, we see this interesting line:</p>
<pre><code class="language-cpp">WNDCLASS wc = { };
</code></pre>
<p>That's a little odd looking, it might not be obvious what's happening.
It's declaring a variable <code>wc</code>, of type <code>WNDCLASS</code>, and then zeroing the entire struct.
Keeping in mind that <code>WNDCLASS</code> is an alias for either <code>WNDCLASSA</code> or <code>WNDCLASSW</code>,
depending on how you're building the C++ program,
and also keeping in mind that we're always going to be using the <code>W</code> versions of things,
then the equivalent Rust would be something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main () {
  let mut wc: WNDCLASSW = unsafe { core::mem::zeroed() };
}
</code></pre></pre>
<p>We haven't even called the OS and we've already got <code>unsafe</code> stuff going on.</p>
<p>But... does this need to be <code>unsafe</code> that everyone thinks about?
Is this the kind of unsafe action that we need to evaluate the correctness of every type we do it?
No, not at all.
It's always safe to make a default <code>WNDCLASSW</code> by zeroing the memory.
We know that right now, and that doesn't change based on the situation.
So we'll just give a <code>Default</code> impl to our type that does this for us.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WNDCLASSW {
  #[inline]
  #[must_use]
  fn default() -&gt; Self {
    unsafe { core::mem::zeroed() }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In fact, this is going to be true for all the foreign C structs we declare.
We'll just make a macro to handle this for us consistently.
When you're making a lot of bindings by hand, consistency is king.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! unsafe_impl_default_zeroed {
  ($t:ty) =&gt; {
    impl Default for $t {
      #[inline]
      #[must_use]
      fn default() -&gt; Self {
        unsafe { core::mem::zeroed() }
      }
    }
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>&quot;Lokathor, why did you put unsafe in that macro name? Default isn't an unsafe trait.&quot;
Good question.
It's because the macro <em>could</em> be used improperly.
The <code>unsafe</code> block around the call to <code>zeroed</code> tells the compiler &quot;no, hush, it's fine, I checked.&quot;
So if you were to use the macro to make a <code>Default</code> impl for a type that can't be safely zeroed,
then you'd sure have a problem on your hand.</p>
<p>Any time a macro hides away some sort of unsafe thing, you should put unsafe in the name.
It's a simple convention, but it keeps it obvious that the macro can go wrong if misused.</p>
<p>Now our rust can look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let mut wc = WNDCLASSW::default();
}
</code></pre></pre>
<p>And that's so much nicer, at least to my eyes.</p>
<h3><a class="header" href="#writing-a-window-procedure" id="writing-a-window-procedure">Writing a Window Procedure</a></h3>
<p>The guide says</p>
<blockquote>
<p>We'll examine the window procedure in detail later. For now, just treat this as a forward reference.</p>
</blockquote>
<p>So, for now we'll just make a dummy window procedure that panics if it's actually called.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern &quot;system&quot; fn dummy_window_procedure(
  hwnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  unimplemented!()
}
<span class="boring">}
</span></code></pre></pre>
<p>And we can start filling in the <code>wc</code> value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = todo!();
  wc.lpszClassName = todo!();
}
</code></pre></pre>
<h3><a class="header" href="#getting-the-hinstance" id="getting-the-hinstance">Getting the HINSTANCE</a></h3>
<p>This next part is a hair tricky to solve on your own.</p>
<p>What the tutorial wants us to do is pass the <code>hInstance</code> value that we were given at the start of the <code>WinMain</code> function.
Except the problem is that we're not writing a Windows C++ program so we don't have a WinMain function at all.
We're writing a Rust program, and the Rust program starts at <code>fn main()</code>, with no instance argument.</p>
<p>If we just ask the internet about <a href="https://duckduckgo.com/?q=msdn+get+my+instance">&quot;msdn get my instance&quot;</a>
then there's not too much help.
However, if we phrase it more like <a href="https://duckduckgo.com/?q=msdn+get+my+hinstance+c%2B%2B">&quot;msdn get my hinstance c++&quot;</a>
then there's a lovely <a href="https://stackoverflow.com/questions/1749972/determine-the-current-hinstance">StackOverflow</a>
asking about this very situation.
If we call <code>GetModuleHandle(NULL)</code> we can get the <code>HINSTANCE</code> of our exe.</p>
<p>Interestingly, one of the comments on the question also says that we can just plain pass <code>NULL</code> as our instance value and it'll be fine.
However, the MSDN tutorial says to pass an <code>HINSTANCE</code>,
and this pushes us to learn a bit and try a new thing,
so we'll at least try the <code>GetModuleHandle</code> way first.</p>
<p>If we look up <code>GetModuleHandle</code>, we see that it has an <code>A</code>-form and <code>W</code>-form, since it takes a name, and the name is textual.
We want to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew">GetModuleHandleW</a>, as discussed.</p>
<blockquote>
<p>If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).</p>
</blockquote>
<p>Sounds good.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = GetModuleHandleW(core::ptr::null());

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = todo!();
}
</code></pre></pre>
<p>Well, obviously this won't work, but let's check that error message for fun:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
error[E0425]: cannot find function, tuple struct or tuple variant `GetModuleHandleW` in this scope
  --&gt; src\main.rs:18:19
   |
18 |   let hInstance = GetModuleHandleW(core::ptr::null());
   |                   ^^^^^^^^^^^^^^^^ not found in this scope
</code></pre>
<p>Okay, so we need to declare the function before we can use it.
We do this with an <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">external block</a>.</p>
<p>An external block just declares the signature of a function, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// EXAMPLE USAGE
extern ABI {
  fn NAME1(args) -&gt; output;
  
  fn NAME2(args) -&gt; output;

  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The actual function is &quot;external&quot; to the program.
To perform compilation, all the compiler really needs is the correct function signature.
This allows it to perform type checking, and ensure the correct call ABI is used.
Later on, the linker sorts it all out.
If it turns out that a function can't be linked after all,
you get a link error rather than a compile error.</p>
<p>But who tells the linker what to link with to find the external functions?
Well, you can use a build script, or you can put it right on the extern block.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// EXAMPLE USAGE
#[link(name = &quot;LibraryName&quot;)]
extern ABI {
  fn NAME1(args) -&gt; output;
}
<span class="boring">}
</span></code></pre></pre>
<p>If the library is some sort of common system library that the linker will already know about,
then it's perfectly fine to just use the attribute.
In other cases, like if a library name varies by operating system, you might need the build script.</p>
<p>Where do we find <code>GetModuleHandleW</code> though?
MSDN tells us right there on the page.
If we look in the <strong>Requirements</strong> section we'll see:</p>
<blockquote>
<p>DLL:	Kernel32.dll</p>
</blockquote>
<p>So in our Rust we have our declaration like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`GetModuleHandleW`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew)
  pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -&gt; HMODULE;
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can call <code>GetModuleHandleW</code> without error (if we put an <code>unsafe</code> block around the call):</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = todo!();
}
</code></pre></pre>
<h3><a class="header" href="#wide-strings" id="wide-strings">Wide Strings</a></h3>
<p>The last thing we need is one of those fancy <code>LPCWSTR</code> things.
A &quot;long pointer to a C-style wide string&quot;.
Well a long pointer is just a pointer.
And a wide string, to Windows, means a UTF-16 string.
The only thing we haven't mentioned yet is the C-style thing.</p>
<p>There's two basic ways to handle strings.</p>
<ul>
<li>&quot;Null terminated&quot;, where the string is just a pointer, but it isn't allowed to contain 0.
To determine the string's length you have to walk the string until you see a 0, and that's the end of the string.</li>
<li>&quot;ptr+len&quot;, where the string is a pointer and a length, and the string can contain any value.
To determine the length, you just check the length value.</li>
</ul>
<p>Rust uses the ptr+len style for strings, as well as for slices in general.
C and C++ use the null terminated style for strings.</p>
<p>It's not <em>too</em> difficult to convert a ptr+len string into a null terminated string,
but it's also not entirely free.
Pushing an extra 0 onto the end of the string is only cheap if there's spare capacity to do it.
In the case of string literals, for example,
you'd have to allocate a separate string, because the literal is kept in read-only memory.</p>
<p>The basic form of this is very simple code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Turns a Rust string slice into a null-terminated utf-16 vector.
pub fn wide_null(s: &amp;str) -&gt; Vec&lt;u16&gt; {
  s.encode_utf16().chain(Some(0)).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>.encode_utf16()</code> makes the basic encoding iterator,
then <code>.chain(Some(0))</code> puts a 0 on the end of the iteration,
and we just <code>.collect()</code> it into a totally normal <code>Vec&lt;u16&gt;</code>.</p>
<p>Long term, if we were using a lot of UTF-16,
we might want to build a way to have these &quot;C wide strings&quot; computed as compile time and stored as literals.
It lets the program allocate a little less as it performs its startup stuff.
However, the code for that is a little hairy, and a bit of a side story compared to the current goal.</p>
<p>Soooo.... we can just write it like this, right?</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  // BAD, WRONG, NO
  wc.lpszClassName = wide_null(&quot;Sample Window Class&quot;).as_ptr();
}
</code></pre></pre>
<p>Ah, we can't do that!
This is a classic beginner's mistake, but it must be avoided.</p>
<p>If we wrote it like that, the vec of utf-16 would get allocated, then we'd call <code>as_ptr</code>,
assign that pointer to <code>wc.lpszClassName</code>, and then... the expression would end.
And the vector would drop, and clean up, and deallocate the memory we wanted to point to.
We'd have a dangling pointer, horrible.
Maybe it'd even sometimes work anyway.
The allocator might not re-use the memory right away, so it might still hold useful data for a while.
It's still some nasty Undefined Behavior though.</p>
<p>Here's the correct way to do it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };
  let sample_window_class_wn = wide_null(&quot;Sample Window Class&quot;);

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();
}
</code></pre></pre>
<p>This way, the <code>sample_window_class_wn</code> binding holds the vector live,
and the pointer can be used for as long as that binding lasts.
In this case, to the end of the <code>main</code> function.</p>
<h3><a class="header" href="#registering-the-window-class" id="registering-the-window-class">Registering The Window Class</a></h3>
<p>Okay, so our widow class request is all filled out, we just have to register it using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw">RegisterClassW</a>:</p>
<pre><code class="language-cpp">ATOM RegisterClassW(
  const WNDCLASSW *lpWndClass
);
</code></pre>
<p>And in Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type ATOM = WORD;
type WORD = c_ushort;
type c_ushort = u16;
#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`RegisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw)
  pub fn RegisterClassW(lpWndClass: *const WNDCLASSW) -&gt; ATOM;
}
<span class="boring">}
</span></code></pre></pre>
<p>It's a little weird sometimes to see that the <code>const</code> and <code>*</code> part are &quot;around&quot; the target type in C,
and then both on the same side of the type in Rust,
but that's genuinely the correct translation.</p>
<p>So now we can make the register call:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };
  let sample_window_class_wn = wide_null(&quot;Sample Window Class&quot;);

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();

  unsafe { RegisterClassW(&amp;wc) };
}
</code></pre></pre>
<p>But we don't know if it worked or not.
Almost any call to the operating system can fail.
Cosmic rays and stuff.
If we check the <strong>Return value</strong> part of the MSDN page it says:</p>
<blockquote>
<p>If the function fails, the return value is zero. To get extended error information, call <code>GetLastError</code>.</p>
</blockquote>
<p>Hmm, let's check <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>,
that sounds like a thing we'll want to use a lot.</p>
<p>yada yada... thead local error code...
yada yada... some functions set an error code and <em>then</em> succeed...
okay... &quot;To obtain an error string for system error codes, use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function.&quot;
Oof, we'd have a whole extra layer to dive into if we went down that path.
&quot;For a complete list of error codes provided by the operating system, see <a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes">System Error Codes</a>.&quot;
Okay, well that's not too bad.
For now, we can show an error code and then look it up by hand.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type DWORD = c_ulong;
type c_ulong = u32;
#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`GetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
  pub fn GetLastError() -&gt; DWORD;
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we have basic error checking / reporting:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };
  let sample_window_class_wn = wide_null(&quot;Sample Window Class&quot;);

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();

  let atom = unsafe { RegisterClassW(&amp;wc) };
  if atom == 0 {
    let last_error = unsafe { GetLastError() };
    panic!(&quot;Could not register the window class, error code: {}&quot;, last_error);
  }
}
</code></pre></pre>
<h2><a class="header" href="#creating-the-window" id="creating-the-window">Creating The Window</a></h2>
<p>VS Code says I'm at like 4500 words already, and we haven't even made our Window yet.</p>
<blockquote>
<p>To create a new instance of a window, call the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw">CreateWindowEx</a> function:</p>
</blockquote>
<p>Okay, sure, that'll be nice and easy, no proble--</p>
<pre><code class="language-cpp">HWND CreateWindowExW(
  DWORD     dwExStyle,
  LPCWSTR   lpClassName,
  LPCWSTR   lpWindowName,
  DWORD     dwStyle,
  int       X,
  int       Y,
  int       nWidth,
  int       nHeight,
  HWND      hWndParent,
  HMENU     hMenu,
  HINSTANCE hInstance,
  LPVOID    lpParam
);
</code></pre>
<p>oof!</p>
<p>Okay, actually most of these we've seen before.
This is getting easier the more we do.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type HMENU = HANDLE;
type LPVOID = *mut core::ffi::c_void;
#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`CreateWindowExW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw)
  pub fn CreateWindowExW(
    dwExStyle: DWORD, lpClassName: LPCWSTR, lpWindowName: LPCWSTR,
    dwStyle: DWORD, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int,
    hWndParent: HWND, hMenu: HMENU, hInstance: HINSTANCE, lpParam: LPVOID,
  ) -&gt; HWND;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>CreateWindowEx</code> returns a handle to the new window, or zero if the function fails.
To show the window—that is, make the window visible —pass the window handle to the
<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a> function</p>
</blockquote>
<p>Hey, look, the MSDN docs are using some of that extended typography we mentioned before (those dashes).</p>
<p>Apparently we want our window creation to look something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // first register the class, as before

  let sample_window_name_wn = wide_null(&quot;Sample Window Name&quot;);
  let hwnd = unsafe {
    CreateWindowExW(
      0,
      sample_window_class_wn.as_ptr(),
      sample_window_name_wn.as_ptr(),
      WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      core::ptr::null_mut(),
      core::ptr::null_mut(),
      hInstance,
      core::ptr::null_mut(),
    )
  };
  if hwnd.is_null() {
    panic!(&quot;Failed to create a window.&quot;);
  }
}
</code></pre></pre>
<p>Now we just have to define <code>WS_OVERLAPPEDWINDOW</code> and <code>CW_USEDEFAULT</code>.
These are defined in the header files as C macro values, which expand to literals.
In Rust, we <em>could</em> define them as macros, but it'd be a little silly.
We probably want to define them as <code>const</code> values instead.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WS_OVERLAPPED: u32 = 0x00000000;
const WS_CAPTION: u32 = 0x00C00000;
const WS_SYSMENU: u32 = 0x00080000;
const WS_THICKFRAME: u32 = 0x00040000;
const WS_MINIMIZEBOX: u32 = 0x00020000;
const WS_MAXIMIZEBOX: u32 = 0x00010000;
const WS_OVERLAPPEDWINDOW: u32 = WS_OVERLAPPED
  | WS_CAPTION
  | WS_SYSMENU
  | WS_THICKFRAME
  | WS_MINIMIZEBOX
  | WS_MAXIMIZEBOX;
const CW_USEDEFAULT: c_int = 0x80000000_u32 as c_int;
<span class="boring">}
</span></code></pre></pre>
<p>There's more <code>WS_</code> values you could define, but that's enough to start.</p>
<p>Oh, and heck, we probably want to just import <code>null</code> and <code>null_mut</code> since we'll be using them a lot.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ptr::{null, null_mut};
<span class="boring">}
</span></code></pre></pre>
<p>For calling <code>ShowWindow</code>, we have a <code>HWND</code> already,
but the show parameter is apparently another one of those <code>WinMain</code> arguments.
Instead we'll just look at the list of what the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>
docs say we can send, and I guess we can pick <code>SW_SHOW</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SW_SHOW: c_int = 5;
type BOOL = c_int;
#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`ShowWindow`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow)
  pub fn ShowWindow(hWnd: HWND, nCmdShow: c_int) -&gt; BOOL;
}
<span class="boring">}
</span></code></pre></pre>
<p>And we add a call to <code>ShowWindow</code> after we've made our window and checked for a successful creation.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let _previously_visible = unsafe { ShowWindow(hwnd, SW_SHOW) };
<span class="boring">}
</span></code></pre></pre>
<p>Okay, if we run our program now we <em>expect</em> it to at least make the window,
but then the window will close when we go off the end of the <code>main</code> function and the process ends.
So, it'll probably flicker on screen really fast and then disappear, or something.
Right?</p>
<p>Let's give it a try...</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target\debug\triangle-from-scratch.exe`
thread 'main' panicked at 'not implemented', src\main.rs:60:3
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\triangle-from-scratch.exe` (exit code: 0xc0000409, STATUS_STACK_BUFFER_OVERRUN)
</code></pre>
<p>Whoops!
Haha, remember how we had that dummy window procedure?
It's actually <em>not</em> supposed to panic and unwind the stack during the callback.
Bad things end up happening.
We just did it to fill in a little bit so the compiler would be cool.</p>
<p>Now that we're tying to turn on the program on for real (even for a second),
we need a real window procedure.
But we don't know how to write one yet.
Never fear, there's a function called <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowprocw">DefWindowProcW</a>.
It's the &quot;Default Window Procedure&quot;, that you can use to handle any messages you don't want to handle.
Right now, for us, that's all of them.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // ...
  wc.lpfnWndProc = Some(DefWindowProcW);
  // ...
}

#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`DefWindowProcW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowprocw)
  pub fn DefWindowProcW(
    hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -&gt; LRESULT;
}
</code></pre></pre>
<p>And, finally, we can get a window to flicker on the screen!</p>
<h2><a class="header" href="#handling-window-messages" id="handling-window-messages">Handling Window Messages</a></h2>
<p>We're on to the next page of the tutorial!</p>
<p>Now we get to learn all about <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/window-messages">Window Messages</a></p>
<p>First we need to define this great <code>MSG</code> struct:</p>
<pre><code class="language-cpp">typedef struct tagMSG {
  HWND   hwnd;
  UINT   message;
  WPARAM wParam;
  LPARAM lParam;
  DWORD  time;
  POINT  pt;
  DWORD  lPrivate;
} MSG, *PMSG, *NPMSG, *LPMSG;
</code></pre>
<p>In Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct MSG {
  hwnd: HWND,
  message: UINT,
  wParam: WPARAM,
  lParam: LPARAM,
  time: DWORD,
  pt: POINT,
  lPrivate: DWORD,
}
unsafe_impl_default_zeroed!(MSG);
<span class="boring">}
</span></code></pre></pre>
<p>Hey look, we have nearly all of that defined already.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type LONG = c_long;
type c_long = i32;
#[repr(C)]
pub struct POINT {
  x: LONG,
  y: LONG,
}
unsafe_impl_default_zeroed!(POINT);
<span class="boring">}
</span></code></pre></pre>
<p>And now we can get our window messages.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`GetMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew)
  pub fn GetMessageW(
    lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT,
  ) -&gt; BOOL;
}
<span class="boring">}
</span></code></pre></pre>
<p>We have to get them in a loop of course, because we'll be getting a whole lot of them.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // first open the window

  let mut msg = MSG::default();
  loop {
    let message_return = unsafe { GetMessageW(&amp;mut msg, null_mut(), 0, 0) };
    if message_return == 0 {
      break;
    } else if message_return == -1 {
      let last_error = unsafe { GetLastError() };
      panic!(&quot;Error with `GetMessageW`, error code: {}&quot;, last_error);
    }
  }
}
</code></pre></pre>
<p>Except we're missing <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">TranslateMessage</a>
and <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagew">DispatchMessageW</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`TranslateMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage)
  pub fn TranslateMessage(lpMsg: *const MSG) -&gt; BOOL;

  /// [`DispatchMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagew)
  pub fn DispatchMessageW(lpMsg: *const MSG) -&gt; LRESULT;
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay so then we put those into our <code>loop</code>, if there's no problem with getting the message:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  loop {
    let message_return = unsafe { GetMessageW(&amp;mut msg, null_mut(), 0, 0) };
    if message_return == 0 {
      break;
    } else if message_return == -1 {
      let last_error = unsafe { GetLastError() };
      panic!(&quot;Error with `GetMessageW`, error code: {}&quot;, last_error);
    } else {
      unsafe {
        TranslateMessage(&amp;msg);
        DispatchMessageW(&amp;msg);
      }
    }
  }
<span class="boring">}
</span></code></pre></pre>
<p>There's a lot of good info on the page about window messages,
but that's all we have to do here in terms of our code.</p>
<p>By now, our program can open a window.
However, we also see an eternally spinning mouse once it's open.
We also <em>don't</em> see our program close when we close the window.
It just continues to spin in the <code>loop</code>,
and we have to exit it by pressing Ctrl+C in the command line.</p>
<h2><a class="header" href="#writing-the-window-procedure" id="writing-the-window-procedure">Writing The Window Procedure</a></h2>
<p>Next up is <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/writing-the-window-procedure">Writing the Window Procedure</a>.</p>
<p>That default window procedure we've been using so far is fine for most events.
Usually it just ignores every event.
However, a few event types can't just be ignored.
One of them is that window closing situation.
Another is that thing with the mouse cursor.</p>
<p>First let's do the window closing and cleanup.
If we look at MSDN page for the <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-close">WM_CLOSE</a>
message, we can see that we'll need to be able to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow">DestroyWindow</a>
and <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a>.
We also need to respond to <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-destroy">WM_DESTROY</a> as well.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const WM_CLOSE: u32 = 0x0010;
pub const WM_DESTROY: u32 = 0x0002;

#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`DestroyWindow`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow)
  pub fn DestroyWindow(hWnd: HWND) -&gt; BOOL;

  /// [`PostQuitMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage)
  pub fn PostQuitMessage(nExitCode: c_int);
}
<span class="boring">}
</span></code></pre></pre>
<p>And we have to write our own procedure.
This time, no panics.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>There's a few different ways we can arrange the branching here,
and it comes down to taste in the end,
but most of the messages should return 0 when you've processed them.
We'll assume that 0 is the &quot;normal&quot; response and build our setup around that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; DestroyWindow(hWnd),
    WM_DESTROY =&gt; PostQuitMessage(0),
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>One little problem here is that <code>DestroyWindow</code> and <code>PostQuitMessage</code> have different return types.
Even though we're ignoring the output of <code>DestroyWindow</code>, it's a type error to have it like this.
We can suppress the output of <code>DestroyWindow</code> by putting it in a block and having a <code>;</code> after it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; {
      DestroyWindow(hWnd);
    }
    WM_DESTROY =&gt; PostQuitMessage(0),
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Ehhhhhh, I'm not sure if I'm a fan of <code>rustfmt</code> making it look like that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; drop(DestroyWindow(hWnd)),
    WM_DESTROY =&gt; PostQuitMessage(0),
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Oh, yeah, that's the good stuff.
We can use <code>drop</code> to throw away the <code>i32</code> value,
so then we don't need the <code>;</code> and braces,
so rustfmt keeps it on a single line.
I am <em>all about</em> that compact code stuff.</p>
<p>Now we can open the window and click for it to close and the program actually terminates.</p>
<h2><a class="header" href="#fixing-the-cursor-maybe" id="fixing-the-cursor-maybe">Fixing The Cursor (maybe?)</a></h2>
<p>The mouse cursor is still kinda funky.
It gets kinda... <em>stuck</em> with different icons.
If you move the mouse into the window area from different sides,
the little &quot;adjust window size&quot; cursors don't change to the normal cursor once the mouse is in the middle of the window.
That's mostly our fault, we left the cursor for our Window Class as null.</p>
<p>Instead, if we use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw">LoadCursorW</a>
we can assign a cursor to our window class,
and then the default window procedure will set the cursor to be the right image at the right time.</p>
<p>We're supposed to call it with something like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // ...
  wc.hCursor = unsafe { LoadCursorW(hInstance, IDC_ARROW) };
  // ...
}
</code></pre></pre>
<p>And the extern function is easy to do:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`LoadCursorW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw)
  pub fn LoadCursorW(hInstance: HINSTANCE, lpCursorName: LPCWSTR) -&gt; HCURSOR;
}
<span class="boring">}
</span></code></pre></pre>
<p>But how do we make that <code>IDC_ARROW</code> thing?
In the docs for <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw">LoadCursorW</a>
they're all listed as <code>MAKEINTRESOURCE(number)</code>.
Okay so we look up <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-makeintresourcew">MAKEINTRESOURCEW</a>
and... it's a C macro. Blast.
Okay so we can't link to it and call it,
instead we'll have to grep the windows includes to see what's happening.</p>
<pre><code>C:\Program Files (x86)\Windows Kits\10\Include&gt;rg &quot;#define MAKEINTRESOURCE&quot;
10.0.16299.0\um\WinUser.h
215:#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
216:#define MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
218:#define MAKEINTRESOURCE  MAKEINTRESOURCEW
220:#define MAKEINTRESOURCE  MAKEINTRESOURCEA

10.0.16299.0\shared\ks.h
4464:#define MAKEINTRESOURCE( res ) ((ULONG_PTR) (USHORT) res)
</code></pre>
<p>This is a <code>#define</code>, which technically <em>isn't</em> C code.
It's a declaration for a thing called the &quot;C Pre-Processor&quot;,
which is a tool that runs over a source file <em>before</em> the text gets to the compiler itself.
In the case of a <code>#define</code>, the general form is <code>#define original replacement</code>.
Any occurrence of the <code>original</code> is replaced (textually) with <code>replacement</code>.
So <code>#define MAKEINTRESOURCE  MAKEINTRESOURCEW</code> makes all occurrences of <code>MAKEINTRESOURCE</code> become <code>MAKEINTRESOURCEW</code>,
before the compiler even sees the source code.
Since there are two different <code>#define</code> statements for <code>MAKEINTRESOURCE</code> we can assume that they're conditional,
and a given program would get one or the other during compilation.
If you go investigate <code>WinUser.h</code> you'll see that this is the case,
but I don't really want to quote source code blocks from <em>Microsoft</em> files,
because I'm not clear on how big of a quote block would be &quot;fair use&quot;.</p>
<p>Anyway, if there's input arguments on the original then they can be written to accept an expression.
And then the expansion puts the expression in somewhere.
That's how <code>MAKEINTRESOURCEW(i)</code> works,
anything inside the parentheses becomes <code>i</code> in the replacement expression.
<code>MAKEINTRESOURCEW(2+2)</code> would become <code>((LPWSTR)((ULONG_PTR)((WORD)(2+2))))</code>.</p>
<p>Finally, if there's a backslash at the end of a <code>#define</code> line it will continue into the next line.
That's not the case here,
but more complicated defines can end up using backslashes,
so you should just be aware if you're trying to read a lot of C code.</p>
<p>In C these are called &quot;macros&quot;,
but because they're so different from how a macro works in Rust,
I'll try to just call them a <code>#define</code>.</p>
<p>Back to examining <code>MAKEINTRESOURCE</code> itself.
The input value is cast to a <code>WORD</code>,
then cast directly to a <code>ULONG_PTR</code>,
then cast directly to a string pointer (either ansi or wide).
That's not too hard for us to do.</p>
<p>Since this was done as a C-style macro,
you might think that we'd want to do a Rust-style macro too.
However, I think we might want to use a <code>const fn</code> instead.
I just like having the type checking when possible.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type LPWSTR = *mut WCHAR;
type ULONG_PTR = usize;
/// [`MAKEINTRESOURCEW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-makeintresourcew)
pub const fn MAKEINTRESOURCEW(i: WORD) -&gt; LPWSTR {
  i as ULONG_PTR as LPWSTR
}
const IDC_ARROW: LPCWSTR = MAKEINTRESOURCEW(32512);
<span class="boring">}
</span></code></pre></pre>
<p>Did that fix it?
Huh. Nope.</p>
<p>Sometimes you're really sure that you know what's wrong,
it's just <em>so</em> obvious,
but you didn't know at all,
and you basically wasted your time with some dead end.
This is frustrating, but it's okay.
We all make mistakes.</p>
<p>In some web searches about this problem,
I've heard that the mouse cursor sometimes is heuristic in Windows,
and once Windows thinks that your app is behaving properly,
it'll make the mouse cursor so the right thing for you.
I don't have any idea if this is true or not.
If it is true, then maybe once we add more to our program the mouse cursor will start working right.
Let's move on, we can come back to this later.</p>
<h2><a class="header" href="#painting-the-window" id="painting-the-window">Painting The Window</a></h2>
<p>The tutorial wants to tell us about <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/painting-the-window">Painting The Window</a> next.</p>
<p>So we have to accept a <code>WM_PAINT</code> message:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WM_PAINT: u32 = 0x000F;
<span class="boring">}
</span></code></pre></pre>
<p>And then do a little dance with a <code>PAINTSTRUCT</code>,
as well as the additional types it depends on:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct PAINTSTRUCT {
  hdc: HDC,
  fErase: BOOL,
  rcPaint: RECT,
  fRestore: BOOL,
  fIncUpdate: BOOL,
  rgbReserved: [BYTE; 32],
}
unsafe_impl_default_zeroed!(PAINTSTRUCT);
type HDC = HANDLE;
type BYTE = u8;
#[repr(C)]
pub struct RECT {
  left: LONG,
  top: LONG,
  right: LONG,
  bottom: LONG,
}
unsafe_impl_default_zeroed!(RECT);
<span class="boring">}
</span></code></pre></pre>
<p>This is all becoming routine by now, I hope.</p>
<p>They want us to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint">BeginPaint</a>,
then <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect">FillRect</a> on the whole canvas,
then <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint">EndPaint</a>.
Sounds easy enough to do.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`BeginPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint)
  pub fn BeginPaint(hWnd: HWND, lpPaint: LPPAINTSTRUCT) -&gt; HDC;

  /// [`FillRect`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect)
  pub fn FillRect(hDC: HDC, lprc: *const RECT, hbr: HBRUSH) -&gt; c_int;

  /// [`EndPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint)
  pub fn EndPaint(hWnd: HWND, lpPaint: *const PAINTSTRUCT) -&gt; BOOL;
}
const COLOR_WINDOW: u32 = 5;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>COLOR_WINDOW</code> constant I had to look up in the headers.</p>
<p>Now we adjust the window procedure a bit to do the painting:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; drop(DestroyWindow(hWnd)),
    WM_DESTROY =&gt; PostQuitMessage(0),
    WM_PAINT =&gt; {
      let mut ps = PAINTSTRUCT::default();
      let hdc = BeginPaint(hWnd, &amp;mut ps);
      let _success = FillRect(hdc, &amp;ps.rcPaint, (COLOR_WINDOW + 1) as HBRUSH);
      EndPaint(hWnd, &amp;ps);
    }
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Window looks the same as before,
but if we fiddle with the brush value we can see it'll draw using other colors.
Doesn't seem to fix the mouse though.</p>
<h2><a class="header" href="#closing-the-window" id="closing-the-window">Closing The Window</a></h2>
<p>The tutorial page about <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/closing-the-window">Closing The Window</a>
has a fun part where we can open a message box.
I like the occasional message box, let's do that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`MessageBoxW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxw)
  pub fn MessageBoxW(
    hWnd: HWND, lpText: LPCWSTR, lpCaption: LPCWSTR, uType: UINT,
  ) -&gt; c_int;
}
const MB_OKCANCEL: u32 = 1;
const IDOK: c_int = 1;
<span class="boring">}
</span></code></pre></pre>
<p>So here's a fun question, how do we decide when a constant should be <code>u32</code> or <code>c_int</code> or whatever type of int?
The correct answer is that there's no correct answer.
I just pick based on how I see the API using it most of the time.
That is, if it's a <code>const</code> that gets compared to a return from a function,
we use the function's return type.
If it's a <code>const</code> we pass to a function, we use the function's argument type.
Sometimes a value will be used as more than one type of number, then you'll have to just pick one.
In C the number types can just automatically convert, so they don't really care.
In Rust, that's not the case, so I just try to pick a default type for the value.
So that most of the time I can write <code>MY_CONST</code> and not <code>MY_CONST as _</code>.</p>
<h2><a class="header" href="#managing-application-state" id="managing-application-state">Managing Application State</a></h2>
<p>Ah, we're back to a slightly tricky part of things.
In <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-application-state-">Managing Application State</a>
we get some notions thrown around like &quot;use just global variables until it gets too complicated!&quot;
Well, no thanks MSDN. I'll go directly to the stage where there's no global variables.</p>
<p>First, we need to be ready to handle <code>WM_NCCREATE</code> and <code>WM_CREATE</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WM_NCCREATE: u32 = 0x0081;
const WM_CREATE: u32 = 0x0001;
<span class="boring">}
</span></code></pre></pre>
<p>And we check for them in our window procedure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in the window_procedure
  match Msg {
    WM_NCCREATE =&gt; {
      println!(&quot;NC Create&quot;);
      return 1;
    }
    WM_CREATE =&gt; println!(&quot;Create&quot;),
<span class="boring">}
</span></code></pre></pre>
<p>Let's see those messages print out...</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
     Running `target\debug\triangle-from-scratch.exe`
NC Create
thread 'main' panicked at 'Failed to create a window.', src\main.rs:53:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\triangle-from-scratch.exe` (exit code: 101)
</code></pre>
<p>Nani!?
Something already went wrong.
Better check the full docs for <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-nccreate">WM_NCCREATE</a>.
Ah, see, it's right there.</p>
<blockquote>
<p>Return Value: If an application processes this message, it should return TRUE to continue creation of the window.
If the application returns FALSE, the CreateWindow or CreateWindowEx function will return a NULL handle.</p>
</blockquote>
<p>Okay, so far all of our messages have asked us to just <em>always</em> return 0 when the message was handled,
and this is the first message we've been handling that we had to decide to return 0 or not.
Well, right now our window creation should always proceed, so here we go:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in the window_procedure
WM_NCCREATE =&gt; {
  println!(&quot;NC Create&quot;);
  return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>And give this a test now:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
     Running `target\debug\triangle-from-scratch.exe`
NC Create
Create
</code></pre>
<p>Naisu!</p>
<p>Hey, better check on <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-create">WM_CREATE</a>
to see if it has any return stuff we just got right on accident:</p>
<blockquote>
<p><strong>Return value:</strong> If an application processes this message, it should return zero to continue creation of the window.
If the application returns –1, the window is destroyed and the CreateWindowEx or CreateWindow function returns a NULL handle.</p>
</blockquote>
<p>Ah, yeah, we were getting it right sorta on accident.
Gotta always read those docs.</p>
<p>Okay now we continue the tutorial:</p>
<blockquote>
<p>The last parameter of CreateWindowEx is a pointer of type <code>void*</code>.
You can pass any pointer value that you want in this parameter.
When the window procedure handles the <code>WM_NCCREATE</code> or <code>WM_CREATE</code> message,
it can extract this value from the message data.</p>
</blockquote>
<p>Right, so, we have to have a void pointer to pass to the message.
Uh, just to pick something, let's pass our message a pointer to the number 5.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in main
let lparam: *mut i32 = Box::leak(Box::new(5_i32));
let hwnd = unsafe {
  CreateWindowExW(
    0,
    sample_window_class_wn.as_ptr(),
    sample_window_name_wn.as_ptr(),
    WS_OVERLAPPEDWINDOW,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    null_mut(),
    null_mut(),
    hInstance,
    lparam.cast(),
  )
};
<span class="boring">}
</span></code></pre></pre>
<p>So we're making a boxed <code>i32</code>,
then we leak the box because we don't want Rust to drop this box based on scope.
Instead, we'll clean up the box as part of the window destruction.</p>
<blockquote>
<p>When you receive the <code>WM_NCCREATE</code> and <code>WM_CREATE</code> messages,
the lParam parameter of each message is a pointer to a <code>CREATESTRUCT</code> structure.</p>
</blockquote>
<p>The <code>CREATESTRUCT</code> type has <code>A</code> and <code>W</code> forms.
Since we're using <code>CreateWindowExW</code>, we'll assume that we use <code>CREATESTRUCTW</code> here.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct CREATESTRUCTW {
  lpCreateParams: LPVOID,
  hInstance: HINSTANCE,
  hMenu: HMENU,
  hwndParent: HWND,
  cy: c_int,
  cx: c_int,
  y: c_int,
  x: c_int,
  style: LONG,
  lpszName: LPCWSTR,
  lpszClass: LPCWSTR,
  dwExStyle: DWORD,
}
unsafe_impl_default_zeroed!(CREATESTRUCTW);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can get out the boxed pointer thing from the create struct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_NCCREATE =&gt; {
  println!(&quot;NC Create&quot;);
  let createstruct: *mut CREATESTRUCTW = lParam as *mut _;
  if createstruct.is_null() {
    return 0;
  }
  let boxed_i32_ptr: *mut i32 = (*createstruct).lpCreateParams.cast();
  return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw">SetWindowLongPtrW</a>
to connect this create struct pointer to the window itself.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`SetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw)
  pub fn SetWindowLongPtrW(
    hWnd: HWND, nIndex: c_int, dwNewLong: LONG_PTR,
  ) -&gt; LONG_PTR;
}
const GWLP_USERDATA: c_int = -21;
<span class="boring">}
</span></code></pre></pre>
<p>And it's fairly simple to call, but we have to put a manual cast to <code>LONG_PTR</code> in:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_NCCREATE =&gt; {
  println!(&quot;NC Create&quot;);
  let createstruct: *mut CREATESTRUCTW = lParam as *mut _;
  if createstruct.is_null() {
    return 0;
  }
  let boxed_i32_ptr = (*createstruct).lpCreateParams;
  SetWindowLongPtrW(hWnd, GWLP_USERDATA, boxed_i32_ptr as LONG_PTR);
  return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we can use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw">GetWindowLongPtrW</a>
to get our windows's custom user data:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`GetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw)
  pub fn GetWindowLongPtrW(hWnd: HWND, nIndex: c_int) -&gt; LONG_PTR;
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, uh, we'll print out the current value or something.
I guess, each time we go to <code>WM_PAINT</code> we'll print the value and add 1 to it.
Just any old thing to see that it's working.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_PAINT =&gt; {
  let ptr = GetWindowLongPtrW(hWnd, GWLP_USERDATA) as *mut i32;
  println!(&quot;Current ptr: {}&quot;, *ptr);
  *ptr += 1;
  let mut ps = PAINTSTRUCT::default();
  let hdc = BeginPaint(hWnd, &amp;mut ps);
  let _success = FillRect(hdc, &amp;ps.rcPaint, (COLOR_WINDOW + 1) as HBRUSH);
  EndPaint(hWnd, &amp;ps);
}
<span class="boring">}
</span></code></pre></pre>
<p>That'll print 5, and then if you force a bunch of paint messages you can see it count up.
The easiest way to do that is to adjust the window's size so that it's small,
then drag it to be bigger.
Each time the window's size expands it triggers new paint messages.</p>
<p>Of course, we also can't forget that cleanup code we promised.
The way we do the cleanup is to just turn the raw pointer back into a <code>Box&lt;i32&gt;</code>.
The drop code for the Box type will handle the rest for us.
Of course, we should only do this right as the window is being destroyed.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_DESTROY =&gt; {
  let ptr = GetWindowLongPtrW(hWnd, GWLP_USERDATA) as *mut i32;
  Box::from_raw(ptr);
  println!(&quot;Cleaned up the box.&quot;);
  PostQuitMessage(0);
}
<span class="boring">}
</span></code></pre></pre>
<p>And finally, I think we're done!</p>
<h2><a class="header" href="#hey-what-about-the-triangle" id="hey-what-about-the-triangle">Hey, What About The Triangle?</a></h2>
<p>Well, there's several ways to draw a triangle in windows.
You can use DirectX, OpenGL, Vulkan, probably some other ways I don't even know about.
This lesson is going to stop at <em>just</em> the window creation part.
Then, each other lesson on a particular Windows drawing API can assume you've read this as a baseline level of understanding.</p>
<h2><a class="header" href="#fixing-that-stupid-cursor" id="fixing-that-stupid-cursor">Fixing That Stupid Cursor</a></h2>
<p>Before I finished this, I really wanted to figure out what was going on with that cursor.</p>
<p>So what I did was, first we want to handle the <code>WM_SETCURSOR</code> event,
and then in the event we call the <code>SetCursor</code> function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
    WM_SETCURSOR =&gt; {
      let hInstance = GetModuleHandleW(null());
      let cursor = LoadCursorW(hInstance, IDC_ARROW);
      let _old_cursor = SetCursor(cursor);
      //
      return 1;
    }
// ...

#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`SetCursor`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setcursor)
  pub fn SetCursor(hCursor: HCURSOR) -&gt; HCURSOR;
}
const WM_SETCURSOR: u32 = 0x0020;
<span class="boring">}
</span></code></pre></pre>
<p>Alright, so, what happens if you do that?
Well, the cursor disappears entirely.
What? Why?
Well, let's check the docs for <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setcursor">SetCursor</a>.
Hm, hmm, hmmmm, yeah.</p>
<blockquote>
<p>If this parameter is NULL, the cursor is removed from the screen.</p>
</blockquote>
<p>Okay, so we must be getting null for <code>cursor</code>.
So <code>LoadCursorW(hInstance, IDC_ARROW)</code> is returning null...
and that's how we're setting <code>wc.hCursor</code> during startup!
So we must have been setting null <em>this whole time</em>.
What fools we've been.</p>
<p>Okay let's check out the MSDN guide on <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/setting-the-cursor-image">Setting the Cursor Image</a>.
They've got some sample code:</p>
<pre><code class="language-cpp">hCursor = LoadCursor(NULL, cursor);
SetCursor(hCursor);
</code></pre>
<p>Oh. Huh. So, you're supposed to pass null to the load call?
I guess that makes sense.
I mean we had an HINSTANCE sitting around and we just used it,
but whe you think about it,
our own executable file probably <em>doesn't</em> contain the <code>IDC_ARROW</code> cursor.</p>
<p>So if we delete the cursor handling code from the window procedure,
and just adjust the startup code to be correct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut wc = WNDCLASSW::default();
wc.lpfnWndProc = Some(window_procedure);
wc.hInstance = hInstance;
wc.lpszClassName = sample_window_class_wn.as_ptr();
wc.hCursor = unsafe { LoadCursorW(null_mut(), IDC_ARROW) };
<span class="boring">}
</span></code></pre></pre>
<p>Well now our cursor works just fine!</p>
<p>The day is saved!</p>
<h2><a class="header" href="#windows_subsystem" id="windows_subsystem">windows_subsystem</a></h2>
<p>A last note before we go.
The Windows operating system has two &quot;subsystems&quot; that a program can target: &quot;console&quot; and &quot;windows&quot;.
The only difference to us Rust folks is if the program gets a console allocated for it automatically by the system.</p>
<ul>
<li>A console subsystem program gets a console allocated for it.
If you run it from an existing console it'll use that one,
but if you run it via other means it'll open a new console of its own while it's running.</li>
<li>A windows subsystem program does <em>not</em> get a console allocated for it.</li>
</ul>
<p>If you try to use standard output or standard error, such as with <code>println!</code> and <code>eprintln!</code>,
and there's no currently allocated console,
then the output goes nowhere.</p>
<p>By default, a Rust program is a console subsystem program.
This is fine, because it means that we can print debug messages.
However, it also means that if we give our program to a friend and they run it,
maybe by double clicking the executable in windows explorer,
then they'll see the window that we want open up <em>and also</em> they'll see a mysterious console open in the background.
If you really really mean for end users to see that console appear then that's fine,
but most people don't expect an extra console to appear when the run a Windows program.
It feels a little janky for this debug thing to show up along side the &quot;real&quot; program's window.</p>
<p>This is easy enough to fix.
If we use the <a href="https://doc.rust-lang.org/stable/reference/runtime.html#the-windows_subsystem-attribute">windows_subsystem</a>
attribute on our program we can pick the subsystem we want the program to use.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// at the top of the file
#![windows_subsystem = &quot;windows&quot;]
<span class="boring">}
</span></code></pre></pre>
<p>However, if we use that attribute directly then <em>even debugging builds</em> don't get a console.</p>
<p>Instead, I like to use <a href="https://doc.rust-lang.org/stable/reference/conditional-compilation.html?highlight=cfg_attr#the-cfg_attr-attribute">cfg_attr</a>
to set the <code>windows_subsystem</code> value any time we're <em>not</em> using debug assertions.
That's not exactly the same as &quot;whenever it's a release build&quot;, but close enough.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>And now we can send a release build of the program to our friends and have it act like they expect a normal Win32 program to act.</p>
<h1><a class="header" href="#win32-window-cleanup" id="win32-window-cleanup">Win32 Window Cleanup</a></h1>
<p>During our introduction to Win32 I said that we'd just write all our code into <code>main.rs</code>,
and then we could sort it into the library later.</p>
<p>Well, later is now.</p>
<h2><a class="header" href="#new-files" id="new-files">New Files</a></h2>
<p>This isn't very hard.
Cargo follows a &quot;convention over configuration&quot; style,
so as long as we do what it expects we won't even have to change <code>Cargo.toml</code> or anything.</p>
<p>First we copy <code>src/main.rs</code> into <code>examples/win32_window_standalone.rs</code>,
so that we can keep our nice small version that's all in one file.
Over time our library will build up,
and later lessons will refer to things we've put in our library already.
However, this first example can be understood in a single file,
without a person having to know what we've put into our library.
I think that's pretty valuable, so we will preserve this first draft for later viewing.</p>
<p>Then we make <code>src/lib.rs</code>.
This holds the top level items of the library.
Within the crate's module hierarchy, <code>lib.rs</code> is a module is <em>above</em> the other modules of the crate.
Within the filesystem on disk, <code>lib.rs</code> is a file <em>beside</em> the other files that make up the crate.
With <em>all other</em> modules, the default filesystem location for a module matches the module's logical crate location.
With <code>lib.rs</code> it's just slightly magical, so it has a different default filesystem location.
Sometimes people find this one exception confusing,
so I'm trying to be extra clear about what's going on regarding this point.</p>
<p>Next, since this is all Win32 specific stuff we'll be putting in the library right now,
which obviously doesn't work on all targets,
we'll make a <code>src/win32.rs</code> file,
and then declare it as a conditional module within the library.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

#[cfg(windows)]
pub mod win32;
<span class="boring">}
</span></code></pre></pre>
<p>Now, if we're on windows, we'll be able to use our nice <code>win32</code> module.</p>
<h2><a class="header" href="#put-the-declarations-in-the-library" id="put-the-declarations-in-the-library">Put The Declarations In The Library</a></h2>
<p>Okay first we put every single type, struct, const, and extern declaration into <code>win32.rs</code>.
We also have to make sure that all the fields and types are marked as <code>pub</code>.</p>
<p>Then we put a <code>use triangle_from_scratch::win32::*;</code> in our program.</p>
<p>The <code>main.rs</code> should only be left with <code>main</code> and <code>window_procedure</code>,
but the program should build and run exactly as before.</p>
<p>Also, I'm going to remove the <code>allow</code> attributes at the top of the <code>main.rs</code>,
and then convert the file to standard Rust naming for all the variables.
This doesn't make the program do better things, but it helps people read it.</p>
<h2><a class="header" href="#we-got-too-much-unsafe" id="we-got-too-much-unsafe">We Got Too Much Unsafe</a></h2>
<p>All this <code>unsafe</code> code isn't great.
Having <code>unsafe</code> code around means that if we aren't careful we don't get &quot;just&quot; a wrong output or an unexpected panic,
instead we get some sort of <em>Undefined Behavior</em> (UB).
UB <em>might</em> do what you expected, or it <em>might</em> segfault, or it <em>might</em> be a security vulnerability.
I'd rather not have a security vulnerability in my program,
so I'd like to reduce the amount of <code>unsafe</code> code in the program as much as I can.</p>
<p><code>/rant start</code></p>
<p>Let's be very plain: You cannot fully eliminate <code>unsafe</code>.</p>
<p>Fundamentally, interacting with the outside world is <code>unsafe</code>.
If your program doesn't have any <code>unsafe</code> <em>anywhere</em> in the call stack,
then it's not actually interacting with the world at all,
and that's a pretty useless program to be running.</p>
<p>Operating systems and device drivers aren't designed to be free of UB.
They are designed for you to pay attention, and ask for the right thing at the right time.
We have to run <code>unsafe</code> code to get <em>anything</em> useful done.</p>
<p>However, <code>unsafe</code> code is <strong>not</strong> automatically the end of everything.
It's code that <em>can</em> go wrong, but that doesn't means it <em>must</em> go wrong.</p>
<p>Fire can burn down your house, but you also need it to forge metal.</p>
<p><code>/rant end</code></p>
<p>Our job, every time we use an <code>unsafe</code> block, is to make sure,
either with compile time checks or runtime checks,
that we don't call any <code>unsafe</code> functions improperly.</p>
<p>It's &quot;that simple&quot;.
You know, &quot;just&quot; get good.</p>
<p>Every time we have an <code>unsafe</code> block, that block needs to be audited for correctness.
The less <code>unsafe</code> blocks we have, the less we need to audit.</p>
<p>Our strategy is that we want to put our <code>unsafe</code> blocks inside of safe functions,
and then the safe function performs whatever checks it needs to before actually making the <code>unsafe</code> function call.
That might mean a runtime check,
or the type system might even allow for static correctness to be known without a runtime check.
Either way, we get it right <em>once</em> in the safe wrapper function,
and then all other code only calls the safe function from there on.
Then we only have to audit the <code>unsafe</code> block in one location,
not everywhere all over the codebase.</p>
<p>I know, &quot;put it in a function&quot; is a very basic concept.
You could have thought of that too, I'm sure.
Still, sometimes it helps just to put the plan into words, even if it seems obvious.</p>
<h2><a class="header" href="#safe-wrapping-getmodulehandlew" id="safe-wrapping-getmodulehandlew">Safe Wrapping <code>GetModuleHandleW</code></a></h2>
<p>Alright so what can we <em>actually</em> make into safe functions?</p>
<p>Well the first thing the program does is call <code>GetModuleHandleW(null())</code>.
Is that legal?
I mean we can at least say that it seems intentional, that doesn't mean it's correct.
Let's checks the docs for <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew">GetModuleHandleW</a>.</p>
<blockquote>
<p>lpModuleName: ... If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).</p>
</blockquote>
<p>Okay, not only are we allowed to pass null, but if we do then we get a special sort of default-ish return value.</p>
<p>In terms of an interface for a wrapper function for this,
I think it'd be a little awkward to try and accept both null and non-null arguments and have it be ergonomic and stuff.
Thankfully, <em>we don't actually have to do that</em>.
We're just using the null argument style,
and if we use the non-null argument variant later we can just make it a totally separate function later.
So let's write a function for calling <code>GetModuleHandleW(null())</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns a handle to the file used to create the calling process (.exe file)
///
/// See [`GetModuleHandleW`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew)
pub fn get_process_handle() -&gt; HMODULE {
  // Safety: as per the MSDN docs.
  unsafe { GetModuleHandleW(null()) }
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can call that at the start of our <code>fn main()</code> in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hinstance = get_process_handle();
  // ...
</code></pre></pre>
<p>No <code>unsafe</code> block! One less thing to audit!</p>
<h2><a class="header" href="#safe-wrapping-loadcursorw" id="safe-wrapping-loadcursorw">Safe Wrapping <code>LoadCursorW</code></a></h2>
<p>So we go down a bit, the next <code>unsafe</code> function is <code>LoadCursorW</code>.
That one gave us some trouble for quite a while.
I was passing the wrong argument in the first position,
and then getting a null back without realizing it.
It wasn't actually UB, it was an allowed function call to make,
but I should have been checking the function's output and handling the error.
Forgetting to handle the error case is what was causing my downfall.</p>
<p>Let's have a look at <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw">LoadCursorW</a>.</p>
<p>We see that the <code>HINSTANCE</code> we pass has to be an executable file with a cursor in it.
That's a thing, did you know that?
You can put cursors and icons <em>inside</em> of executables and then programs can pick them out and use them.
I knew you could do that with icons for desktop shortcuts,
but I guess it works with cursors too.
Neat.</p>
<p>Right now the program says <code>LoadCursorW(null_mut(), IDC_ARROW)</code>, so can we pass null?
It doesn't say anything about null in the description for <code>hInstance</code>,
but lower down in the description for <code>lpCursorName</code> it says if you pass an <code>IDC_</code> value from the list as the <code>lpCursorName</code>,
then in that case you should set <code>hInstance</code> to null.</p>
<p>Like with how we wrapped <code>GetModuleHandleW</code>,
we don't need to make a <em>single</em> wrapper function that handles every possible case that <code>LoadCursorW</code> does.
Here, lets just make a function for loading the <code>IDC_</code> cursors.
If we want to load cursors out of non-null instances later on that can be a separate function.</p>
<p>And let's not forget to check that Return Value error case information:</p>
<blockquote>
<p>If the function succeeds, the return value is the handle to the newly loaded cursor.
If the function fails, the return value is NULL. To get extended error information, call <code>GetLastError</code>.</p>
</blockquote>
<p>Simple enough. What do the Remarks have to say? Ah, this part sounds important:</p>
<blockquote>
<p>This function returns a valid cursor handle only if the lpCursorName parameter is a pointer to a cursor resource.
If lpCursorName is a pointer to any type of resource other than a cursor (such as an icon),
the return value is not NULL, even though it is not a valid cursor handle.</p>
</blockquote>
<p>Yikes, so we want to be very sure that we're passing a value from that list of allowed values.</p>
<p>Okay, so what if we make an enum of what you're allowed to pass in.
On the Rust side, you can only have an enum of a real variant.
Constructing an improper enum is already UB, so we don't even have to think about that case.
If we define our enum properly then we know people will only be allowed to pass correct values.</p>
<p>And since things can error, let's use a <code>Result</code> type for the output.
For now, the error will just be the <code>()</code> type.
We'll come back here once we've looked at <code>GetLastError</code>,
and made ourselves a useful error code type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The predefined cursor styles.
pub enum IDCursor {
  /// Standard arrow and small hourglass
  AppStarting = 32650,
  /// Standard arrow
  Arrow = 32512,
  /// Crosshair
  Cross = 32515,
  /// Hand
  Hand = 32649,
  /// Arrow and question mark
  Help = 32651,
  /// I-beam
  IBeam = 32513,
  /// Slashed circle
  No = 32648,
  /// Four-pointed arrow pointing north, south, east, and west
  SizeAll = 32646,
  /// Double-pointed arrow pointing northeast and southwest
  SizeNeSw = 32643,
  /// Double-pointed arrow pointing north and south
  SizeNS = 32645,
  /// Double-pointed arrow pointing northwest and southeast
  SizeNwSe = 32642,
  /// Double-pointed arrow pointing west and east
  SizeWE = 32644,
  /// Vertical arrow
  UpArrow = 32516,
  /// Hourglass
  Wait = 32514,
}

/// Load one of the predefined cursors.
///
/// See [`LoadCursorW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw)
pub fn load_predefined_cursor(cursor: IDCursor) -&gt; Result&lt;HCURSOR, ()&gt; {
  // Safety: The enum only allows values from the approved list. See MSDN.
  let hcursor =
    unsafe { LoadCursorW(null_mut(), MAKEINTRESOURCEW(cursor as WORD)) };
  if hcursor.is_null() {
    Err(())
  } else {
    Ok(hcursor)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>That's a lot of variants, but the wrapper function is still very simple.
The tag values of the enum are each set to the <code>MAKEINTRESOURCEW</code> input shown in the documentation.
When an enum is passed in, <code>cursor as WORD</code> will give us the tag value.
We pass that value to <code>MAKEINTRESOURCEW</code>, then it goes off to <code>LoadCursorW</code>.</p>
<p>Also, remember that <code>MAKEINTRESOURCEW</code> is just some type casting stuff,
it's not actually making any resources we have to free up later.</p>
<p>Let's check our <code>fn main</code> with this update:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(window_procedure);
  wc.hInstance = hinstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();
  wc.hCursor = load_predefined_cursor(IDCursor::Arrow).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Ah ha! Now it's clear that we're going for a predefined cursor,
<em>and</em> it's clear that the call could fail.
Of course, using <code>unwrap</code> isn't a very robust way to solve problems.
It's <em>absolutely</em> not allowed in a good library (always pass the error back up!),
but in a binary it's &quot;sorta okay, I guess&quot;, particularly since this is a demo.</p>
<h2><a class="header" href="#partial-wrapping-registerclassw" id="partial-wrapping-registerclassw">Partial Wrapping <code>RegisterClassW</code></a></h2>
<p><em>Partial</em> wrapping?
I can hear you asking.</p>
<p>Yeah, you can't always make it safe.
But you can at least <em>almost</em> always make it better typed.</p>
<p>If we have a look at the docs of our next <code>unsafe</code> function call,
<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw">RegisterClassW</a>,
It says &quot;You must fill the structure with the appropriate class attributes before passing it to the function.&quot;</p>
<p>But the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw">WNDCLASSW</a>
type is full of pointers to strings and stuff.
There's like three things that <em>aren't</em> pointers,
and then all the rest is a pile of pointers.
We don't have any easy way to track the validity of all the fields.
I'm sure it's possible to do something here to make sure that all fields are valid all the time,
but I'm also sure that the amount of effort that it would take would exceed the effort to just use an <code>unsafe</code> block and audit that code every so often.</p>
<p>So we're going to make a wrapper function,
but we'll leave it as an <code>unsafe</code> function.
Even then, we can give a better input and output type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Registers a window class struct.
///
/// ## Safety
///
/// All pointer fields of the struct must be valid.
///
/// See [`RegisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw)
pub unsafe fn register_class(window_class: &amp;WNDCLASSW) -&gt; Result&lt;ATOM, ()&gt; {
  let atom = RegisterClassW(window_class);
  if atom == 0 {
    Err(())
  } else {
    Ok(atom)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, and then the usage code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let atom = unsafe { register_class(&amp;wc) }.unwrap_or_else(|()| {
    let last_error = unsafe { GetLastError() };
    panic!(&quot;Could not register the window class, error code: {}&quot;, last_error);
  });
<span class="boring">}
</span></code></pre></pre>
<p>Hmm.
At first glance, things didn't improve as much as we might have wanted.
Ah, but here's an interesting thing.
Now <code>atom</code> is marked as a <em>totally unused</em> variable.
We can't even forget to check for an error any more,
someone else already did that for us.</p>
<p>Still, the error case is very wonky.
That needs a fix.</p>
<h2><a class="header" href="#safe-wrapping-getlasterror" id="safe-wrapping-getlasterror">Safe Wrapping <code>GetLastError</code></a></h2>
<p>I'm pretty sure I remember how <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>
worked.
It was super simple, right?
Yeah, it just gives you the thread-local last-error value.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the thread-local last-error code value.
///
/// See [`GetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
pub fn get_last_error() -&gt; DWORD {
  unsafe { GetLastError() }
}
<span class="boring">}
</span></code></pre></pre>
<p>Done.
Right?</p>
<p>Naw, of course not.
Keep reading.</p>
<blockquote>
<p>To obtain an error string for system error codes, use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function.
For a complete list of error codes provided by the operating system, see <a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes">System Error Codes</a>.</p>
</blockquote>
<p>So we want to be able to print out the error string.
Really, the least we can do for our users.
Let's just have a quick look at <code>FormatMessage</code> and... oh... oh my...
You see that function signature?
There's flags, there's pointers, there's even a <code>va_list</code> thing we don't know about.
Oof.</p>
<h2><a class="header" href="#a-newtype-for-the-error-code" id="a-newtype-for-the-error-code">A Newtype For The Error Code</a></h2>
<p>Okay, okay.
When there's a lot to do, one step at a time is usually the best way to do it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct Win32Error(pub DWORD);
<span class="boring">}
</span></code></pre></pre>
<p>But, unlike the other types so far, this type is really intended to be shown to people.
For this, there's two main traits that Rust supports:</p>
<ul>
<li><code>Debug</code> is for when you want to show the value <em>to a Rust programmer</em>.</li>
<li><code>Display</code> is for when you want to show the value <em>to the general public</em>.</li>
</ul>
<p>So for our Debug impl, it can just show &quot;Win32Error(12)&quot; or similar.
This is exactly what a derived <code>Debug</code> impl will do, so we'll use the derive:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
#[repr(transparent)]
pub struct Win32Error(pub DWORD);
<span class="boring">}
</span></code></pre></pre>
<p>For Display we can't derive an implementation.
I don't mean that we <em>shouldn't</em> derive an implementation,
but that we literally cannot.
The standard library literally doesn't offer a derive for the <code>Display</code> trait.
That's because the standard library is managed by people who are very silly.
They have a silly concern that a derived Display impl &quot;might&quot; not show the right sort of info.
Instead of saying &quot;if the derive doesn't do the right thing for you, write the impl by hand&quot;,
they just completely refuse to offer a derive at all.
Like I said, completely silly.</p>
<p>But we won't dwell on that too much,
because even if the derive was there, we wouldn't be able to use it in this case.</p>
<p>Instead... we get to use everyone's favorite function.... <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagew">FormatMessageW</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl core::fmt::Display for Win32Error {
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    todo!(&quot;call FormatMessageW&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>First we define the extern we need:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type LPCVOID = *const core::ffi::c_void;
pub type va_list = *mut c_char;
pub type c_char = i8;
#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`FormatMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagew)
  pub fn FormatMessageW(
    dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD,
    lpBuffer: LPWSTR, nSize: DWORD, Arguments: va_list,
  ) -&gt; DWORD;
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's go through each argument one by one.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl core::fmt::Display for Win32Error {
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    let dwFlags = todo!();
    let lpSource = todo!();
    let dwMessageId = todo!();
    let dwLanguageId = todo!();
    let lpBuffer = todo!();
    let nSize = todo!();
    let Arguments = todo!();
    let dword = unsafe {
      FormatMessageW(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        lpBuffer,
        nSize,
        Arguments,
      )
    };
    todo!(&quot;call FormatMessageW&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>dwFlags</code> lets us control a lot of options.
Looking carefully, it seems like we want <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>,
which makes <code>FormatMessageW</code> perform the allocation of a large enough buffer.
But then... if we use this <code>lpBuffer</code> gets a little odd.
More on that in a moment.
We also want <code>FORMAT_MESSAGE_FROM_SYSTEM</code>, since these are system errors.
All done? Not quite.
If we skip ahead down the page to &quot;Security Remarks&quot; then we see that we need <code>FORMAT_MESSAGE_IGNORE_INSERTS</code> too.
<em>Now</em> are we done?
Hmm, if we set the low-order byte we can fiddle the line length, but we don't need that.
We'll leave it as 0.</li>
<li><code>lpSource</code> is the location of the message definition.
It's only used if our message is from an hmodule or a string.
Since our message is from the system the argument is ignored,
so we'll leave this as null.</li>
<li><code>dwMessageId</code> is the identifier of the requested message.
That means the error code, so we'll set <code>self.0</code> here.</li>
<li><code>dwLanguageId</code> is the language identifier of the message.
Happily, if we just pass 0, then it'll basically look up the best message it can,
and then format that. So we'll just pass 0.</li>
<li><code>lpBuffer</code> is... hey we had to remember something about this!
Okay so because we're using <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>...
well <em>normally</em> this would be interpreted as <code>LPWSTR</code> (pointer to a null-terminated wide string).
However, since we're using <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>,
instead the function will use our pointer as a pointer to the start of a buffer.
The <code>lpBuffer</code> is written with the buffer start info,
and then we read it back after the function completes,
and we get our allocation that way.
So, in our use case, the <code>lpBuffer</code> arg is a pointer <em>to a pointer</em>.
We have to be careful about this point.</li>
<li><code>nSize</code> is the size of the output buffer, if you're providing the output buffer,
or it's the minimum output buffer size you want if you're using <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>.
We don't have any minimum needs, so we'll give 0.</li>
<li><code>Arguments</code> is the insert arguments for the formatting.
However, we're using <code>FORMAT_MESSAGE_IGNORE_INSERTS</code>, so we'll pass null.</li>
</ul>
<p><strong>Returns:</strong> what we get back is the number of <code>TCHAR</code> values stored in the buffer,
<em>excluding</em> the final null character.
A <code>TCHAR</code> is either an <code>i8</code> (for <code>A</code> functions) or a <code>u16</code> (for <code>W</code> functions).</p>
<p>Okay, so, let's review what we've got so far, because this is a lot of little things:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl core::fmt::Display for Win32Error {
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    let dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER
      | FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS;
    let lpSource = null_mut();
    let dwMessageId = self.0;
    let dwLanguageId = 0;
    let mut buffer: *mut u16 = null_mut();
    let lpBuffer = &amp;mut buffer as *mut *mut u16 as *mut u16;
    let nSize = 0;
    let Arguments = null_mut();
    let tchar_count_excluding_null = unsafe {
      FormatMessageW(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        lpBuffer,
        nSize,
        Arguments,
      )
    };
    todo!(&quot;read the buffer&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>So if we got a count of 0, of if the buffer is still null,
then there was some sort of problem.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if tchar_count_excluding_null == 0 || buffer.is_null() {
  // some sort of problem happened. we can't usefully get_last_error since
  // Display formatting doesn't let you give an error value.
  return Err(core::fmt::Error);
} else {
  todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>If there was no problem then we need to access the buffer.
The simplest way is to turn it into a slice:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    } else {
      let buffer_slice: &amp;[u16] = unsafe {
        core::slice::from_raw_parts(buffer, tchar_count_excluding_null as usize)
      };
      todo!()
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now we can decode the data with <a href="https://doc.rust-lang.org/core/char/fn.decode_utf16.html">decode_utf16</a>.
This iterates over the <code>u16</code> values, producing <code>Result&lt;char, DecodeUtf16Error&gt;</code> as it goes.
If there was any decoding error, let's just use the standard <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">Unicode Replacement Character</a> instead.
Then we put whatever character we've got into the output.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for decode_result in
  core::char::decode_utf16(buffer_slice.iter().copied())
{
  let ch = decode_result.unwrap_or('�');
  write!(f, &quot;{}&quot;, ch)?;
}
<span class="boring">}
</span></code></pre></pre>
<p>Cool.
All done?
Ah, not quite.</p>
<p>Remember how we had <code>FormatMessageW</code> allocate the buffer for us?
We need to free that buffer or we'll have a memory leak.
A memory leak is <em>safe</em>, but it's still <em>bad</em>.</p>
<p>There's more than one allocation system within Windows.
To free this memory, <code>FormatMessageW</code> says that we need to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree">LocalFree</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type HLOCAL = HANDLE;
#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`LocalFree`](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree)
  pub fn LocalFree(hMem: HLOCAL) -&gt; HLOCAL;
}
<span class="boring">}
</span></code></pre></pre>
<p>So where's our call to <code>FreeLocal</code> go?
At the end, right?
Except we also have all those <code>?</code> operators on the writing.
Any of those can early return from the function.</p>
<p>Let's use the magic of <code>Drop</code> to solve our problem.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OnDropLocalFree(HLOCAL);
impl Drop for OnDropLocalFree {
  fn drop(&amp;mut self) {
    unsafe { LocalFree(self.0) };
  }
}
let _on_drop = OnDropLocalFree(buffer as HLOCAL);
let buffer_slice: &amp;[u16] = unsafe {
  core::slice::from_raw_parts(buffer, tchar_count_excluding_null as usize)
};
for decode_result in
  core::char::decode_utf16(buffer_slice.iter().copied())
{
  let ch = decode_result.unwrap_or('�');
  write!(f, &quot;{}&quot;, ch)?;
}
Ok(())
<span class="boring">}
</span></code></pre></pre>
<p>Isn't that cool?
I think it's pretty cool.</p>
<p>One small note: we have to be sure to bind it to a local variable.
If we didn't bind it to a local variable, or if we bound it to the special <code>_</code> variable,
then the struct would drop <em>immediately</em> (before we read the buffer),
and then things would go very wrong.</p>
<p>If we test it out with error code 0, we can see &quot;The operation completed successfully.\r\n&quot;.
Hmm, let's eat up those newline characters though. We didn't want those.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match decode_result {
  Ok('\r') | Ok('\n') =&gt; write!(f, &quot; &quot;)?,
  Ok(ch) =&gt; write!(f, &quot;{}&quot;, ch)?,
  Err(_) =&gt; write!(f, &quot;�&quot;)?,
}
<span class="boring">}
</span></code></pre></pre>
<p>that's better.</p>
<p>One other note: if the 29th bit is set, then it's an application error.
The system doesn't know how to format those, so we won't even ask it.
Instead, we'll just show display that and return early.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    if self.0 &amp; (1 &lt;&lt; 29) &gt; 0 {
      return write!(f, &quot;Win32ApplicationError({})&quot;, self.0);
    }
<span class="boring">}
</span></code></pre></pre>
<p>We want our error getting function to use this great new type we worked on:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the thread-local last-error code value.
///
/// See [`GetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
pub fn get_last_error() -&gt; Win32Error {
  Win32Error(unsafe { GetLastError() })
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we can update our stuff that returns <code>Result</code> types to use this error type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_predefined_cursor(cursor: IDCursor) -&gt; Result&lt;HCURSOR, Win32Error&gt; {
  // ...
}

pub unsafe fn register_class(
  window_class: &amp;WNDCLASSW,
) -&gt; Result&lt;ATOM, Win32Error&gt; {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>There's also the <a href="https://doc.rust-lang.org/std/error/trait.Error.html">std::error::Error</a> trait.
It's a bit of a mess right now, but there's a Working Group trying to develop things to be better in the future.
At the moment, we might as well implement <code>std::error::Error</code> for our error type,
just to be potentially more compatible with the rest of the Rust ecosystem.
It's not like we even have to do anything, it's all default methods:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::error::Error for Win32Error {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#window-creation" id="window-creation">Window Creation</a></h2>
<p>The next <code>unsafe</code> function that our <code>main</code> calls is <code>CreateWindowExW</code>.
This one is one heck of a swiss-army-chainsaw of a function.
See, it turns out that, in Win32, not only are the things we think of as windows &quot;windows&quot;,
but <em>tons</em> of the GUI elements are &quot;windows&quot; too.
It's all windows, everywhere, all over the place.</p>
<p>So <code>CreateWindowExW</code> has like a million options it can do.
It also has a ton of arguments that can't be easily verified.
It's just as bad as <code>register_class</code>,
the only difference is that the arguments are passed as arguments,
instead of being stuffed into a struct and then passed as a single struct.</p>
<p>Like we did with with <code>register_class</code>,
we're gonna basically skip on the verification and leave it as <code>unsafe</code>.
What we will do is give it a <code>Result</code> for the output,
so that we enforce the error handling on ourselves.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Creates a window.
///
/// See [`CreateWindowExW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw)
pub unsafe fn create_window_ex_w(
  ex_style: DWORD, class_name: LPCWSTR, window_name: LPCWSTR, style: DWORD,
  x: c_int, y: c_int, width: c_int, height: c_int, parent: HWND, menu: HMENU,
  instance: HINSTANCE, param: LPVOID,
) -&gt; Result&lt;HWND, Win32Error&gt; {
  let hwnd = CreateWindowExW(
    ex_style,
    class_name,
    window_name,
    style,
    x,
    y,
    width,
    height,
    parent,
    menu,
    instance,
    param,
  );
  if hwnd.is_null() {
    Err(get_last_error())
  } else {
    Ok(hwnd)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ugh.
Are we really adding value here?
Isn't the point to like, you know, cut down on accidents?
Let's simplify this.</p>
<ul>
<li>First of all, we'll just accept <code>&amp;str</code> and then make wide strings ourselves.
This lets us use string literals, and the extra allocation isn't a huge deal.
We're already calling the OS to make a window, so this isn't a &quot;hot path&quot; function.</li>
<li>Next, we won't accept <code>ex_style</code> or <code>style</code> values.
We'll just pick some &quot;good default&quot; values to use.
Since a user can always just bypass our decision if they really want to
(by calling <code>CreateWindowExW</code> themselves), it's fine.</li>
<li>Instead of accepting <code>x</code> and <code>y</code>, we'll just take an <code>Option&lt;[i32;2]&gt;</code> as the position.
If you give a <code>Some</code> then it uses the two array values as the <code>x</code> and <code>y</code>.
If you give a <code>None</code> then both <code>x</code> and <code>y</code> will be <code>CW_USEDEFAULT</code>, which gives a default position.
This is <em>much</em> simpler than the normal rules for how <code>CW_USEDEFAULT</code> works.
The normal rules seriously take up about two paragraphs of the <code>CreateWindowExW</code> documentation.</li>
<li>Also, the window size can be <code>[i32; 2]</code>.
It doesn't seem particularly useful to keep the ability to have a default size.
It's not a huge burden to have the caller always pick a size.</li>
<li>We don't need to specify a parent window.
We'll always pass null, so that's one less thing for the caller to think about.</li>
<li>We don't need to specify a custom menu to use.
A null argument here means to use the class window,
so if we wanna change the menu we'd change it on the window class.
Again, one less thing for the caller to think about in the 99% case.</li>
<li>The instance isn't useful to pass in,
we can just have <code>create_app_window</code> look up the instance itself.</li>
<li>We'll rename <code>param</code> to <code>create_param</code>.
Normally, the styles used can change the meaning of this pointer.
With the styles we're using, this will be the argument to the <code>WM_NCCREATE</code> event.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn create_app_window(
  class_name: &amp;str, window_name: &amp;str, position: Option&lt;[i32; 2]&gt;,
  [width, height]: [i32; 2], create_param: LPVOID,
) -&gt; Result&lt;HWND, Win32Error&gt; {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>That's a <em>lot</em> less for the caller to think about.
We can call it at moderate improvement.</p>
<h2><a class="header" href="#messages" id="messages">Messages</a></h2>
<p>Next would be <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>,
but I'm not sure we can provide much help there.
We don't have a general window abstraction where we can be sure that a <code>HWND</code> is real or not.
So even if we made an enum for the second arg, it'd be an <code>unsafe</code> function overall.
There's also no error value to help fix up into an <code>Option</code> or <code>Result</code>.
I suppose we'll skip over it for now.</p>
<p>Instead, let's have a look at <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew">GetMessageW</a>.
Here's a function where I think we can make some improvements.</p>
<p>The basic output of <code>GetMessageW</code> is 0 for a quit event,
or non-zero for anything else,
and if the &quot;anything else&quot; was an error, then it's specifically -1.
That's because it's <em>kinda</em> intended to be used with C's looping constructs,
where test expressions evaluating to 0 will cancel the loop.
Except, it doesn't work well with C loops because you end up missing the error when you get -1
(which isn't 0, so you'd continue the loop).
In fact MSDN <em>specifically</em> tells you to not write <code>while (GetMessage(lpMsg, hWnd, 0, 0)) {</code>,
because it does the wrong thing,
and presumably enough people wrote that and asked why it went wrong that they put it on the docs to not do that.
So I think we can easily say that they picked the wrong sentinel values for <code>GetMessageW</code> to use.
Still, they are what they are,
we'll just adapt a bit.
Instead, let's focus on if we got a message or not,
and then we can worry about if it was a quit event in the calling code.
What we want is something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets a message from the thread's message queue.
///
/// The message can be for any window from this thread,
/// or it can be a non-window message as well.
///
/// See [`GetMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew)
#[inline(always)]
pub fn get_any_message() -&gt; Result&lt;MSG, Win32Error&gt; {
  let mut msg = MSG::default();
  let output = unsafe { GetMessageW(&amp;mut msg, null_mut(), 0, 0) };
  if output == -1 {
    Err(get_last_error())
  } else {
    Ok(msg)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then in <code>main</code> adjust how we call it just a bit:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
  match get_any_message() {
    Ok(msg) =&gt; {
      if msg.message == WM_QUIT {
        break;
      }
      unsafe {
        TranslateMessage(&amp;msg);
        DispatchMessageW(&amp;msg);
      }
    }
    Err(e) =&gt; panic!(&quot;Error when getting from the message queue: {}&quot;, e),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, we can make <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> safe too.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Translates virtual-key messages into character messages.
///
/// The character messages go into your thread's message queue,
/// and you'll see them if you continue to consume messages.
///
/// **Returns:**
/// * `true` if the message was `WM_KEYDOWN`, `WM_KEYUP`, `WM_SYSKEYDOWN`, or
///   `WM_SYSKEYUP`.
/// * `true` for any other message type that generated a character message.
/// * otherwise `false`
///
/// See [`TranslateMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage)
pub fn translate_message(msg: &amp;MSG) -&gt; bool {
  0 != unsafe { TranslateMessage(msg) }
}
<span class="boring">}
</span></code></pre></pre>
<p>Can we make <code>DispatchMessageW</code> safe just as easily?
Sadly, no.
Using <code>DispatchMessageW</code> causes the window procedure to be called,
<em>or</em> it can cause a timer callback to be called.
Since a call to <code>DispatchMessageW</code> with a funky <code>MSG</code> value could make arbitrary functions get called,
and with arbitrary arguments,
then we cannot wrap <code>DispatchMessageW</code> in a safe way.
In the case of <code>main</code>, we can see that we're not messing with the fields of the message,
everything in the message is what the operating system said,
so we know the message content is &quot;real&quot; content.
However, if we put a safe version of <code>DispatchMessageW</code> into our library,
that library code wouldn't actually be correct for all possible message inputs.</p>
<h2><a class="header" href="#getset-window-long-pointer" id="getset-window-long-pointer">Get/Set Window Long Pointer</a></h2>
<p>When we're using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw">SetWindowLongPtrW</a>,
and also the <code>Get</code> version,
there's a lot of options going on.
Also, we're also not checking the error values properly at the moment.</p>
<p>What's supposed to happen with the <em>setter</em> is that you set a value,
and the return value is the previous value.
If there's an error, then you get 0 back (and you call <code>GetLastError</code>).
Except, if the previous value was 0, then you can't tell if things are wrong or not.
So what you do is you first call <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>,
which we haven't used yet,
and you set the error code to 0.
Then you do <code>SetWindowLongPtrW</code> and if you do get a 0,
then you can check the error code.
If the error code is still the 0 that you set it to,
then actually you had a &quot;successful&quot; 0.
The <code>GetWindowLongPtrW</code> behaves basically the same.</p>
<p>For now, we'll <em>only</em> support getting/setting the userdata pointer.
This simplifies the problem immensely.</p>
<p>First we need to declare that we'll be using <code>SetLastError</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`SetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror)
  pub fn SetLastError(dwErrCode: DWORD);
}
<span class="boring">}
</span></code></pre></pre>
<p>And we'll make this callable as a safe operation,</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets the thread-local last-error code value.
///
/// See [`SetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror)
pub fn set_last_error(e: Win32Error) {
  unsafe { SetLastError(e.0) }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can make an unsafe function for setting the userdata pointer.
We'll make it generic over whatever pointer type you want:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets the &quot;userdata&quot; pointer of the window (`GWLP_USERDATA`).
///
/// **Returns:** The previous userdata pointer.
///
/// [`SetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw)
pub unsafe fn set_window_userdata&lt;T&gt;(
  hwnd: HWND, ptr: *mut T,
) -&gt; Result&lt;*mut T, Win32Error&gt; {
  set_last_error(Win32Error(0));
  let out = SetWindowLongPtrW(hwnd, GWLP_USERDATA, ptr as LONG_PTR);
  if out == 0 {
    // if output is 0, it's only a &quot;real&quot; error if the last_error is non-zero
    let last_error = get_last_error();
    if last_error.0 != 0 {
      Err(last_error)
    } else {
      Ok(out as *mut T)
    }
  } else {
    Ok(out as *mut T)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And this lets us upgrade our window creation process a bit:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
    WM_NCCREATE =&gt; {
      println!(&quot;NC Create&quot;);
      let createstruct: *mut CREATESTRUCTW = lparam as *mut _;
      if createstruct.is_null() {
        return 0;
      }
      let ptr = (*createstruct).lpCreateParams as *mut i32;
      return set_window_userdata::&lt;i32&gt;(hwnd, ptr).is_ok() as LRESULT;
    }
<span class="boring">}
</span></code></pre></pre>
<p>The getter for the userdata pointer is basically the same deal.
Again, we're making it generic so you can ask for the pointer as pointing to any type,
and then it'll do the cast for you.
If you <em>forget</em> to say a type you'll get a type inference error,
which is good in this case, because you don't want to forget the type:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the &quot;userdata&quot; pointer of the window (`GWLP_USERDATA`).
///
/// **Returns:** The userdata pointer.
///
/// [`GetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw)
pub unsafe fn get_window_userdata&lt;T&gt;(hwnd: HWND) -&gt; Result&lt;*mut T, Win32Error&gt; {
  set_last_error(Win32Error(0));
  let out = GetWindowLongPtrW(hwnd, GWLP_USERDATA);
  if out == 0 {
    // if output is 0, it's only a &quot;real&quot; error if the last_error is non-zero
    let last_error = get_last_error();
    if last_error.0 != 0 {
      Err(last_error)
    } else {
      Ok(out as *mut T)
    }
  } else {
    Ok(out as *mut T)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can adjust how WM_DESTROY and WM_PAINT are handled.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
    WM_DESTROY =&gt; {
      match get_window_userdata::&lt;i32&gt;(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          Box::from_raw(ptr);
          println!(&quot;Cleaned up the box.&quot;);
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null, no cleanup&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr to clean it up: {}&quot;, e)
        }
      }
      PostQuitMessage(0);
    }
    WM_PAINT =&gt; {
      match get_window_userdata::&lt;i32&gt;(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          println!(&quot;Current ptr: {}&quot;, *ptr);
          *ptr += 1;
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr: {}&quot;, e)
        }
      }
      let mut ps = PAINTSTRUCT::default();
      let hdc = BeginPaint(hwnd, &amp;mut ps);
      let _success = FillRect(hdc, &amp;ps.rcPaint, (COLOR_WINDOW + 1) as HBRUSH);
      EndPaint(hwnd, &amp;ps);
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#postquitmessage" id="postquitmessage">PostQuitMessage</a></h2>
<p>This one is easy to make safe:
you give it an exit code, and that exit code goes with the WM_QUIT message you get back later on.</p>
<p>There's nothing that can go wrong, so we just wrap it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Indicates to the system that a thread has made a request to terminate
/// (quit).
///
/// The exit code becomes the `wparam` of the [`WM_QUIT`] message your message
/// loop eventually gets.
///
/// [`PostQuitMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage)
pub fn post_quit_message(exit_code: c_int) {
  unsafe { PostQuitMessage(exit_code) }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we just put that as the last line of the <code>WM_DESTROY</code> branch.</p>
<h2><a class="header" href="#beginpaint" id="beginpaint">BeginPaint</a></h2>
<p>Our next target is <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint">BeginPaint</a>,
which is another thing that's simple to make easier to use when you've got Rust types available.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Prepares the specified window for painting.
///
/// On success: you get back both the [`HDC`] and [`PAINTSTRUCT`]
/// that you'll need for future painting calls (including [`EndPaint`]).
///
/// [`BeginPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint)
pub unsafe fn begin_paint(
  hwnd: HWND,
) -&gt; Result&lt;(HDC, PAINTSTRUCT), Win32Error&gt; {
  let mut ps = PAINTSTRUCT::default();
  let hdc = BeginPaint(hwnd, &amp;mut ps);
  if hdc.is_null() {
    Err(get_last_error())
  } else {
    Ok((hdc, ps))
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#fillrect" id="fillrect">FillRect</a></h2>
<p>Using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect">FillRect</a>
you can paint using an HBRUSH <em>or</em> a system color.</p>
<p>We only want to support the system color path.
First we make an enum for all the system colors.
This is a little fiddly because some values are named more than once,
and so we have to pick just a single canonical name for each value,
but it's not too bad:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See [`GetSysColor`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getsyscolor)
pub enum SysColor {
  _3dDarkShadow = 21,
  _3dLight = 22,
  ActiveBorder = 10,
  ActiveCaption = 2,
  AppWorkspace = 12,
  /// Button face, also &quot;3D face&quot; color.
  ButtonFace = 15,
  /// Button highlight, also &quot;3D highlight&quot; color.
  ButtonHighlight = 20,
  /// Button shadow, also &quot;3D shadow&quot; color.
  ButtonShadow = 16,
  ButtonText = 18,
  CaptionText = 9,
  /// Desktop background color
  Desktop = 1,
  GradientActiveCaption = 27,
  GradientInactiveCaption = 28,
  GrayText = 17,
  Highlight = 13,
  HighlightText = 14,
  HotLight = 26,
  InactiveBorder = 11,
  InactiveCaption = 3,
  InactiveCaptionText = 19,
  InfoBackground = 24,
  InfoText = 23,
  Menu = 4,
  MenuHighlight = 29,
  MenuBar = 30,
  MenuText = 7,
  ScrollBar = 0,
  Window = 5,
  WindowFrame = 6,
  WindowText = 8,
}
<span class="boring">}
</span></code></pre></pre>
<p>and then we make a function to fill in with a system color:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Fills a rectangle with the given system color.
///
/// When filling the specified rectangle, this does **not** include the
/// rectangle's right and bottom sides. GDI fills a rectangle up to, but not
/// including, the right column and bottom row, regardless of the current
/// mapping mode.
///
/// [`FillRect`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect)
pub unsafe fn fill_rect_with_sys_color(
  hdc: HDC, rect: &amp;RECT, color: SysColor,
) -&gt; Result&lt;(), ()&gt; {
  if FillRect(hdc, rect, (color as u32 + 1) as HBRUSH) != 0 {
    Ok(())
  } else {
    Err(())
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#endpaint" id="endpaint">EndPaint</a></h2>
<p>You might think that <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint">EndPaint</a>
has some sort of error code we're ignoring.
It returns a BOOL right?
Actually when you check the docs, &quot;The return value is always nonzero&quot;.
In other words, the function might as well return nothing.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See [`EndPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint)
pub unsafe fn end_paint(hwnd: HWND, ps: &amp;PAINTSTRUCT) {
  EndPaint(hwnd, ps);
}
<span class="boring">}
</span></code></pre></pre>
<p>Not a big gain in terms of API quality.
However, this way the caller can at least see they're supposed to pass a real paint struct,
and not possibly a null pointer.
Also, now it's clear that there's no output value.
We'll call it a small win.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
      match begin_paint(hwnd) {
        Ok((hdc, ps)) =&gt; {
          let _ = fill_rect_with_sys_color(hdc, &amp;ps.rcPaint, SysColor::Window);
          end_paint(hwnd, &amp;ps);
        }
        Err(e) =&gt; {
          println!(&quot;Couldn't begin painting: {}&quot;, e)
        }
      }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#a-painting-closure" id="a-painting-closure">A Painting Closure</a></h2>
<p>Is it easy to mess up the whole begin/end painting thing?
Yeah, I could see that going wrong.
One thing we might want to <em>try</em> is having a function that takes closure to do painting.</p>
<p>The function signature for this is pretty gnarly,
because <em>anything</em> with a closure is gnarly.</p>
<p>The closure is going to get three details it needs to know from the <code>PAINTSTRUCT</code>:</p>
<ul>
<li>The HDC.</li>
<li>If the background needs to be erased or not.</li>
<li>The target rectangle for painting.
Everything else in the <code>PAINTSTRUCT</code> is just system reserved info that we don't even care about.</li>
</ul>
<p>Our library function will get the HWND and the closure.
It starts the painting,
runs the closure,
and then ends the painting.
Remember that we want the painting to be ended <em>regardless</em> of success/failure of the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Performs [`begin_paint`] / [`end_paint`] around your closure.
pub unsafe fn do_some_painting&lt;F, T&gt;(hwnd: HWND, f: F) -&gt; Result&lt;T, Win32Error&gt;
where
  F: FnOnce(HDC, bool, RECT) -&gt; Result&lt;T, Win32Error&gt;,
{
  let (hdc, ps) = begin_paint(hwnd)?;
  let output = f(hdc, ps.fErase != 0, ps.rcPaint);
  end_paint(hwnd, &amp;ps);
  output
}
<span class="boring">}
</span></code></pre></pre>
<p>Neat!</p>
<p>Note that, to write this, we needed to make <code>RECT</code> a <code>Copy</code> type.
Most all the C structs we're declaring should be Debug, Clone, Copy, etc.
We just didn't add all the impls at the time.</p>
<p>What's it look like in practice?
Not too bad at all:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
    WM_PAINT =&gt; {
      match get_window_userdata(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          let ptr = ptr as *mut i32;
          println!(&quot;Current ptr: {}&quot;, *ptr);
          *ptr += 1;
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr: {}&quot;, e)
        }
      }
      do_some_painting(hwnd, |hdc, _erase_bg, target_rect| {
        let _ = fill_rect_with_sys_color(hdc, &amp;target_rect, SysColor::Window);
        Ok(())
      })
      .unwrap_or_else(|e| println!(&quot;error during painting: {}&quot;, e));
    }
<span class="boring">}
</span></code></pre></pre>
<p>What I like the most about this is that the user can still call <code>begin_paint</code> and <code>end_paint</code> on their own if they want.
Because maybe we make some abstraction workflow thing that doesn't work for them,
and they can just skip around our thing if that's the case.</p>
<h2><a class="header" href="#using-the-exit-code" id="using-the-exit-code">Using The Exit Code</a></h2>
<p>One thing we don't do is pass along the <code>wParam</code> from the <code>MSG</code> struct when we see <code>WM_QUIT</code>.
We're <em>supposed</em> to pass that as the exit code of our process.
For this, we can use <code>std::process:exit</code>, and then pass the value, instead of just breaking the loop.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in main
  loop {
    match get_any_message() {
      Ok(msg) =&gt; {
        if msg.message == WM_QUIT {
          std::process::exit(msg.wParam as i32);
        }
        translate_message(&amp;msg);
        unsafe {
          DispatchMessageW(&amp;msg);
        }
      }
      Err(e) =&gt; panic!(&quot;Error when getting from the message queue: {}&quot;, e),
    }
  }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#done" id="done">Done</a></h2>
<p>Is our program perfect?
Naw, but I think it's good enough for now.</p>
<h1><a class="header" href="#loading-open-gl" id="loading-open-gl">Loading Open GL</a></h1>
<p>While the <em>usage</em> of Open GL is basically the same across platforms,
the precise details of how to first initialize Open GL varies.</p>
<p>The general idea is that we need to do two things:</p>
<ol>
<li>Create an <a href="https://www.khronos.org/opengl/wiki/OpenGL_Context">Open GL context</a>
and make it &quot;current&quot;.
A GL context is what holds all of the drawing state for GL.
Each GL Context must only be current in a single thread at a time,
otherwise you'll get undefined behavior.
Also, a thread's current context is a thread-local variable,
so you can't have more than one context current in a thread at a time.
Also, a context is associated with a particular window's drawing area.
Usually you have just one window,
and so you have only one GL context,
meaning that don't need to worry about any of that.
If you're trying to use GL with more than one window at a time,
things can get tricky.</li>
<li>Load the GL function pointers.
Unfortunately, you can't access GL like it was a normal dynamic library.
At least, you can't on Windows and Linux.
We'll have a whole fun time
<a href="https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions">loading function pointers</a> manually.</li>
</ol>
<h2><a class="header" href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h2>
<p>For this portion of the guide I'd like to give an incredible acknowledgement to
<a href="https://github.com/glowcoil">glowcoil</a>, who wrote the
<a href="https://github.com/glowcoil/raw-gl-context">raw-gl-context</a>
crate, which gives come very clean and clear examples of how you open a GL context on the major platforms.</p>
<h1><a class="header" href="#loading-opengl-with-win32" id="loading-opengl-with-win32">Loading OpenGL With Win32</a></h1>
<p>On Windows, turning on OpenGL requires... a few steps.</p>
<p>It's honestly gonna seem borderline silly when I explain it.</p>
<p>Basically, Microsoft would rather that you use DirectX,
the Windows-exclusive graphics card API,
and so they don't really bother to make it <em>easy</em> to turn on OpenGL.</p>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>In terms of documentation for opening a GL Context,
you can check out <a href="https://docs.microsoft.com/en-us/windows/win32/opengl/rendering-contexts">MSDN</a>
like we've done before,
but you'll probably get a little more help from
<a href="https://www.khronos.org/opengl/wiki/Creating_an_OpenGL_Context_(WGL)">The OpenGL Wiki</a>.
Technically, the context creation process is fully outside the OpenGL specification.
However, they still explain how to create a context on the wiki because it's obviously a necessary step to use GL.</p>
<h1><a class="header" href="#expanding-the-cleaned-up-win32-example" id="expanding-the-cleaned-up-win32-example">Expanding the &quot;Cleaned Up&quot; Win32 Example</a></h1>
<p>For this lesson we'll be using the &quot;cleaned up&quot; Win32 example as our starting point.</p>
<h2><a class="header" href="#device-context" id="device-context">Device Context</a></h2>
<p>The first thing we need to do is adjust the <code>WNDCLASSW</code> value that we register.</p>
<p>According to the <a href="https://www.khronos.org/opengl/wiki/Creating_an_OpenGL_Context_(WGL)">wiki article</a>,
we need to set <code>CS_OWNDC</code> in the <code>style</code> field so that each window has its own device context:</p>
<pre><pre class="playground"><code class="language-rust edition2018">// in our fn main()
  // ...
  let mut wc = WNDCLASSW::default();
  wc.style = CS_OWNDC; // NEW
  // ...
</code></pre></pre>
<p>If we search for <code>CS_OWNDC</code> <a href="https://docs.microsoft.com/en-us/search/?scope=Desktop&amp;terms=CS_OWNDC">in the MSDN pages</a>,
it leads us to the <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-class-styles">Window Class Styles</a> page.
Ah, so many things to look at.
We know we want <code>CS_OWNDC</code>,
but if we glance at the other options there's mostly stuff we don't need.
Interestingly, it looks like maybe you need to enable double-click support on your window if you want it?
We don't need that now, but just something to remember if you want it later on.
There's also <code>CS_HREDRAW</code> and <code>CS_VREDRAW</code>,
which cause the full window to be redrawn if the window changes horizontal or vertical size.
That seems fairly handy, it means we just always draw everything if the window resizes,
and we don't have to think about re-drawing sub-regions.
We'll use those too.</p>
<p>All three new declarations can go directly into the <code>win32</code> module of our library:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/win32.rs

/// Allocates a unique device context for each window in the class.
pub const CS_OWNDC: u32 = 0x0020;

/// Redraws the entire window if a movement or size adjustment changes the width
/// of the client area.
pub const CS_HREDRAW: u32 = 0x0002;

/// Redraws the entire window if a movement or size adjustment changes the
/// height of the client area.
pub const CS_VREDRAW: u32 = 0x0001;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pixel-format-descriptor" id="pixel-format-descriptor">Pixel Format Descriptor</a></h2>
<p>Next we need to fill out a <a href="https://docs.microsoft.com/en-us/windows/win32/api/Wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a>.
This is our <em>request</em> for what we want the eventual pixel format of the window to be.
We can't be sure we'll get exactly what we ask for,
but if we ask for something fairly common we'll probably get it.</p>
<p>Looking at the MSDN page for <code>PIXELFORMATDESCRIPTOR</code>,
there's two very important fields that are different from any struct fields we've seen so far.
The <code>nSize</code> and <code>nVersion</code> fields specify the struct's size (in bytes) along with a version number.
That's a little... odd.</p>
<h3><a class="header" href="#versioned-structs" id="versioned-structs">Versioned Structs</a></h3>
<p>Because <em>of course</em> you know what the size of the struct is, right?
You're using struct <code>S</code> from crate <code>foo-x.y.z</code>,
and in version <code>x.y.z</code> of crate <code>foo</code> the struct <code>S</code> had... whatever the fields are.
If the fields ever <em>were</em> changed,
that would have to be published as a new version of the crate,
then the compiler would know about the change when you updated the dependency.
So there's totally no reason to ever write down the size of the struct within the struct itself, right?</p>
<p>Nope.</p>
<p>This is one area where C still has Rust completely beat: binary stability.</p>
<p>See the folks at Microsoft want programs to <em>last</em>.
Like, they want programs to keep working <em>forever</em> if possible.
Users have their old video games,
or their old art software,
or their old whatever software,
and those users want their stuff to keep working when there's a Windows Update.
And they often <em>won't</em> update to a newer version of Windows if it breaks their stuff.
So Microsoft would really rather that all old programs keep working for as long as possible,
because they want to keep selling you new versions of Windows.
They're usually pretty good at this.</p>
<p>A few months ago I downloaded an old tile editor from an ancient website,
and the site said &quot;this was tested on windows 95, it might work on windows 98&quot;.
I opened it up on my modern Windows 10 machine, and it worked.
A few of the GUI buttons looked kinda &quot;off&quot;, visually, but it worked.
I was able to edit some tiles and export them,
despite the program being from so long ago that the author didn't know if it would work on Windows 98.
That's a stability success story right there.</p>
<p>On the other hand, Diablo 2 (circa 2000) doesn't run on Windows 10 without the 1.14 patch,
because the 1.0 patch level of the game can't launch the program for whatever reason.
So the world isn't always as stable as we'd like.</p>
<p>&quot;Lokathor what <em>are</em> you rambling on about? <code>cargo</code> uses SemVer, it's all plenty stable!&quot;</p>
<p>No friends, no, hold on, not quite.</p>
<p>You see <code>cargo</code> builds the whole universe from source every time.
When you use <code>foo-x.y.z</code> in your project,
<code>cargo</code> downloads the <em>source</em> for that crate with that version,
then it builds that crate version right on your own machine,
and then it builds your crate and links it all together.
This all works out when you're making just <em>one</em> program.
I mean, clean build times are huge, but whatever, right?</p>
<p>However, when you're asking <em>two</em> programs to communicate with each other,
obviously you need to be able to update one of the programs without updating the other program right away (or ever).
Which means that if you ever want to be able to change your message format in the future,
you need to put a version on that kind of message <em>now</em>,
so that the possibility to change the version number later is left open to you.</p>
<p>&quot;Lokathor! We're only building one program! What are you even talking about!?&quot;</p>
<p>No, friends, <em>the operating system is the other program</em>.</p>
<p>&quot;...what?&quot;</p>
<p>Yeah, the operating system isn't magic.
It's just a program.
It's a program that runs programs for you.
And manages when they get to use the CPU and RAM and stuff.
So the word &quot;just&quot; is doing a lot of heavy lifting when I say &quot;it's just a program&quot;,
but ultimately that's true.</p>
<p>Which means that you'll often see things like the <code>PIXELFORMATDESCRIPTOR</code> struct,
where there's something that lets you say what version of the API's protocol you're intending to use when you make the API call.
The operating system looks at those signs, and does the right thing for the version you expect.</p>
<p>So you end up seeing this pattern a lot any time there's an interface that's intended to be stable over a long period of time.
It's used quite a bit within Win32, and it's <em>all over</em> in Vulkan, for example.</p>
<p>Okay, fun digression, let's get back to the task at hand.</p>
<h3><a class="header" href="#defining-pixelformatdescriptor" id="defining-pixelformatdescriptor">Defining PIXELFORMATDESCRIPTOR</a></h3>
<p>In terms of the fields, the <code>PIXELFORMATDESCRIPTOR</code> type is fairly obvious:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct PIXELFORMATDESCRIPTOR {
  pub nSize: WORD,
  pub nVersion: WORD,
  pub dwFlags: DWORD,
  pub iPixelType: BYTE,
  pub cColorBits: BYTE,
  pub cRedBits: BYTE,
  pub cRedShift: BYTE,
  pub cGreenBits: BYTE,
  pub cGreenShift: BYTE,
  pub cBlueBits: BYTE,
  pub cBlueShift: BYTE,
  pub cAlphaBits: BYTE,
  pub cAlphaShift: BYTE,
  pub cAccumBits: BYTE,
  pub cAccumRedBits: BYTE,
  pub cAccumGreenBits: BYTE,
  pub cAccumBlueBits: BYTE,
  pub cAccumAlphaBits: BYTE,
  pub cDepthBits: BYTE,
  pub cStencilBits: BYTE,
  pub cAuxBuffers: BYTE,
  pub iLayerType: BYTE,
  pub bReserved: BYTE,
  pub dwLayerMask: DWORD,
  pub dwVisibleMask: DWORD,
  pub dwDamageMask: DWORD,
}
<span class="boring">}
</span></code></pre></pre>
<p>However, since we want the type to <em>always</em> say it's size and version,
we'll have a <code>Default</code> impl that just sets the size and version for us.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for PIXELFORMATDESCRIPTOR {
  #[inline]
  #[must_use]
  fn default() -&gt; Self {
    let mut out: Self = unsafe { core::mem::zeroed() };
    out.nSize = core::mem::size_of::&lt;Self&gt;() as WORD;
    out.nVersion = 1;
    out
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#filling-our-our-pixelformatdescriptor" id="filling-our-our-pixelformatdescriptor">Filling Our Our PIXELFORMATDESCRIPTOR</a></h3>
<p>The wiki page suggests that we fill out our pixel format like this:</p>
<pre><code class="language-c">PIXELFORMATDESCRIPTOR pfd =
{
	sizeof(PIXELFORMATDESCRIPTOR),
	1,
	PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,    // Flags
	PFD_TYPE_RGBA,        // The kind of framebuffer. RGBA or palette.
	32,                   // Colordepth of the framebuffer.
	0, 0, 0, 0, 0, 0,
	0,
	0,
	0,
	0, 0, 0, 0,
	24,                   // Number of bits for the depthbuffer
	8,                    // Number of bits for the stencilbuffer
	0,                    // Number of Aux buffers in the framebuffer.
	PFD_MAIN_PLANE,
	0,
	0, 0, 0
};
</code></pre>
<p>Well, okay, sure, let's just kinda convert that into some Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2018">// after we register the class in fn main
  let pfd = PIXELFORMATDESCRIPTOR {
    dwFlags: PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
    iPixelType: PFD_TYPE_RGBA,
    cColorBits: 32,
    cDepthBits: 24,
    cStencilBits: 8,
    iLayerType: PFD_MAIN_PLANE,
    ..Default::default()
  };
</code></pre></pre>
<p>Oh that's actually pretty clear.
This time we're using the <a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax">functional update syntax</a>
for struct creation.
We haven't used that before,
so I'll link the reference there for you.
We could also use it in other places,
such as filling out our <code>WNDCLASSW</code> value.
Honestly, I don't even use it myself that much,
but I thought we'd just give it a try,
and see how it feels.</p>
<p>Anyway, now we need to declare a bunch of consts.</p>
<p>Except, the <code>PIXELFORMATDESCRIPTOR</code> page on MSDN <strong>doesn't</strong> list the values.</p>
<p>Guess it's back to grepping through the windows header files.
By the way, if you're not aware,
there's a very fast grep tool written in rust called <code>ripgrep</code> you might want to try.</p>
<pre><code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0&gt;rg &quot;PFD_DRAW_TO_WINDOW&quot;
um\wingdi.h
3640:#define PFD_DRAW_TO_WINDOW          0x00000004

C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0&gt;rg &quot;PFD_SUPPORT_OPENGL&quot;
um\wingdi.h
3643:#define PFD_SUPPORT_OPENGL          0x00000020
</code></pre>
<p>Looks like it's generally around line 3640 of <code>wingdi.h</code>,
so we just have a look at those defines and then do a little Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// [`PIXELFORMATDESCRIPTOR`] pixel type
pub const PFD_TYPE_RGBA: u8 = 0;
/// [`PIXELFORMATDESCRIPTOR`] pixel type
pub const PFD_TYPE_COLORINDEX: u8 = 1;

/// [`PIXELFORMATDESCRIPTOR`] layer type
pub const PFD_MAIN_PLANE: u8 = 0;
/// [`PIXELFORMATDESCRIPTOR`] layer type
pub const PFD_OVERLAY_PLANE: u8 = 1;
/// [`PIXELFORMATDESCRIPTOR`] layer type
pub const PFD_UNDERLAY_PLANE: u8 = u8::MAX /* was (-1) */;

pub const PFD_DOUBLEBUFFER: u32 = 0x00000001;
pub const PFD_STEREO: u32 = 0x00000002;
pub const PFD_DRAW_TO_WINDOW: u32 = 0x00000004;
pub const PFD_DRAW_TO_BITMAP: u32 = 0x00000008;
pub const PFD_SUPPORT_GDI: u32 = 0x00000010;
pub const PFD_SUPPORT_OPENGL: u32 = 0x00000020;
pub const PFD_GENERIC_FORMAT: u32 = 0x00000040;
pub const PFD_NEED_PALETTE: u32 = 0x00000080;
pub const PFD_NEED_SYSTEM_PALETTE: u32 = 0x00000100;
pub const PFD_SWAP_EXCHANGE: u32 = 0x00000200;
pub const PFD_SWAP_COPY: u32 = 0x00000400;
pub const PFD_SWAP_LAYER_BUFFERS: u32 = 0x00000800;
pub const PFD_GENERIC_ACCELERATED: u32 = 0x00001000;
pub const PFD_SUPPORT_DIRECTDRAW: u32 = 0x00002000;
pub const PFD_DIRECT3D_ACCELERATED: u32 = 0x00004000;
pub const PFD_SUPPORT_COMPOSITION: u32 = 0x00008000;

/// use with [`ChoosePixelFormat`] only
pub const PFD_DEPTH_DONTCARE: u32 = 0x20000000;
/// use with [`ChoosePixelFormat`] only
pub const PFD_DOUBLEBUFFER_DONTCARE: u32 = 0x40000000;
/// use with [`ChoosePixelFormat`] only
pub const PFD_STEREO_DONTCARE: u32 = 0x80000000;
<span class="boring">}
</span></code></pre></pre>
<p>When translating a C <code>#define</code> into a Rust declaration you've gotta use a little judgement.
In addition to looking at the raw numeric value,
you've gotta try and match the type of the const to the type of the place it gets used the most.
The pixel types and layer types get assigned to a field that's a <code>u8</code>, so we declare them as <code>u8</code>.
The flags all get combined and assigned to a field that's a <code>u32</code>, so we declare them as a <code>u32</code>.
In C it makes little difference (because C numbers will <em>generally</em> coerce automatically),
but in Rust we would have to write some casts somewhere if the types don't line up,
so we try to make our lives easy later by getting the declaration itself to have the most used type.</p>
<h2><a class="header" href="#choosepixelformat" id="choosepixelformat">ChoosePixelFormat</a></h2>
<p>Okay once we have a <code>PIXELFORMATDESCRIPTOR</code> value we call <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-choosepixelformat">ChoosePixelFormat</a>
to get a &quot;pixel format index&quot; that's the closest available pixel format to our request.</p>
<p>First we declare the external call of course:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// note: our first use of Gdi32!
#[link(name = &quot;Gdi32&quot;)]
extern &quot;system&quot; {
  /// [`ChoosePixelFormat`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-choosepixelformat)
  pub fn ChoosePixelFormat(
    hdc: HDC, ppfd: *const PIXELFORMATDESCRIPTOR,
  ) -&gt; c_int;
}
<span class="boring">}
</span></code></pre></pre>
<p>Of course, this function can fail,
so we want to have a <code>Result</code> as the output type in the final version we'll use.
Instead of doing a whole thing with the raw calls,
and then doing an entire revision phase to make all the &quot;nicer&quot; versions after that,
we'll just jump right to the part where we make the nice version as we cover each new function.
Personally, I think that seeing the &quot;all raw calls&quot; version of something is a little fun once,
but once you start making things Rusty you might as well keep doing it as you go.
We won't always know exactly how we want to use each extern function the moment we first see it,
but each wrapper function is generally quite small,
so we can usually make a change if we realize something new later on.</p>
<p>Let's check the docs:</p>
<blockquote>
<p>If the function succeeds, the return value is a pixel format index (one-based) that is the closest match to the given pixel format descriptor.
If the function fails, the return value is zero. To get extended error information, call GetLastError.</p>
</blockquote>
<p>The docs do <em>not</em> seem to indicate that you're allowed to pass a null pointer for the pixel format descriptor,
so we can just require a reference instead of requiring a const pointer.</p>
<p>Okay, easy enough:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See [`ChoosePixelFormat`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-choosepixelformat)
pub unsafe fn choose_pixel_format(
  hdc: HDC, ppfd: &amp;PIXELFORMATDESCRIPTOR,
) -&gt; Result&lt;c_int, Win32Error&gt; {
  let index = ChoosePixelFormat(hdc, ppfd);
  if index != 0 {
    Ok(index)
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Can we improve it any more than this?
The only thing I can think of would be <em>maybe</em> to newtype that <code>c_int</code> value.
We could make a <code>PixelFormatIndex</code> or something if we wanted to.
I sure thought about it for a while, sitting on the bus.
But now that I'm at the keyboard, it doesn't seem very error prone even as just a <code>c_int</code>.
I think we're fine without doing that extra work.</p>
<p>Code you don't write at all is more valuable than code you do write.
Or, something wise sounding like that.</p>
<p>Alright so we're gonna set up a <code>PIXELFORMATDESCRIPTOR</code> and choose a pixel format:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let pfd = PIXELFORMATDESCRIPTOR {
    dwFlags: PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
    iPixelType: PFD_TYPE_RGBA,
    cColorBits: 32,
    cDepthBits: 24,
    cStencilBits: 8,
    iLayerType: PFD_MAIN_PLANE,
    ..Default::default()
  };
  // Oops, we don't have an HDC value yet!
  let pixel_format_index = unsafe { choose_pixel_format(hdc, &amp;pfd) }.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>AGH! With no HDC from anywhere we can't choose a pixel format!
Blast, and such.</p>
<h3><a class="header" href="#we-need-an-hdc" id="we-need-an-hdc">We Need An HDC</a></h3>
<p>Alright since we need an HDC to choose a pixel format,
we'll move the choosing <em>after</em> we create our window,
before we show it,
and then we can get the DC for our window,
and it'll all be fine.</p>
<p>We'll need to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdc">GetDC</a>
to get the HDC value for our window,
and then eventually <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-releasedc">ReleaseDC</a>
at some point.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`GetDC`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdc)
  pub fn GetDC(hWnd: HWND) -&gt; HDC;

  /// [`ReleaseDC`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-releasedc)
  pub fn ReleaseDC(hWnd: HWND, hDC: HDC) -&gt; c_int;
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, now we're ready.
So we're going to get the DC for our window,
choose a pixel format,
we'll set that pixel format (see next section),
and then we're all good, right?</p>
<p>No.</p>
<p>Again, of course, this has to be more complicated than that.</p>
<p>If we glance back at <a href="https://www.khronos.org/opengl/wiki/Creating_an_OpenGL_Context_(WGL)">the wiki</a>
we'll see a section called &quot;Proper Context Creation&quot; with the following warning:</p>
<blockquote>
<p><strong>Warning:</strong> Unfortunately, Windows does not allow the user to change the pixel format of a window.
You get to set it exactly once.
Therefore, if you want to use a different pixel format from the one your fake context used (for sRGB or multisample framebuffers, or just different bit-depths of buffers),
you must destroy the window entirely and recreate it after we are finished with the dummy context.</p>
</blockquote>
<p>...oookay</p>
<p>Sure, we'll just do <em>that</em> thing.</p>
<h3><a class="header" href="#making-a-fake-window" id="making-a-fake-window">Making A Fake Window</a></h3>
<p>So in between registering the class and making the <code>i32</code> box,
we've got quite a bit of new middle work</p>
<pre><pre class="playground"><code class="language-rust edition2018">// in fn main
  let _atom = unsafe { register_class(&amp;wc) }.unwrap();

  // fake window stuff
  let pfd = PIXELFORMATDESCRIPTOR {
    dwFlags: PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
    iPixelType: PFD_TYPE_RGBA,
    cColorBits: 32,
    cDepthBits: 24,
    cStencilBits: 8,
    iLayerType: PFD_MAIN_PLANE,
    ..Default::default()
  };
  let fake_hwnd = unsafe {
    create_app_window(
      sample_window_class,
      &quot;Fake Window&quot;,
      None,
      [1, 1],
      null_mut(),
    )
  }
  .unwrap();
  let fake_hdc = unsafe { GetDC(fake_hwnd) };
  let pf_index = unsafe { choose_pixel_format(fake_hdc, &amp;pfd) }.unwrap();
  // TODO: SetPixelFormat
  assert!(unsafe { ReleaseDC(fake_hwnd, fake_hdc) } != 0);
  assert!(unsafe { DestroyWindow(fake_hwnd) } != 0);

  // real window stuff
  let lparam: *mut i32 = Box::leak(Box::new(5_i32));
</code></pre></pre>
<p>Okay, I guess that makes sense.</p>
<p>Hmm, I don't like those mysterious <code>!= 0</code> parts.
Let's wrap those into our lib.
And since we're wrapping <code>ReleaseDC</code> we might as well do <code>GetDC</code> too.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See [`GetDC`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdc)
pub unsafe fn get_dc(hwnd: HWND) -&gt; Option&lt;HDC&gt; {
  let hdc = GetDC(hwnd);
  if hdc.is_null() {
    None
  } else {
    Some(hdc)
  }
}

/// See [`ReleaseDC`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-releasedc)
#[must_use]
pub unsafe fn release_dc(hwnd: HWND, hdc: HDC) -&gt; bool {
  let was_released = ReleaseDC(hwnd, hdc);
  was_released != 0
}

/// See [`DestroyWindow`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow)
pub unsafe fn destroy_window(hwnd: HWND) -&gt; Result&lt;(), Win32Error&gt; {
  let destroyed = DestroyWindow(hwnd);
  if destroyed != 0 {
    Ok(())
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the output <em>isn't</em> always a result.
Since <code>GetDC</code> doesn't have any error code to report (according to its docs), we just use <code>Option</code>.
Similarly, <code>ReleaseDC</code> doesn't seem to report an error code, so we just return a <code>bool</code>.
However, in both cases we want to encourage the caller to actually use the output,
because not checking these could lead to nasty memory leaks.
So we use the <code>#[must_use]</code> attribute to ensure that they get a warning if they don't use the output value.</p>
<p>Which means our program looks more like this now:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let fake_hdc = unsafe { get_dc(fake_hwnd) }.unwrap();
  let pf_index = unsafe { choose_pixel_format(fake_hdc, &amp;pfd) }.unwrap();
  // TODO: SetPixelFormat
  assert!(unsafe { release_dc(fake_hwnd, fake_hdc) });
  unsafe { destroy_window(fake_hwnd) }.unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setpixelformat" id="setpixelformat">SetPixelFormat</a></h2>
<p>Once we've chosen a pixel format, we set it to the HDC with <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpixelformat">SetPixelFormat</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;Gdi32&quot;)]
extern &quot;system&quot; {
  /// [`SetPixelFormat`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpixelformat)
  pub fn SetPixelFormat(
    hdc: HDC, format: c_int, ppfd: *const PIXELFORMATDESCRIPTOR,
  ) -&gt; BOOL;
}
<span class="boring">}
</span></code></pre></pre>
<p>Which we wrap up a little nicer like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets the pixel format of an HDC.
///
/// * If it's a window's HDC then it sets the pixel format of the window.
/// * You can't set a window's pixel format more than once.
/// * Call this *before* creating an OpenGL context.
/// * OpenGL windows should use [`WS_CLIPCHILDREN`] and [`WS_CLIPSIBLINGS`]
/// * OpenGL windows should *not* use `CS_PARENTDC`
///
/// See [`SetPixelFormat`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpixelformat)
pub unsafe fn set_pixel_format(
  hdc: HDC, format: c_int, ppfd: &amp;PIXELFORMATDESCRIPTOR,
) -&gt; Result&lt;(), Win32Error&gt; {
  let success = SetPixelFormat(hdc, format, ppfd);
  if success != 0 {
    Ok(())
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Oh, what's that?
Yeah we need some extra window styles.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Excludes the area occupied by child windows when drawing occurs within the
/// parent window.
///
/// This style is used when creating the parent window.
pub const WS_CLIPCHILDREN: u32 = 0x02000000;

/// Clips child windows relative to each other.
///
/// That is, when a particular child window receives a WM_PAINT message,
/// the WS_CLIPSIBLINGS style clips all other overlapping child windows out of
/// the region of the child window to be updated. If WS_CLIPSIBLINGS is not
/// specified and child windows overlap, it is possible, when drawing within the
/// client area of a child window, to draw within the client area of a
/// neighboring child window.
pub const WS_CLIPSIBLINGS: u32 = 0x04000000;

pub unsafe fn create_app_window(
  // ...
  let hwnd = CreateWindowExW(
    WS_EX_APPWINDOW | WS_EX_OVERLAPPEDWINDOW,
    class_name_null.as_ptr(),
    window_name_null.as_ptr(),
    // New Style!
    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
    x,
    y,
    width,
    height,
    null_mut(),
    null_mut(),
    get_process_handle(),
    create_param,
  );
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, so now we can set the pixel format on our fake HDC:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let fake_hdc = unsafe { get_dc(fake_hwnd) }.unwrap();
  let pf_index = unsafe { choose_pixel_format(fake_hdc, &amp;pfd) }.unwrap();
  unsafe { set_pixel_format(fake_hdc, pf_index, &amp;pfd) }.unwrap();
  assert!(unsafe { release_dc(fake_hwnd, fake_hdc) });
  unsafe { destroy_window(fake_hwnd) }.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Hmm, wait, hold on.
So we choose a pixel format, and get an index.
How do we check if that index is close to what we wanted?
Ah, the docs say we need <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-describepixelformat">DescribePixelFormat</a>.
This is one of those &quot;does two things at once&quot; functions.
When it succeeds, not only is the return code a non-zero value,
it's the maximum index of pixel formats.
So you can call the function with a null pointer to just get the maximum index.
We'll split this up into two different functions.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the maximum pixel format index for the HDC.
///
/// Pixel format indexes are 1-based.
///
/// To print out info on all the pixel formats you'd do something like this:
/// ```no_run
/// # use triangle_from_scratch::win32::*;
/// let hdc = todo!(&quot;create a window to get an HDC&quot;);
/// let max = unsafe { get_max_pixel_format_index(hdc).unwrap() };
/// for index in 1..=max {
///   let pfd = unsafe { describe_pixel_format(hdc, index).unwrap() };
///   todo!(&quot;print the pfd info you want to know&quot;);
/// }
/// ```
///
/// See [`DescribePixelFormat`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-describepixelformat)
pub unsafe fn get_max_pixel_format_index(
  hdc: HDC,
) -&gt; Result&lt;c_int, Win32Error&gt; {
  let max_index = DescribePixelFormat(
    hdc,
    1,
    size_of::&lt;PIXELFORMATDESCRIPTOR&gt;() as _,
    null_mut(),
  );
  if max_index == 0 {
    Err(get_last_error())
  } else {
    Ok(max_index)
  }
}

/// Gets the pixel format info for a given pixel format index.
///
/// See [`DescribePixelFormat`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-describepixelformat)
pub unsafe fn describe_pixel_format(
  hdc: HDC, format: c_int,
) -&gt; Result&lt;PIXELFORMATDESCRIPTOR, Win32Error&gt; {
  let mut pfd = PIXELFORMATDESCRIPTOR::default();
  let max_index = DescribePixelFormat(
    hdc,
    format,
    size_of::&lt;PIXELFORMATDESCRIPTOR&gt;() as _,
    &amp;mut pfd,
  );
  if max_index == 0 {
    Err(get_last_error())
  } else {
    Ok(pfd)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>So we'll print out our pixel format info when we boot the program, seems neat to know.
We just throw a <code>#[derive(Debug)]</code> on the <code>PIXELFORMATDESCRIPTOR</code> struct and add a little bit to our <code>main</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  if let Ok(pfd) = unsafe { describe_pixel_format(fake_hdc, pf_index) } {
    println!(&quot;{:?}&quot;, pfd);
  } else {
    println!(&quot;Error: Couldn't get pixel format description.&quot;);
  }
<span class="boring">}
</span></code></pre></pre>
<p>Let's give this a try and see what pixel format info prints out:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 1.34s
     Running `target\debug\triangle-from-scratch.exe`
NC Create
Create
PIXELFORMATDESCRIPTOR { nSize: 40, nVersion: 1, dwFlags: 33317, iPixelType: 0, cColorBits: 32, cRedBits: 8, cRedShift: 16, cGreenBits: 8, cGreenShift: 8, cBlueBits: 8, cBlueShift: 0, cAlphaBits: 0, cAlphaShift: 0, cAccumBits: 64, cAccumRedBits: 16, cAccumGreenBits: 16, cAccumBlueBits: 16, cAccumAlphaBits: 16, cDepthBits: 24, cStencilBits: 8, cAuxBuffers: 4, iLayerType: 0, bReserved: 0, dwLayerMask: 0, dwVisibleMask: 0, dwDamageMask: 0 }
userdata ptr is null, no cleanup
NC Create
Create
</code></pre>
<p>Uh... huh? So we're seeing the info, but there's no window!
Some sort of problem has prevented the real window from showing up.
If we comment out all the &quot;fake window&quot; stuff the real window comes back,
so some part of that code is at fault here.</p>
<p>Hmm.</p>
<p>What if we make a fake window class to go with our fake window?</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // fake window stuff
  let fake_window_class = &quot;Fake Window Class&quot;;
  let fake_window_class_wn = wide_null(fake_window_class);

  let mut fake_wc = WNDCLASSW::default();
  fake_wc.style = CS_OWNDC;
  fake_wc.lpfnWndProc = Some(DefWindowProcW);
  fake_wc.hInstance = get_process_handle();
  fake_wc.lpszClassName = fake_window_class_wn.as_ptr();

  let _atom = unsafe { register_class(&amp;fake_wc) }.unwrap();

  let pfd = // ...
  let fake_hwnd = unsafe {
    create_app_window(
      fake_window_class,
      &quot;Fake Window&quot;,
      None,
      [1, 1],
      null_mut(),
    )
  }
  .unwrap();
</code></pre></pre>
<p>Okay, now it works.
Not sure <em>what</em> the difference is here, but I guess we can investigate that later.
Only little problem is that now we have an extra window class floating around.
If we use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterclassw">UnregisterClassW</a>
we can clean that up.</p>
<p>With <code>UnregisterClassW</code> you can pass in a pointer to a class name,
<em>or</em> you can pass in an atom value.
We'll make a separate function for each style.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`UnregisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterclassw)
  pub fn UnregisterClassW(lpClassName: LPCWSTR, hInstance: HINSTANCE) -&gt; BOOL;
}

/// Un-registers the window class from the `HINSTANCE` given.
///
/// * The name must be the name of a registered window class.
/// * This requires re-encoding the name to null-terminated utf-16, which
///   allocates. Using [`unregister_class_by_atom`] instead does not allocate,
///   if you have the atom available.
/// * Before calling this function, an application must destroy all windows
///   created with the specified class.
///
/// See
/// [`UnregisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterclassw)
pub unsafe fn unregister_class_by_name(
  name: &amp;str, instance: HINSTANCE,
) -&gt; Result&lt;(), Win32Error&gt; {
  let name_null = wide_null(name);
  let out = UnregisterClassW(name_null.as_ptr(), instance);
  if out != 0 {
    Ok(())
  } else {
    Err(get_last_error())
  }
}

/// Un-registers the window class from the `HINSTANCE` given.
///
/// * The atom must be the atom of a registered window class.
/// * Before calling this function, an application must destroy all windows
///   created with the specified class.
///
/// See [`UnregisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterclassw)
pub unsafe fn unregister_class_by_atom(
  a: ATOM, instance: HINSTANCE,
) -&gt; Result&lt;(), Win32Error&gt; {
  let out = UnregisterClassW(a as LPCWSTR, instance);
  if out != 0 {
    Ok(())
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And here's another thing that went wrong when I tried to figure this &quot;window doesn't show up&quot; problem.
At one point I was registering the same class twice,
because my <code>fake_wc</code> had the same name string as the &quot;real&quot; <code>wc</code>.
Then I got this error:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target\debug\triangle-from-scratch.exe`        
PIXELFORMATDESCRIPTOR { nSize: 40, nVersion: 1, dwFlags: 33317, iPixelType: 0, cColorBits: 32, cRedBits: 8, cRedShift: 16, cGreenBits: 8, cGreenShift: 8, cBlueBits: 8, cBlueShift: 0, cAlphaBits: 0, cAlphaShift: 0, cAccumBits: 64, cAccumRedBits: 16, cAccumGreenBits: 16, cAccumBlueBits: 16, cAccumAlphaBits: 16, cDepthBits: 24, cStencilBits: 8, cAuxBuffers: 4, iLayerType: 0, bReserved: 0, dwLayerMask: 0, dwVisibleMask: 0, dwDamageMask: 0 }
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Win32Error(1410)', src\main.rs:63:46
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\triangle-from-scratch.exe` (exit code: 101)
</code></pre>
<p>Not helpful!
Error 1410, what on Earth does that mean?
So we should adjust the error lookups to happen in <code>Debug</code> as well as <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct Win32Error(pub DWORD);
impl std::error::Error for Win32Error {}

impl core::fmt::Debug for Win32Error {
  /// Displays the error using `FormatMessageW`
  ///
  /// ```
  /// use triangle_from_scratch::win32::*;
  /// let s = format!(&quot;{:?}&quot;, Win32Error(0));
  /// assert_eq!(&quot;The operation completed successfully.  &quot;, s);
  /// let app_error = format!(&quot;{:?}&quot;, Win32Error(1 &lt;&lt; 29));
  /// assert_eq!(&quot;Win32ApplicationError(536870912)&quot;, app_error);
  /// ```
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    // everything from before
  }
}
impl core::fmt::Display for Win32Error {
  /// Same as `Debug` impl
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    write!(f, &quot;{:?}&quot;, self)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>But what if you <em>really wanted that error number</em>.
Well, maybe you do, and for that, we can use the &quot;alternate&quot; flag.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    // ...
    if f.alternate() {
      return write!(f, &quot;Win32Error({})&quot;, self.0);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now if you format with &quot;{:?}&quot; (which is what <code>unwrap</code> uses)
then you get the message form,
and if you really want to see the number you can format with &quot;{:#?}&quot;.</p>
<p>Now when an <code>unwrap</code> goes bad it looks like this:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.87s
     Running `target\debug\triangle-from-scratch.exe`
PIXELFORMATDESCRIPTOR { nSize: 40, nVersion: 1, dwFlags: 33317, iPixelType: 0, cColorBits: 32, cRedBits: 8, cRedShift: 16, cGreenBits: 8, cGreenShift: 8, cBlueBits: 8, cBlueShift: 0, cAlphaBits: 0, cAlphaShift: 0, cAccumBits: 64, cAccumRedBits: 16, cAccumGreenBits: 16, cAccumBlueBits: 16, cAccumAlphaBits: 16, cDepthBits: 24, cStencilBits: 8, cAuxBuffers: 4, iLayerType: 0, bReserved: 0, dwLayerMask: 0, dwVisibleMask: 0, dwDamageMask: 0 }
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Class already exists.  ', src\main.rs:63:46
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\triangle-from-scratch.exe` (exit code: 101)
</code></pre>
<p>Ah, look, the class already existed, of course!</p>
<p>So finally we can set a pixel format on a fake window,
and then clean it all up,
and then make our real window.</p>
<h2><a class="header" href="#wglcreatecontext" id="wglcreatecontext">wglCreateContext</a></h2>
<p>As fun as it is to make a fake window and do not much with it and then throw it away,
it might be even better if we did something with it.</p>
<p>The point of all this is that we <em>want</em> to be able to create an OpenGL context with the latest version,
and other advanced features.
However, Windows only lets you directly make an OpenGL 1.1 context.
To make a context with a newer version than that, you need to use an extension.
To use an extension, you need to check the extension string to see what extensions are available.
To check the extension string, you need to have a current OpenGL context.</p>
<p>What we do is we use our fake window to make a fake GL context,
which will be for the old OpenGL 1.1,
then we can get the extension string to check what extensions are available.
This lets us use the &quot;advanced&quot; capabilities like &quot;making a context with a modern API version&quot;.</p>
<p>I told you at the start that this was gonna seem silly when I explained what was going on.
<a href="http://www.mspaintadventures.com/sweetbroandhellajeff/">I warned you about stairs bro!</a></p>
<p>Anyway, once we've gotten the info we need from the fake context then we close it,
and we close out all the other &quot;fake&quot; stuff,
and then we make the &quot;real&quot; stuff.</p>
<p>That means our next step is <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglcreatecontext">wglCreateContext</a>,
and also the inverse, <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wgldeletecontext">wglDeleteContext</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Handle (to a) GL Rendering Context
pub type HGLRC = HANDLE;

#[link(name = &quot;Opengl32&quot;)]
extern &quot;system&quot; {
  /// [`wglCreateContext`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglcreatecontext)
  pub fn wglCreateContext(Arg1: HDC) -&gt; HGLRC;

  /// [`wglDeleteContext`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wgldeletecontext)
  pub fn wglDeleteContext(Arg1: HGLRC) -&gt; BOOL;
}

/// See [`wglCreateContext`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglcreatecontext)
pub unsafe fn wgl_create_context(hdc: HDC) -&gt; Result&lt;HGLRC, Win32Error&gt; {
  let hglrc = wglCreateContext(hdc);
  if hglrc.is_null() {
    Err(get_last_error())
  } else {
    Ok(hglrc)
  }
}

/// Deletes a GL Context.
///
/// * You **cannot** use this to delete a context current in another thread.
/// * You **can** use this to delete the current thread's context. The context
///   will be made not-current automatically before it is deleted.
///
/// See
/// [`wglDeleteContext`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wgldeletecontext)
pub unsafe fn wgl_delete_context(hglrc: HGLRC) -&gt; Result&lt;(), Win32Error&gt; {
  let success = wglDeleteContext(hglrc);
  if success != 0 {
    Ok(())
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then in <code>main</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  unsafe { set_pixel_format(fake_hdc, pf_index, &amp;pfd) }.unwrap();
  let fake_hglrc = unsafe { wgl_create_context(fake_hdc) }.unwrap();

  // TODO: work with the fake context.

  // cleanup the fake stuff
  unsafe { wgl_delete_context(fake_hglrc) }.unwrap();
  assert!(unsafe { release_dc(fake_hwnd, fake_hdc) });
  unsafe { destroy_window(fake_hwnd) }.unwrap();
  unsafe { unregister_class_by_atom(fake_atom, instance) }.unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#wglmakecurrent" id="wglmakecurrent">wglMakeCurrent</a></h2>
<p>It's no use making and destroying this fake context if we don't make it current:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;Opengl32&quot;)]
extern &quot;system&quot; {
  /// [`wglMakeCurrent`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglmakecurrent)
  pub fn wglMakeCurrent(hdc: HDC, hglrc: HGLRC) -&gt; BOOL;
}

/// Makes a given HGLRC current in the thread and targets it at the HDC given.
///
/// * You can safely pass `null_mut` for both parameters if you wish to make no
///   context current in the thread.
///
/// See
/// [`wglMakeCurrent`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglmakecurrent)
pub unsafe fn wgl_make_current(
  hdc: HDC, hglrc: HGLRC,
) -&gt; Result&lt;(), Win32Error&gt; {
  let success = wglMakeCurrent(hdc, hglrc);
  if success != 0 {
    Ok(())
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Before we can use the context we have to make it current,
and before we destroy it we have to make it not be current.
On Windows we don't <em>have</em> to make it not-current,
but it's just good habit because on <em>other</em> systems you must make a context not-current before you destroy it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let fake_hglrc = unsafe { wgl_create_context(fake_hdc) }.unwrap();
  unsafe { wgl_make_current(fake_hdc, fake_hglrc) }.unwrap();

  // TODO: work with the fake context.

  // cleanup the fake stuff
  unsafe { wgl_make_current(null_mut(), null_mut()) }.unwrap();
  unsafe { wgl_delete_context(fake_hglrc) }.unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#wglgetprocaddress" id="wglgetprocaddress">wglGetProcAddress</a></h2>
<p>This is what we've been after the whole time!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// macros.rs

/// Turns a rust string literal into a null-terminated `&amp;[u8]`.
#[macro_export]
macro_rules! c_str {
  ($text:expr) =&gt; {{
    concat!($text, '\0').as_bytes()
  }};
}

// win32.rs

/// Pointer to an ANSI string.
pub type LPCSTR = *const c_char;
/// Pointer to a procedure of unknown type.
pub type PROC = *mut c_void;

#[link(name = &quot;Opengl32&quot;)]
extern &quot;system&quot; {
  /// [`wglGetProcAddress`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglgetprocaddress)
  pub fn wglGetProcAddress(Arg1: LPCSTR) -&gt; PROC;
}

/// Gets a GL function address.
///
/// The input should be a null-terminated function name string. Use the
/// [`c_str!`] macro for assistance.
///
/// * You must have an active GL context for this to work. Otherwise you will
///   always get an error.
/// * The function name is case sensitive, and spelling must be exact.
/// * All outputs are context specific. Functions supported in one rendering
///   context are not necessarily supported in another.
/// * The extension function addresses are unique for each pixel format. All
///   rendering contexts of a given pixel format share the same extension
///   function addresses.
///
/// This *will not* return function pointers exported by `OpenGL32.dll`, meaning
/// that it won't return OpenGL 1.1 functions. For those old function, use
/// [`GetProcAddress`].
pub fn wgl_get_proc_address(func_name: &amp;[u8]) -&gt; Result&lt;PROC, Win32Error&gt; {
  // check that we end the slice with a \0 as expected.
  match func_name.last() {
    Some(b'\0') =&gt; (),
    _ =&gt; return Err(Win32Error(Win32Error::APPLICATION_ERROR_BIT)),
  }
  // Safety: we've checked that the end of the slice is null-terminated.
  let proc = unsafe { wglGetProcAddress(func_name.as_ptr().cast()) };
  match proc as usize {
    // Some non-zero values can also be errors,
    // https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions#Windows
    0 | 1 | 2 | 3 | usize::MAX =&gt; return Err(get_last_error()),
    _ =&gt; Ok(proc),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This part is pretty simple.
We get a value back, and on success it's a pointer to a function.
We'll have to use <a href="https://doc.rust-lang.org/core/mem/fn.transmute.html">transmute</a>
to change the type into the proper function type,
but that's a concern for the caller to deal with.</p>
<h2><a class="header" href="#wglgetextensionsstringarb" id="wglgetextensionsstringarb">wglGetExtensionsStringARB</a></h2>
<p>Okay, now we can get function pointers.
This lets us check for <a href="https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions#Windows_2">platform specific extensions</a>
using the <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_extensions_string.txt">wglGetExtensionsStringARB</a> function.</p>
<p>For this, we'll want a helper macro to make C-style string literals for us:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Turns a rust string literal into a null-terminated `&amp;[u8]`.
#[macro_export]
macro_rules! c_str {
  ($text:expr) =&gt; {{
    concat!($text, '\0').as_bytes()
  }};
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we:</p>
<ul>
<li>lookup the function</li>
<li>call the function</li>
<li>get the info from the string pointer we get back</li>
</ul>
<p>This part is kinda <em>a lot</em> when you just write it all inline in <code>main</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  unsafe { wgl_make_current(fake_hdc, fake_hglrc) }.unwrap();

  #[allow(non_camel_case_types)]
  type wglGetExtensionsStringARB_t =
    unsafe extern &quot;system&quot; fn(HDC) -&gt; *const c_char;
  let wgl_get_extension_string_arb: Option&lt;wglGetExtensionsStringARB_t&gt; = unsafe {
    core::mem::transmute(
      wgl_get_proc_address(c_str!(&quot;wglGetExtensionsStringARB&quot;)).unwrap(),
    )
  };
  let mut extension_string: *const u8 =
    unsafe { (wgl_get_extension_string_arb.unwrap())(fake_hdc) }.cast();
  assert!(!extension_string.is_null());
  let mut s = String::new();
  unsafe {
    while *extension_string != 0 {
      s.push(*extension_string as char);
      extension_string = extension_string.add(1);
    }
  }
  println!(&quot;&gt; Extension String: {}&quot;, s);

  // cleanup the fake stuff
<span class="boring">}
</span></code></pre></pre>
<p>but if we break it down it's not so bad.
First let's put a function for gathering up a null-terminated byte string into our library.
This isn't Win32 specific, so we'll put it in <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gathers up the bytes from a pointer.
///
/// The byte sequence must be null-terminated.
///
/// The output excludes the null byte.
pub unsafe fn gather_null_terminated_bytes(mut p: *const u8) -&gt; Vec&lt;u8&gt; {
  let mut v = vec![];
  while *p != 0 {
    v.push(*p);
    p = p.add(1);
  }
  v
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have a <code>Vec&lt;u8&gt;</code> we want a <code>String</code>.
We can use <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8">String::from_utf8</a>,
but that returns a Result (it fails if the bytes aren't valid utf8).
There's also <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8_lossy">String::from_utf8_lossy</a>,
but if the bytes <em>are</em> valid utf8 then we get a borrow on our vec and we'd have to clone it to get the <code>String</code>.
What we <em>want</em> is to move the Vec if we can, and only allocate a new Vec if we must.
You'd think that this is a completely common thing to want,
but for whatever reason it's not in the standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PS: naming is hard :(

/// Converts a `Vec&lt;u8&gt;` into a `String` using the minimum amount of
/// re-allocation.
pub fn min_alloc_lossy_into_string(bytes: Vec&lt;u8&gt;) -&gt; String {
  match String::from_utf8(bytes) {
    Ok(s) =&gt; s,
    Err(e) =&gt; String::from_utf8_lossy(e.as_bytes()).into_owned(),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now in <code>win32.rs</code> we'll just <code>use super::*;</code> and make a function to get the extension string:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the WGL extension string for the HDC passed.
///
/// * This relies on [`wgl_get_proc_address`], and so you must have a context
///   current for it to work.
/// * If `wgl_get_proc_address` fails then an Application Error is generated.
/// * If `wgl_get_proc_address` succeeds but the extension string can't be
///   obtained for some other reason you'll get a System Error.
///
/// The output is a space-separated list of extensions that are supported.
///
/// See
/// [`wglGetExtensionsStringARB`](https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_extensions_string.txt)
pub unsafe fn wgl_get_extension_string_arb(
  hdc: HDC,
) -&gt; Result&lt;String, Win32Error&gt; {
  let f: wglGetExtensionsStringARB_t = core::mem::transmute(
    wgl_get_proc_address(c_str!(&quot;wglGetExtensionsStringARB&quot;))?,
  );
  let p: *const u8 =
    (f.ok_or(Win32Error(Win32Error::APPLICATION_ERROR_BIT))?)(hdc).cast();
  if p.is_null() {
    Err(get_last_error())
  } else {
    let bytes = gather_null_terminated_bytes(p);
    Ok(min_alloc_lossy_into_string(bytes))
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can try to get the extension string with a single call to that:</p>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs: fn main
  unsafe { wgl_make_current(fake_hdc, fake_hglrc) }.unwrap();

  let res = unsafe { wgl_get_extension_string_arb(fake_hdc) };
  println!(&quot;&gt; Extension String Result: {:?}&quot;, res);

  // cleanup the fake stuff
</code></pre></pre>
<p>And with a little iterator magic:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let extensions: Vec&lt;String&gt; =
    unsafe { wgl_get_extension_string_arb(fake_hdc) }
      .map(|s| {
        s.split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()).collect()
      })
      .unwrap_or(Vec::new());
  println!(&quot;&gt; Extensions: {:?}&quot;, extensions);
<span class="boring">}
</span></code></pre></pre>
<p>Which prints out alright:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target\debug\triangle-from-scratch.exe`        
&gt; Got Pixel Format: PIXELFORMATDESCRIPTOR { nSize: 40, nVersion: 1, dwFlags: 33317, iPixelType: 0, cColorBits: 32, cRedBits: 8, cRedShift: 16, cGreenBits: 8, cGreenShift: 8, cBlueBits: 8, cBlueShift: 0, cAlphaBits: 0, cAlphaShift: 0, cAccumBits: 64, cAccumRedBits: 16, cAccumGreenBits: 16, cAccumBlueBits: 16, cAccumAlphaBits: 16, cDepthBits: 24, cStencilBits: 8, cAuxBuffers: 4, iLayerType: 0, bReserved: 0, dwLayerMask: 0, dwVisibleMask: 0, dwDamageMask: 0 }
&gt; Extensions: [&quot;WGL_ARB_buffer_region&quot;, &quot;WGL_ARB_create_context&quot;, &quot;WGL_ARB_create_context_no_error&quot;, &quot;WGL_ARB_create_context_profile&quot;, &quot;WGL_ARB_create_context_robustness&quot;, &quot;WGL_ARB_context_flush_control&quot;, &quot;WGL_ARB_extensions_string&quot;, &quot;WGL_ARB_make_current_read&quot;, &quot;WGL_ARB_multisample&quot;, &quot;WGL_ARB_pbuffer&quot;, &quot;WGL_ARB_pixel_format&quot;, &quot;WGL_ARB_pixel_format_float&quot;, &quot;WGL_ARB_render_texture&quot;, &quot;WGL_ATI_pixel_format_float&quot;, &quot;WGL_EXT_colorspace&quot;, &quot;WGL_EXT_create_context_es_profile&quot;, &quot;WGL_EXT_create_context_es2_profile&quot;, &quot;WGL_EXT_extensions_string&quot;, &quot;WGL_EXT_framebuffer_sRGB&quot;, &quot;WGL_EXT_pixel_format_packed_float&quot;, &quot;WGL_EXT_swap_control&quot;, &quot;WGL_EXT_swap_control_tear&quot;, &quot;WGL_NVX_DX_interop&quot;, &quot;WGL_NV_DX_interop&quot;, &quot;WGL_NV_DX_interop2&quot;, &quot;WGL_NV_copy_image&quot;, &quot;WGL_NV_delay_before_swap&quot;, &quot;WGL_NV_float_buffer&quot;, &quot;WGL_NV_multisample_coverage&quot;, &quot;WGL_NV_render_depth_texture&quot;, &quot;WGL_NV_render_texture_rectangle&quot;]
</code></pre>
<h2><a class="header" href="#grab-some-function-pointers" id="grab-some-function-pointers">Grab Some Function Pointers</a></h2>
<p>Now that we can see what WGL extensions are available,
we can grab out some function pointers.</p>
<p>Here's the key part:
<em>We don't call them yet.</em></p>
<p>This is another silly thing, but it's true.
We just get the function pointers for now.
Then we destroy the fake stuff,
then we use the function pointers that we stored to make our real stuff.</p>
<p>We want to get function pointers for:</p>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_pixel_format.txt">wglChoosePixelFormatARB</a>
(provided by <code>WGL_ARB_pixel_format</code>) is required to choose advanced pixel formats (such as multisampling).</li>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_create_context.txt">wglCreateContextAttribsARB</a>
(provided by <code>WGL_ARB_create_context</code>) is required to make GL contexts with API versions above 1.1.</li>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/WGL_EXT_swap_control.txt">wglSwapIntervalEXT</a>
(provided by <code>WGL_EXT_swap_control</code>) is <em>not</em> required but is very handy, because it lets you enable
<a href="https://en.wikipedia.org/wiki/Screen_tearing#Vertical_synchronization">vsync</a></li>
</ul>
<p>These are our core three extension functions.
Many of the extensions listed above don't add new functions,
they just extend what values you can send to these three.</p>
<p>First we declare the types we'll be using:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs

/// Type for [wglChoosePixelFormatARB](https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_pixel_format.txt)
pub type wglChoosePixelFormatARB_t = Option&lt;
  unsafe extern &quot;system&quot; fn(
    hdc: HDC,
    piAttribIList: *const c_int,
    pfAttribFList: *const f32,
    nMaxFormats: UINT,
    piFormats: *mut c_int,
    nNumFormats: *mut UINT,
  ) -&gt; BOOL,
&gt;;
pub type FLOAT = c_float;
pub type c_float = f32;
/// Type for [wglCreateContextAttribsARB](https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_create_context.txt)
pub type wglCreateContextAttribsARB_t = Option&lt;
  unsafe extern &quot;system&quot; fn(
    hDC: HDC,
    hShareContext: HGLRC,
    attribList: *const c_int,
  ) -&gt; HGLRC,
&gt;;
/// Type for [wglSwapIntervalEXT](https://www.khronos.org/registry/OpenGL/extensions/EXT/WGL_EXT_swap_control.txt)
pub type wglSwapIntervalEXT_t =
  Option&lt;unsafe extern &quot;system&quot; fn(interval: c_int) -&gt; BOOL&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>And then we store the function pointers:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  println!(&quot;&gt; Extensions: {:?}&quot;, extensions);

  let wglChoosePixelFormatARB: wglChoosePixelFormatARB_t = unsafe {
    core::mem::transmute(
      wgl_get_proc_address(c_str!(&quot;wglChoosePixelFormatARB&quot;)).unwrap(),
    )
  };
  let wglCreateContextAttribsARB: wglCreateContextAttribsARB_t = unsafe {
    core::mem::transmute(
      wgl_get_proc_address(c_str!(&quot;wglCreateContextAttribsARB&quot;)).unwrap(),
    )
  };
  let wglSwapIntervalEXT: wglSwapIntervalEXT_t = unsafe {
    core::mem::transmute(
      wgl_get_proc_address(c_str!(&quot;wglSwapIntervalEXT&quot;)).unwrap(),
    )
  };

  // cleanup the fake stuff
<span class="boring">}
</span></code></pre></pre>
<p>Alright, I think we're done with all this fake context stuff.
We can move on to setting up our real context.</p>
<p>Actually, let's briefly put all that stuff into a single library function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Grabs out the stuff you'll need to have fun with WGL.
pub fn get_wgl_basics() -&gt; Result&lt;
  (
    Vec&lt;String&gt;,
    wglChoosePixelFormatARB_t,
    wglCreateContextAttribsARB_t,
    wglSwapIntervalEXT_t,
  ),
  Win32Error,
&gt; {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>It's just moving all the stuff you've seen over,
and then putting in a lot of drop guard types like we saw in format message.
There's not much new to talk about, so we'll keep moving.</p>
<h2><a class="header" href="#our-new-window-setup" id="our-new-window-setup">Our New Window Setup</a></h2>
<p>Alright, so now let's get some useful stuff with our window:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WindowData {
  hdc: HDC,
}
impl Default for WindowData {
  fn default() -&gt; Self {
    unsafe { core::mem::zeroed() }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Since it's going to be connected to a GL context now we don't want to get and free it with every <code>WM_PAINT</code>.
Instead, we'll get it once after the window is created,
then stuff it into the WindowData field and leave it there.
The <code>WM_DESTROY</code> can clean it up before destroying the window itself.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// fn main
  let lparam: *mut WindowData = Box::leak(Box::new(WindowData::default()));
  let hwnd = unsafe {
    create_app_window(
      sample_window_class,
      &quot;Sample Window Name&quot;,
      None,
      [800, 600],
      lparam.cast(),
    )
  }
  .unwrap();
  let hdc = unsafe { get_dc(hwnd) }.unwrap();
  unsafe { (*lparam).hdc = hdc };
</code></pre></pre>
<p>And we need to adjust our window procedure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    WM_DESTROY =&gt; {
      match get_window_userdata::&lt;WindowData&gt;(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          let window_data = Box::from_raw(ptr);
          let _ = release_dc(hwnd, window_data.hdc);
          println!(&quot;Cleaned up the box.&quot;);
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null, no cleanup&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr for cleanup: {}&quot;, e)
        }
      }
      post_quit_message(0);
    }
    WM_PAINT =&gt; match get_window_userdata::&lt;WindowData&gt;(hwnd) {
      Ok(ptr) if !ptr.is_null() =&gt; {
        // TODO: real painting, eventually
        println!(&quot;painting!&quot;);
      }
      Ok(_) =&gt; {
        println!(&quot;userdata ptr is null&quot;)
      }
      Err(e) =&gt; {
        println!(&quot;Error while getting the userdata ptr: {}&quot;, e)
      }
    },
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#finally-we-call-wglchoosepixelformatarb" id="finally-we-call-wglchoosepixelformatarb">Finally We Call wglChoosePixelFormatARB</a></h2>
<p>We're finally ready to call our <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_pixel_format.txt">wglChoosePixelFormatARB</a> pointer.</p>
<p>This one is fairly flexible.
We can pass a list of integer (key,value) pairs,
a list of float (key,value) pairs,
and the space to get some outputs.</p>
<p>As far as I can tell,
there's no reason in the basic extension for any float attributes to be specified.
Other extensions might add options in the future,
but there's nothing for us there right now.
The int attributes, on the other hand, have many interesting things.
For both lists, the function knows the list is over when it sees a 0 in the key position.
Also for both lists, we can pass a null instead of a list pointer.</p>
<p>Meanwhile, we can have more than one output if we want.
We pass in a count, and a pointer to an array of that length.
The function will fill in as many array values as it can.
There's also a pointer to an integer that we pass,
and it gets written the number of outputs that were found.
This could be the full array, but it could also be less than the full array.</p>
<p>Interestingly, using <code>min_const_generics</code> might work here.
We could make the array of values to return be a const generic.
But we only actually need <em>one</em> pixel format,
so we'll just pick the first format they give us.</p>
<p>The wrapper function for this is not complex, but it is <em>tall</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Arranges the data for calling a [`wglChoosePixelFormatARB_t`] procedure.
///
/// * Inputs are slices of [key, value] pairs.
/// * Input slices **can** be empty.
/// * Non-empty slices must have a zero value in the key position of the final
///   pair.
pub unsafe fn do_wglChoosePixelFormatARB(
  f: wglChoosePixelFormatARB_t, hdc: HDC, int_attrs: &amp;[[c_int; 2]],
  float_attrs: &amp;[[FLOAT; 2]],
) -&gt; Result&lt;c_int, Win32Error&gt; {
  let app_err = Win32Error(Win32Error::APPLICATION_ERROR_BIT);
  let i_ptr = match int_attrs.last() {
    Some([k, _v]) =&gt; {
      if *k == 0 {
        int_attrs.as_ptr()
      } else {
        return Err(app_err);
      }
    }
    None =&gt; null(),
  };
  let f_ptr = match float_attrs.last() {
    Some([k, _v]) =&gt; {
      if *k == 0.0 {
        int_attrs.as_ptr()
      } else {
        return Err(app_err);
      }
    }
    None =&gt; null(),
  };
  let mut out_format = 0;
  let mut out_format_count = 0;
  let b = (f.ok_or(app_err)?)(
    hdc,
    i_ptr.cast(),
    f_ptr.cast(),
    1,
    &amp;mut out_format,
    &amp;mut out_format_count,
  );
  if b != 0 &amp;&amp; out_format_count == 1 {
    Ok(out_format)
  } else {
    Err(get_last_error())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now the way we call this thing is that we're gonna have some &quot;base&quot; requirements,
then we can look at the extensions and maybe ask for a little more if it's available,
then we finalize the list by putting in that zero.</p>
<p>After we get the pixel format index,
we can't set it directly, because we need a <code>PIXELFORMATDESCRIPTOR</code> to go with it.
First we use <code>describe_pixel_format</code>, then we can <code>set_pixel_format</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // base criteria
  let mut int_attribs = vec![
    [WGL_DRAW_TO_WINDOW_ARB, true as _],
    [WGL_SUPPORT_OPENGL_ARB, true as _],
    [WGL_DOUBLE_BUFFER_ARB, true as _],
    [WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB],
    [WGL_COLOR_BITS_ARB, 32],
    [WGL_DEPTH_BITS_ARB, 24],
    [WGL_STENCIL_BITS_ARB, 8],
  ];
  // if sRGB is supported, ask for that
  if wgl_extensions.iter().any(|s| s == &quot;WGL_EXT_framebuffer_sRGB&quot;) {
    int_attribs.push([WGL_FRAMEBUFFER_SRGB_CAPABLE_EXT, true as _]);
  };
  // let's have some multisample if we can get it
  if wgl_extensions.iter().any(|s| s == &quot;WGL_ARB_multisample&quot;) {
    int_attribs.push([WGL_SAMPLE_BUFFERS_ARB, 1]);
  };
  // finalize our list
  int_attribs.push([0, 0]);
  // choose a format, get the PIXELFORMATDESCRIPTOR, and set it.
  let pix_format = unsafe {
    do_wglChoosePixelFormatARB(wglChoosePixelFormatARB, hdc, &amp;int_attribs, &amp;[])
  }
  .unwrap();
  let pfd = unsafe { describe_pixel_format(hdc, pix_format) }.unwrap();
  unsafe { set_pixel_format(hdc, pix_format, &amp;pfd) }.unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#open-that-stupid-context-already-wglcreatecontextattribsarb" id="open-that-stupid-context-already-wglcreatecontextattribsarb">Open That Stupid Context Already (wglCreateContextAttribsARB)</a></h2>
<p>Now that we have a pixel format set, we can create a context.</p>
<p>To create an advanced context,
we call <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_create_context.txt">wglCreateContextAttribsARB</a>.</p>
<p>It's not too different from the last function we used.
We pass a list of (key,value) pairs in,
with a 0 key to signal the final entry.</p>
<p>The wrapper for this should look familiar, it's the same basic idea:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Arranges the data for calling a [`wglCreateContextAttribsARB_t`] procedure.
///
/// * The input slice consists of [key, value] pairs.
/// * The input slice **can** be empty.
/// * Any non-empty input must have zero as the key value of the last position.
pub unsafe fn do_wglCreateContextAttribsARB(
  f: wglCreateContextAttribsARB_t, hdc: HDC, hShareContext: HGLRC,
  attribList: &amp;[[i32; 2]],
) -&gt; Result&lt;HGLRC, Win32Error&gt; {
  let app_err = Win32Error(Win32Error::APPLICATION_ERROR_BIT);
  let i_ptr = match attribList.last() {
    Some([k, _v]) =&gt; {
      if *k == 0 {
        attribList.as_ptr()
      } else {
        return Err(app_err);
      }
    }
    None =&gt; null(),
  };
  let hglrc = (f.ok_or(app_err)?)(hdc, hShareContext, i_ptr.cast());
  if hglrc.is_null() {
    Err(get_last_error())
  } else {
    Ok(hglrc)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And this time we don't even have to use a vec to store all our settings.
We don't have a dynamic number of settings, so a plain array will do fine.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // now we create a context.
  const FLAGS: c_int = WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB
    | if cfg!(debug_assertions) { WGL_CONTEXT_DEBUG_BIT_ARB } else { 0 };
  let hglrc = unsafe {
    do_wglCreateContextAttribsARB(
      wglCreateContextAttribsARB,
      hdc,
      null_mut(),
      &amp;[
        [WGL_CONTEXT_MAJOR_VERSION_ARB, 3],
        [WGL_CONTEXT_MINOR_VERSION_ARB, 3],
        [WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB],
        [WGL_CONTEXT_FLAGS_ARB, FLAGS],
        [0, 0],
      ],
    )
  }
  .unwrap();
  unsafe { wgl_make_current(hdc, hglrc) }.unwrap();
  unsafe { (*lparam).hglrc = hglrc };
<span class="boring">}
</span></code></pre></pre>
<p>I'm here selecting OpenGL 3.3 Core,
because some day,
when this tutorial is finally over,
I'm going to say,
&quot;and now you can learn how to do the rest of OpenGL by going over to <a href="https://LearnOpenGL.com">LearnOpenGL.com</a>!&quot;.
And they teach 3.3 Core.
If you don't yet know about OpenGL versions,
that's the oldest version of the &quot;newer&quot; set of OpenGL versions.
If you do know enough about OpenGL to have an opinion on what other version to use,
you could also use any other version as well.</p>
<h2><a class="header" href="#loadlibraryw" id="loadlibraryw">LoadLibraryW</a></h2>
<p>On both MSDN and the OpenGL Wiki it says that any function that's in <code>OpenGL32.dll</code>
is <em>not</em> able to be looked up with <code>wglGetProcAddress</code>.
Instead you have to use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> function.
To use that, we need to have a loaded library.
The library loading itself uses a textual name, so it has <code>A</code> and <code>W</code> versions.
As usual, we want the <code>W</code> version, so we want <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw">LoadLibraryW</a>.
When we're all done with the library we'll use <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a>
to close out the library.
The <code>FreeLibrary</code> call just takes the handle to the module, so it doesn't have <code>A</code> and <code>W</code> variants.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Pointer to a procedure of unknown type.
pub type FARPROC = *mut c_void;

#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`LoadLibraryW`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw)
  pub fn LoadLibraryW(lpLibFileName: LPCWSTR) -&gt; HMODULE;

  /// [`FreeLibrary`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary)
  pub fn FreeLibrary(hLibModule: HMODULE) -&gt; BOOL;

  /// [`GetProcAddress`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)
  pub fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -&gt; FARPROC;
}

/// Loads a dynamic library.
///
/// The precise details of how the library is searched for depend on the input
/// string.
///
/// See [`LoadLibraryW`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw)
pub fn load_library(name: &amp;str) -&gt; Result&lt;HMODULE, Win32Error&gt; {
  let name_null = wide_null(name);
  // Safety: the input pointer is to a null-terminated string
  let hmodule = unsafe { LoadLibraryW(name_null.as_ptr()) };
  if hmodule.is_null() {
    Err(get_last_error())
  } else {
    Ok(hmodule)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Also, if you're wondering why <code>GetProcAddress</code> doesn't have <code>A</code> and <code>W</code> versions,
it's because C function names can only ever be ANSI content.</p>
<p>Now we can put an <code>HMODULE</code> into our WindowData struct.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WindowData {
  hdc: HDC,
  hglrc: HGLRC,
  opengl32: HMODULE,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we can load a module and assign it.
We can do this basically anywhere in the startup process,
but it's emotionally connected to using GL,
so we'll do it right after we make our context.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  unsafe { wgl_make_current(hdc, hglrc) }.unwrap();
  unsafe { (*lparam).hglrc = hglrc };

  let opengl32 = load_library(&quot;opengl32.dll&quot;).unwrap();
  unsafe { (*lparam).opengl32 = opengl32 };
<span class="boring">}
</span></code></pre></pre>
<p>And we have to properly close out the module when we're cleaning up the window.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    WM_DESTROY =&gt; {
      println!(&quot;WM_DESTROY&quot;);
      match get_window_userdata::&lt;WindowData&gt;(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          let window_data = Box::from_raw(ptr);
          FreeLibrary(window_data.opengl32);
          wgl_delete_context(window_data.hglrc)
            .unwrap_or_else(|e| eprintln!(&quot;GL Context deletion error: {}&quot;, e));
          // ...
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#what-do-we-load" id="what-do-we-load">What Do We Load?</a></h2>
<p>Now that we can load up GL functions, what do we want to load?
And what are the type signatures?</p>
<p>Well, for that, we could look at our old friend <a href="https://github.com/KhronosGroup/OpenGL-Registry/blob/master/xml/gl.xml">gl.xml</a>.
It describes the entire GL API in a structured way.</p>
<p>However, that's overkill for what we need at the moment.
We only need to use like two functions to just clear the screen to a color,
so instead we'll just check the online manual pages.
What we're after for is <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml">glClearColor</a>
and also <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml">glClear</a>.</p>
<p>What's a GLfloat and a GLbitfield? For that we can look in <code>gl.xml</code>.
If we look around we'll eventually find these entries:</p>
<pre><code class="language-xml">&lt;type&gt;typedef unsigned int &lt;name&gt;GLbitfield&lt;/name&gt;;&lt;/type&gt;

&lt;type requires=&quot;khrplatform&quot;&gt;typedef khronos_float_t &lt;name&gt;GLfloat&lt;/name&gt;;&lt;/type&gt;
</code></pre>
<p>Cool.
Hmm, we need a new library module for this.
These definitions will be common to our GL usage across all the platforms,
so let's start a new file for that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs

//! Library for the [Triangle From Scratch][tfs] project.
//!
//! [tfs]: https://rust-tutorials.github.io/triangle-from-scratch/

mod macros;

pub mod util;

#[cfg(windows)]
pub mod win32;
// this is so that gl will see the C types
#[cfg(windows)]
use win32::*;

pub mod gl;
<span class="boring">}
</span></code></pre></pre>
<p>And then our fun new module</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>#![allow(non_camel_case_types)]

<span class="boring">fn main() {
</span>use super::*;

/// From `gl.xml`
pub type GLbitfield = c_uint;

/// From `gl.xml`
pub type GLfloat = c_float;

/// See [`glClearColor`](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml)
pub type glClearColor_t = Option&lt;
  unsafe extern &quot;system&quot; fn(
    red: GLfloat,
    green: GLfloat,
    blue: GLfloat,
    alpha: GLfloat,
  ),
&gt;;

/// See [`glClear`](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml)
pub type glClear_t = Option&lt;unsafe extern &quot;system&quot; fn(mask: GLbitfield)&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Hmm, but where do we get the values for the <code>GL_COLOR_BUFFER_BIT</code> and so on?
That's also stored in <code>gl.xml</code>.</p>
<p>If you search for <code>GL_COLOR_BUFFER_BIT</code> you'll see a lot of &quot;group&quot; info,
but that's old and not what we want.
Eventually if you keep looking you'll see a line like this:</p>
<pre><code class="language-xml">&lt;enum value=&quot;0x00004000&quot; name=&quot;GL_COLOR_BUFFER_BIT&quot; group=&quot;ClearBufferMask,AttribMask&quot;/&gt;
</code></pre>
<p>This is good, this is good.</p>
<p>So what are the groups?
Well, there's been a heroic effort by the GL maintainers to get the <code>gl.xml</code> descriptions
of functions to be <em>slightly</em> better documented by giving each function input a group,
and then each constant lists what groups it's in.</p>
<p>If we look at the XML definition for <code>glClear</code>:</p>
<pre><code class="language-xml">&lt;command&gt;
  &lt;proto&gt;void &lt;name&gt;glClear&lt;/name&gt;&lt;/proto&gt;
  &lt;param group=&quot;ClearBufferMask&quot;&gt;&lt;ptype&gt;GLbitfield&lt;/ptype&gt; &lt;name&gt;mask&lt;/name&gt;&lt;/param&gt;
  &lt;glx type=&quot;render&quot; opcode=&quot;127&quot;/&gt;
&lt;/command&gt;
</code></pre>
<p>See, that mask argument should be a constant in the &quot;ClearBufferMask&quot; group.
And <code>GL_COLOR_BUFFER_BIT</code> is in the &quot;ClearBufferMask&quot; group,
so it would be a correct call to make.</p>
<p>This is just some info to try and help static checkers,
but it's still pretty loosey-goosey,
and you don't really have to pay much attention if you don't care to.
We won't be following the group info while we're doing this by hand.
If we make a fancy generator then that might care to track the group info.</p>
<p>So we add some fields to our window data:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WindowData {
  hdc: HDC,
  hglrc: HGLRC,
  opengl32: HMODULE,
  gl_clear: glClear_t,
  gl_clear_color: glClearColor_t,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we add some functions to our window data:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowData {
  pub fn gl_get_proc_address(&amp;self, name: &amp;[u8]) -&gt; *mut c_void {
    assert!(*name.last().unwrap() == 0);
    let p = unsafe { wglGetProcAddress(name.as_ptr().cast()) };
    match p as usize {
      0 | 1 | 2 | 3 | usize::MAX =&gt; unsafe {
        GetProcAddress(self.opengl32, name.as_ptr().cast())
      },
      _ =&gt; p,
    }
  }
  #[rustfmt::skip]
  pub unsafe fn load_gl_functions(&amp;mut self) {
    self.gl_clear = core::mem::transmute(self.gl_get_proc_address(c_str!(&quot;glClear&quot;)));
    self.gl_clear_color = core::mem::transmute(self.gl_get_proc_address(c_str!(&quot;glClearColor&quot;)));
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then, in addition to simply setting the loaded library,
we also tell the window data to do its loading process:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let opengl32 = load_library(&quot;opengl32.dll&quot;).unwrap();
  unsafe { (*lparam).opengl32 = opengl32 };
  unsafe { (*lparam).load_gl_functions() };
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#clear-the-screen" id="clear-the-screen">Clear The Screen</a></h2>
<p>To clear the screen's color we call <code>glClear(GL_COLOR_BUFFER_BIT)</code>.
We can also set the color we want to clear things to.
By default it'll clear to black,
but we can select any color we want.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    WM_PAINT =&gt; match get_window_userdata::&lt;WindowData&gt;(hwnd) {
      Ok(ptr) if !ptr.is_null() =&gt; {
        let window_data = ptr.as_mut().unwrap();
        (window_data.gl_clear_color.unwrap())(0.6, 0.7, 0.8, 1.0);
        (window_data.gl_clear.unwrap())(GL_COLOR_BUFFER_BIT);
      }
<span class="boring">}
</span></code></pre></pre>
<p>And there's one more step!</p>
<p>We need to call <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-swapbuffers">SwapBuffers</a>
on our HDC to tell windows to swap the front and back buffers.</p>
<p>Declare it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in the library's win32.rs

#[link(name = &quot;Gdi32&quot;)]
extern &quot;system&quot; {
  /// [`SwapBuffers`](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-swapbuffers)
  pub fn SwapBuffers(Arg1: HDC) -&gt; BOOL;
}
<span class="boring">}
</span></code></pre></pre>
<p>And then call it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    WM_PAINT =&gt; match get_window_userdata::&lt;WindowData&gt;(hwnd) {
      Ok(ptr) if !ptr.is_null() =&gt; {
        let window_data = ptr.as_mut().unwrap();
        (window_data.gl_clear_color.unwrap())(0.6, 0.7, 0.8, 1.0);
        (window_data.gl_clear.unwrap())(GL_COLOR_BUFFER_BIT);
        SwapBuffers(window_data.hdc);
      }
<span class="boring">}
</span></code></pre></pre>
<p>And we finally get a nice, soft, blue sort of color in our window.</p>
<h2><a class="header" href="#swap-interval" id="swap-interval">Swap Interval</a></h2>
<p>Oh heck, we didn't set a swap interval!</p>
<p>Remember how we loaded up a pointer for <a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/WGL_EXT_swap_control.txt">wglSwapIntervalEXT</a>,
and then we didn't use it at all?
Uh, I guess we can call it after we load the GL functions.
We just need to set it once and it'll stay that way for the rest of the program.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let opengl32 = load_library(&quot;opengl32.dll&quot;).unwrap();
  unsafe { (*lparam).opengl32 = opengl32 };
  unsafe { (*lparam).load_gl_functions() };

  // Enable &quot;adaptive&quot; vsync if possible, otherwise normal vsync
  if wgl_extensions.iter().any(|s| s == &quot;WGL_EXT_swap_control_tear&quot;) {
    unsafe { (wglSwapIntervalEXT.unwrap())(-1) };
  } else {
    unsafe { (wglSwapIntervalEXT.unwrap())(1) };
  }
<span class="boring">}
</span></code></pre></pre>
<p>Now, any time we call <code>SwapBuffers</code>,
the system will sync the swap with the vertical trace of the screen,
and it'll wait at least 1 full monitor cycle between each swap.</p>
<p>If we have the adaptive vsync available, it'll still wait at least 1 frame,
but if we're only slightly off from the correct time, it'll swap immediately.
This reduces visual stutter by allowing occasional visual tearing.
Neither of those are great, but sometimes the program will struggle to keep up.
Usually the vsync mode is a user setting within a game or whatever,
so you can just let users pick how they want to handle things.</p>
<h2><a class="header" href="#are-we-done" id="are-we-done">Are We Done?</a></h2>
<p>Yeah, basically!</p>
<p>You understand the basics of how we find a GL function type,
lookup the function to load it into the program at runtime,
and call it to make something happen.</p>
<blockquote>
<p>and now you can learn how to do the rest of OpenGL by going over to <a href="https://LearnOpenGL.com">LearnOpenGL.com</a>!</p>
</blockquote>
<p>I promised I'd say that to you one day.</p>
<p>No, but really, <em>the basics</em> have all been explained.
There's a lot of stuff that's still clunky as heck,
but it all works.</p>
<p>What's certainly left to do is make it more ergonomic.
However, we're already at just over 9300 words.
We might talk about ways to make GL nice to work with in another lesson some day.</p>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>This part of the book has articles on stuff that's even more of a
<a href="https://en.wiktionary.org/wiki/yak_shaving">yak shave</a> than normal.</p>
<p>It's useful, but it's just a diversion from our main focus.</p>
<p>(Note: Thanks to <a href="https://github.com/Plecra">Plecra</a> for helping with the code for this article.)</p>
<h1><a class="header" href="#utf-16-literals" id="utf-16-literals">UTF-16 Literals</a></h1>
<p>Rust literals are textual content encoded as UTF-8.</p>
<p>Sometimes we want our textual content in other encodings instead.</p>
<p>This can be done at runtime,
but why do at runtime what you could be doing at compile time?</p>
<h2><a class="header" href="#what-is-unicode" id="what-is-unicode">What is Unicode?</a></h2>
<p>Unicode is a huge pile of nonsense, that's what it is.</p>
<p>There's an old article from 2003 called
<a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a>,
and the title of that article is correct.</p>
<p>You should stop and read it if you haven't,
and from here on I'm going to assume you've read it.</p>
<h2><a class="header" href="#const-fn" id="const-fn"><code>const fn</code></a></h2>
<p>In Rust, if you want to do something at compile time you must use a <code>const fn</code>.
However, Rust <code>const fn</code> is only <em>partly</em> implemented within the language.
There is much that is not yet done,
and most importantly <code>const fn</code> doesn't support traits.</p>
<p>Not having trait support means that we have to do things a little weird.
For one, we can't use normal iterators.
Another, we can't use string slice indexing.</p>
<p>So we'll have to write some <code>const fn</code> stuff without using traits.</p>
<h2><a class="header" href="#break_off_code_point" id="break_off_code_point"><code>break_off_code_point</code></a></h2>
<p>First, we want a <code>const fn</code> way to break a code point off the front of a utf-8 byte slice.
Normally, we'd use <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars">str::chars</a>,
but remember that there's no iterators here.
We'll have to just do it ourselves.</p>
<p>It's not too difficult.
We just follow the spec, as described on the <a href="https://en.wikipedia.org/wiki/UTF-8#Encoding">the wikipedia for utf-8</a>.</p>
<p>First we need a function that will take in some utf8 bytes,
break off one code point worth of bytes,
and then return what code point it found and the rest of the bytes.
All of this might fail (such as if the input is an empty slice), so the output is an <code>Option</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  None
}
<span class="boring">}
</span></code></pre></pre>
<p>As I mentioned above, we can't sub-slice a <code>&amp;str</code> value in a const context in current rust,
so we'll have to deal directly in <code>&amp;[u8]</code> for now.</p>
<h3><a class="header" href="#determine-the-next-code-points-byte-count" id="determine-the-next-code-points-byte-count">Determine the next code point's byte count</a></h3>
<p>The first thing we do is decide how many bytes we're going to use from the input.</p>
<p>As a &quot;default&quot; case, if we can't find a code point in the input we'll give none.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [..] =&gt; None
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>To determine how many bytes we'll use up to get our code point we look at the bits of the leading byte.
For any multi-byte sequence the number of initial 1 bits is the number of <em>total</em> bytes in the sequence.</p>
<ul>
<li>If the initial bit is 0, then that's a one byte sequence.</li>
<li>If the initial bits are 110, then that's a two byte sequence.</li>
<li>If the initial bits are 1110, then that's a three byte sequence.</li>
<li>If the initial bits are 11110, then that's a four byte sequence.</li>
</ul>
<p>We can look at the initial byte and see what case we're in using a
<a href="https://doc.rust-lang.org/reference/patterns.html#slice-patterns">slice pattern</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [0b00000000..=0b01111111, ..] =&gt; None, /* one */
    [0b11000000..=0b11011111, ..] =&gt; None, /* two */
    [0b11100000..=0b11101111, ..] =&gt; None, /* three */
    [0b11110000..=0b11110111, ..] =&gt; None, /* four */
    [..] =&gt; None,                          /* default */
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Except that after checking the bit pattern we need to store that byte,
because we'll need it to determine the output.
Also we'll need to use the &quot;rest of the bytes&quot; too.
For this we can add an <a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">identifier pattern</a>
to the matching segments.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [a @ 0b00000000..=0b01111111, rest @ ..] =&gt; None, /* one */
    [a @ 0b11000000..=0b11011111, rest @ ..] =&gt; None, /* two */
    [a @ 0b11100000..=0b11101111, rest @ ..] =&gt; None, /* three */
    [a @ 0b11110000..=0b11110111, rest @ ..] =&gt; None, /* four */
    [..] =&gt; None,                                     /* default */
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Slice patterns and identifier patterns are not very common in Rust,
so if you're unfamiliar with them please go glance at the reference.</p>
<p>Okay, next adjustment is that the two, three, and four cases aren't actually pulling the right number of bytes off the slice.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [a @ 0b00000000..=0b01111111, rest @ ..] =&gt; None, /* one */
    [a @ 0b11000000..=0b11011111, b, rest @ ..] =&gt; None, /* two */
    [a @ 0b11100000..=0b11101111, b, c, rest @ ..] =&gt; None, /* three */
    [a @ 0b11110000..=0b11110111, b, c, d, rest @ ..] =&gt; None, /* four */
    [..] =&gt; None,                                     /* default */
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>What's up with those comments? That's really how rustfmt puts it. Whatever.</p>
<p>Also note that <em>technically</em> the trailing bytes have their own limits on what's valid and what's not.
We're going to take a page from Rust's book and ignore that.
We'll simply <em>assume</em> that the trailing bytes in a multi-byte sequence are valid.
If a caller gives us bad input, we might give them bad output back.
There's not an actual safety concern with it, so it's not a big deal.</p>
<h3><a class="header" href="#compute-the-output-code-point" id="compute-the-output-code-point">Compute the output code point</a></h3>
<p>So now we need to fill in the output side of the four cases.</p>
<p>The one byte case is simple.
We just return the value directly.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [a @ 0b00000000..=0b01111111, rest @ ..] =&gt; {
      // one byte
      Some((*a as u32, rest))
    }
    [a @ 0b11000000..=0b11011111, b, rest @ ..] =&gt; None, /* two */
    [a @ 0b11100000..=0b11101111, b, c, rest @ ..] =&gt; None, /* three */
    [a @ 0b11110000..=0b11110111, b, c, d, rest @ ..] =&gt; None, /* four */
    [..] =&gt; None,                                        /* default */
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>The two byte case is where we start having to combine bits across different bytes.
From the leading byte we take the lowest 5 bits,
and from the trailing byte we take the lowest 6 bits.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [a @ 0b00000000..=0b01111111, rest @ ..] =&gt; {
      // one byte
      Some((*a as u32, rest))
    }
    [a @ 0b11000000..=0b11011111, b, rest @ ..] =&gt; {
      // two bytes
      let lead = (*a &amp; 0b11111) as u32;
      let trail = (*b &amp; 0b111111) as u32;
      Some((lead &lt;&lt; 6 | trail, rest))
    }
    [a @ 0b11100000..=0b11101111, b, c, rest @ ..] =&gt; None, /* three */
    [a @ 0b11110000..=0b11110111, b, c, d, rest @ ..] =&gt; None, /* four */
    [..] =&gt; None,                                           /* default */
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>The three and four byte cases are the same idea as the two byte case.
The number of bits to use from the leading byte changes each time,
but the number of bits to use from trailing bytes stays the same.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn break_off_code_point(utf8: &amp;[u8]) -&gt; Option&lt;(u32, &amp;[u8])&gt; {
  match utf8 {
    [a @ 0b00000000..=0b01111111, rest @ ..] =&gt; {
      // one byte
      Some((*a as u32, rest))
    }
    [a @ 0b11000000..=0b11011111, b, rest @ ..] =&gt; {
      // two bytes
      let lead = (*a &amp; 0b11111) as u32;
      let trail = (*b &amp; 0b111111) as u32;
      Some((lead &lt;&lt; 6 | trail, rest))
    }
    [a @ 0b11100000..=0b11101111, b, c, rest @ ..] =&gt; {
      // three bytes
      let lead = (*a &amp; 0b1111) as u32;
      let trail1 = (*b &amp; 0b111111) as u32;
      let trail2 = (*c &amp; 0b111111) as u32;
      let out = lead &lt;&lt; 12 | trail1 &lt;&lt; 6 | trail2;
      Some((out, rest))
    }
    [a @ 0b11110000..=0b11110111, b, c, d, rest @ ..] =&gt; {
      // four bytes
      let lead = (*a &amp; 0b111) as u32;
      let trail1 = (*b &amp; 0b111111) as u32;
      let trail2 = (*c &amp; 0b111111) as u32;
      let trail3 = (*d &amp; 0b111111) as u32;
      let out = lead &lt;&lt; 18 | trail1 &lt;&lt; 12 | trail2 &lt;&lt; 6 | trail3;
      Some((out, rest))
    }
    [..] =&gt; None, /* default */
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>We can also write a small unit test for this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_break_off_code_point() {
  // code points of 1, 2, 3, and 4 byte size
  for ch in &amp;['$', '¢', 'ह', '€', '한', '𐍈'] {
    let s = format!(&quot;{}&quot;, ch);
    assert_eq!(break_off_code_point(s.as_bytes()), Some((*ch as u32, &amp;[][..])));
  }

  // empty string works properly
  assert!(break_off_code_point(&quot;&quot;.as_bytes()).is_none());
}
<span class="boring">}
</span></code></pre></pre>
<p>A passing test doesn't conclusively prove that our function works,
but it at least shows that the function does what we expect (as far as we tested).</p>
<h3><a class="header" href="#invalid-input" id="invalid-input">Invalid Input</a></h3>
<p>One thing we <em>don't</em> handle quite right is invalid input.
Right now, our input is assumed to be correct.
If the input doesn't match a case we expect, then we just give back <code>None</code>.
If we're expecting to only process string literals with this, that's fine.
However, we might want to process <em>any</em> input at some point,
so let's do a little tweak to allow for lossy conversion of bad inputs.</p>
<p>All we have to do is break up the final <code>[..] =&gt; None</code> case into two cases.</p>
<ul>
<li>An empty string goes to <code>None</code></li>
<li>Our new &quot;default&quot; case gives the <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">Unicode Replacement Character</a>
as the code point and consumes 1 byte if the current leading character is disallowed.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in the `break_off_code_point` match
    [] =&gt; None,
    [_unknown, rest @ ..] =&gt; {
      // If we can't match anything above, we just pull off one byte and give
      // the unicode replacement code point.
      Some(('�' as u32, rest))
    }
<span class="boring">}
</span></code></pre></pre>
<p>This allows us to handle garbage in the middle of the input a little better.</p>
<p>It's still not perfectly conformant,
because we've decided to skip on checking the trailing bytes for validity,
but it's good enough in most cases that we'll make that trade.</p>
<h2><a class="header" href="#count_utf16_code_units" id="count_utf16_code_units"><code>count_utf16_code_units</code></a></h2>
<p>Alright, so our goal was to re-encode utf-8 as utf-16.
Now that we can iterate the code points of a utf-8 sequence,
how are we going to build a utf-16 sequence?</p>
<p>First, we need to get an output buffer. To put our output.
Since this is all in a const context, our output buffer is going to be an array.
How big of an array do we need?
Glad you asked.</p>
<p>Let's make another function for this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn count_utf16_code_units(s: &amp;str) -&gt; usize {
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Off to a good start.</p>
<p>So we're going to walk the input string,
and then for each code <em>point</em> we determine if it needs 1 or 2 code <em>units</em> to be stored.
This will give us the capacity for how many <code>u16</code> values our array will need to be.</p>
<p>The rule to count code units in utf-16 is simple:
If the unicode code point value is less than or equal to 0xFFFF then it's 1 code unit in utf-16,
otherwise it's 2 code units in utf-16.</p>
<p>We can write this with a simply <code>while let</code> loop,
and we'll throw a unit test at it too.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn count_utf16_code_units(s: &amp;str) -&gt; usize {
  let mut bytes = s.as_bytes();
  let mut len = 0;
  while let Some((u, rest)) = break_off_code_point(bytes) {
    len += if u &lt;= 0xFFFF { 1 } else { 2 };
    bytes = rest;
  }
  len
}

#[test]
fn test_count_utf16_code_units() {
  let s = &quot;hello from the unit test&quot;;
  let normal_style: usize = s.chars().map(|ch| ch.len_utf16()).sum();
  assert_eq!(normal_style, count_utf16_code_units(s));

  let s = &quot;$¢ह€한𐍈, 漢字, ひらがな / 平仮名, カタカナ / 片仮名&quot;;
  let normal_style: usize = s.chars().map(|ch| ch.len_utf16()).sum();
  assert_eq!(normal_style, count_utf16_code_units(s));
}
<span class="boring">}
</span></code></pre></pre>
<p>Cool, so now we can const count the number of code units we'll need to have.</p>
<h2><a class="header" href="#making-a-macro" id="making-a-macro">Making A Macro</a></h2>
<p>Okay, so now we want to input a string literal to something and get out a utf-16 literal.</p>
<p>Sadly, we can't do this with a const fn.
The output type would depend on the input value.
Rust doesn't like that idea at all.</p>
<p>Instead, we'll write a macro.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! utf16 {
  // pass
}
<span class="boring">}
</span></code></pre></pre>
<p>Our macro has one match case it can do: you give it an expression and it'll process the text.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! utf16 {
  ($text:expr) =&gt; {{
    todo!()
  }};
}
<span class="boring">}
</span></code></pre></pre>
<p>So when we get this <code>$text</code> value we want to assign it to a local const with a weird name.
This helps avoid some const-eval issues you can <em>potentially</em> get like if
the macro's caller has got an identifier in scope next to their macro usage that clashes with an identifier we're about to make in our macro.
It sounds unlikely, but it did come up in real code when developing the crate that this article is based on.
It doesn't really hurt, and it prevents a very cryptic error message from hitting the macro's user, so we'll do it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! utf16 {
  ($text:expr) =&gt; {{
    // Here we pick a name highly unlikely to exist in the scope
    // that $text came from, which prevents a potential const eval cycle error.
    const __A1B2C3D4_CONST_EVAL_LOOP_BREAK: &amp;str = $text;
    const UTF8: &amp;str = __A1B2C3D4_CONST_EVAL_LOOP_BREAK;
    todo!()
  }};
}
<span class="boring">}
</span></code></pre></pre>
<p>Next we'll make a const for the size of the output buffer.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! utf16 {
  ($text:expr) =&gt; {{
    // Here we pick a name highly unlikely to exist in the scope
    // that $text came from, which prevents a potential const eval cycle error.
    const __A1B2C3D4_CONST_EVAL_LOOP_BREAK: &amp;str = $text;
    const UTF8: &amp;str = __A1B2C3D4_CONST_EVAL_LOOP_BREAK;
    const OUT_BUFFER_LEN: usize = $crate::util::count_utf16_code_units(UTF8);
    todo!()
  }};
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we make a const for the output itself.
It's an array with a length equal to <code>OUT_BUFFER_LEN</code>,
but we need to mutate and fill it all in as we iterate the code points of the input,
so we'll compute it using an inner block.</p>
<p>We start with a zeroed buffer of the right size,
then we walk the input and write in each value.
Because the normal encoding utilities in the core library aren't <code>const fn</code>,
we have to do our own encoding math right here.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
    const UTF16: [u16; OUT_BUFFER_LEN] = {
      let mut buffer = [0u16; OUT_BUFFER_LEN];
      let mut bytes = UTF8.as_bytes();
      let mut i = 0;
      while let Some((u, rest)) = $crate::util::break_off_code_point(bytes) {
        if u &lt;= 0xFFFF {
          buffer[i] = u as u16;
          i += 1;
        } else {
          let code = u - 0x1_0000;
          buffer[i] = 0xD800 | ((code &gt;&gt; 10) as u16);
          buffer[i + 1] = 0xDC00 | ((code &amp; 0x3FF) as u16);
          i += 2;
        }
        bytes = rest;
      }
      buffer
    };
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we just return the whole array.
In an initial version of this I had the output be just the data slice (<code>&amp;[u16]</code>),
but in some select situations you do need the data in an owned form,
so the macro was adjusted to return the array directly.
If you want it to be a slice, just prefix the call with <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! utf16 {
  ($text:expr) =&gt; {{
    // Here we pick a name highly unlikely to exist in the scope
    // that $text came from, which prevents a potential const eval cycle error.
    const __A1B2C3D4_CONST_EVAL_LOOP_BREAK: &amp;str = $text;
    const UTF8: &amp;str = __A1B2C3D4_CONST_EVAL_LOOP_BREAK;
    const OUT_BUFFER_LEN: usize = $crate::util::count_utf16_code_units(UTF8);
    const UTF16: [u16; OUT_BUFFER_LEN] = {
      let mut buffer = [0u16; OUT_BUFFER_LEN];
      let mut bytes = UTF8.as_bytes();
      let mut i = 0;
      while let Some((u, rest)) = $crate::util::break_off_code_point(bytes) {
        if u &lt;= 0xFFFF {
          buffer[i] = u as u16;
          i += 1;
        } else {
          let code = u - 0x1_0000;
          buffer[i] = 0xD800 | ((code &gt;&gt; 10) as u16);
          buffer[i + 1] = 0xDC00 | ((code &amp; 0x3FF) as u16);
          i += 2;
        }
        bytes = rest;
      }
      buffer
    };
    UTF16
  }};
}
<span class="boring">}
</span></code></pre></pre>
<p>And some handy tests wouldn't be out of place:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_utf16() {
  const HELLO16: [u16; 5] = utf16!(&quot;hello&quot;);
  assert_eq!(&amp;HELLO16[..], &amp;&quot;hello&quot;.encode_utf16().collect::&lt;Vec&lt;u16&gt;&gt;());

  const WORDS8: &amp;str = &quot;$¢ह€한𐍈, 漢字, ひらがな / 平仮名, カタカナ / 片仮名&quot;;
  const WORDS16: &amp;[u16] = &amp;utf16!(WORDS8);
  assert_eq!(WORDS16, &amp;WORDS8.encode_utf16().collect::&lt;Vec&lt;u16&gt;&gt;());
}
<span class="boring">}
</span></code></pre></pre>
<p>Ah, but often we want to have a <em>null terminated</em> string of utf-16.
That's also no trouble at all:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// As per [`utf16`], but places a null-terminator on the end.
#[macro_export]
macro_rules! utf16_null {
  ($text:expr) =&gt; {{
    const TEXT_NULL___A1B2C3D4: &amp;str = concat!($text, '\0');
    $crate::utf16!(TEXT_NULL___A1B2C3D4)
  }};
}

#[test]
fn test_utf16_null() {
  const HELLO: &amp;[u16] = &amp;utf16_null!(&quot;hello&quot;);
  assert_eq!(HELLO, &amp;&quot;hello\0&quot;.encode_utf16().collect::&lt;Vec&lt;u16&gt;&gt;());
}
<span class="boring">}
</span></code></pre></pre>
<p>All very good, I hope you had fun with this one.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
