<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Triangle From Scratch</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A tutorial for drawing a triangle without any outside crates.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="opening_a_window/index.html"><strong aria-hidden="true">1.</strong> Opening A Window</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="opening_a_window/win32.html"><strong aria-hidden="true">1.1.</strong> Win32</a></li><li class="chapter-item expanded "><a href="opening_a_window/win32_cleanup.html"><strong aria-hidden="true">1.2.</strong> Win32 Cleanup</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Triangle From Scratch</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/rust-tutorials/triangle-from-scratch">GitHub Repo</a></p>
<h1><a class="header" href="#triangle-from-scratch-introduction" id="triangle-from-scratch-introduction">Triangle From Scratch: Introduction</a></h1>
<p>This is an educational series about drawing a triangle without using any outside crates.</p>
<p>Specifically, the rules are:</p>
<ol>
<li>We can only put a crate into the <code>[dependencies]</code> section of <code>Cargo.toml</code> if it's a crate that we wrote ourselves, as part of this project.</li>
<li>We <strong>can</strong> still use Rust's standard library. Since all Rust programs can import from the standard library without a <code>[dependencies]</code> entry, it's fair game.</li>
</ol>
<p>Without any external crates, we'll have to write our own operating system bindings.
It's not difficult code to write, there's just a lot of background details you need to understand first.
That's where most of our focus will go, on learning how that works.
There's a lot less focus spent on the literal &quot;triangle drawing&quot; part, which is usually fairly easy.</p>
<p>Expected subjects include:</p>
<ul>
<li>Reading OS documentation (which usually assumes you're programming in C).</li>
<li>Understanding the C header files that describe the OS's public API.</li>
<li>Writing appropriate &quot;raw&quot; Rust bindings to that public API.</li>
<li>Creating ergonomic wrapper functions to make the API easily used with the rest of Rust.</li>
<li>Having those wrapper functions be fully safe (in the Rust sense) when possible, or at least making them as error-proof as we can.</li>
</ul>
<p><strong>Reminder:</strong> The &quot;absolutely no dependencies&quot; thing is for demonstration purposes only.
If you actually want to draw a triangle within a reasonable amount of development time, please do feel free to use dependencies.
Depending on what you need to do, there's generally many good crates available.</p>
<h1><a class="header" href="#opening-a-window" id="opening-a-window">Opening A Window</a></h1>
<p>If we wanna draw a triangle, we have to have some place to <em>put</em> a triangle.</p>
<p>Generally (but not always) this means showing it in a graphical window on the screen.</p>
<p>Because operating systems all support more than one drawing API,
and because many drawing APIs can be used with more than one operating system,
we're going to separate the lessons about opening a window from the lessons about using a particular drawing API.</p>
<h1><a class="header" href="#opening-a-win32-window" id="opening-a-win32-window">Opening a Win32 Window</a></h1>
<p>On Windows, the C oriented API is called &quot;Win32&quot;.</p>
<p>There's also some C++ oriented APIs for interacting with Windows as well (called COM and WinRT).</p>
<p>It's <em>much</em> easier for Rust to bind to and interact with a C oriented API than a C++ oriented API,
so we'll start with just using Win32 to interact with Windows.</p>
<h2><a class="header" href="#search-the-web" id="search-the-web">Search The Web</a></h2>
<p>Okay, for the sake of the lesson let's pretend that <em>even I</em> don't know what to do.</p>
<p>Let's start by asking the internet nicely.
Something like <a href="https://duckduckgo.com/?q=open+a+window+win32">&quot;open a window win32&quot;</a> sounds right.
Hey look, that <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window">first result</a> is straight from Microsoft.
It's a whole little tutorial on how to open a window.
Perfect, just what we wanted.</p>
<h2><a class="header" href="#starting-the-win32-windowing-tutorial" id="starting-the-win32-windowing-tutorial">Starting The Win32 Windowing Tutorial</a></h2>
<p>Let's read the first paragraph of the <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window">windowing tutorial</a>
that we just found...</p>
<p>To summarize the opening portion:</p>
<ul>
<li>Every window needs a window class.</li>
<li>A window class is registered with the OS at runtime.</li>
<li>We need to fill in a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa">WNDCLASSA</a> (or <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw">WNDCLASSW</a>)</li>
</ul>
<p>Whoa, slow down, hold on, what's this structure thing? And why are there two versions?</p>
<h3><a class="header" href="#ansi-and-wide" id="ansi-and-wide">ANSI and Wide</a></h3>
<p>All over the Win32 API you'll find stuff where there's an <code>A</code> version and a <code>W</code> version.
This happens with functions that process textual data, as well as with structs associated with those functions.
In this case of <code>WNDCLASSA</code> / <code>WNDCLASSW</code>, a window class has, as part of it, a menu name as well as a class name.
These names are textual, and so we get both an <code>A</code> and a <code>W</code> version.</p>
<p>The <code>A</code> and <code>W</code> letters come from the two types of string that the windows API lets you use: ANSI strings and &quot;wide&quot; strings.</p>
<ul>
<li>ANSI strings use C's <code>char</code> type.
They don't have a specified encoding.
If you store anything other than ASCII data in an ANSI string, the results vary based on context.</li>
<li>Wide strings use C's <code>wchar_t</code> type.
These strings are UTF-16 encoded.
This gives you consistent results while using all the world's writing systems.</li>
</ul>
<h4><a class="header" href="#what-does-this-mean-for-us-rust-users" id="what-does-this-mean-for-us-rust-users">What does this mean for us Rust users?</a></h4>
<p>Well, Rust string literals, and Rust's normal <code>String</code> and <code>&amp;str</code> types, are all UTF-8 encoded.
This means there's a bit of a mismatch between what Windows expects and what we've usually got.</p>
<p>UTF-8 is a <em>superset</em> of ASCII.
This means that any ASCII-only string can be stored compatibly inside a UTF-8 string.
So if we only want to use ASCII data the normal <code>String</code> and <code>&amp;str</code> types will be (mostly) compatible with <code>A</code>-type operations.</p>
<p>On the other hand, ASCII is pretty limited.
Most languages of the world aren't representable with only ASCII text.
You get English, Latin, Esperanto, Klingon, but the list runs out quick after that.
Even English doesn't get all of its fancy typographical marks in an ASCII-only context:
ellipses (…), “angled quotes”, different length dashes (– / —), and so on.</p>
<p>So we really want to be using these <code>W</code>-type operations.
This means that we have to convert UTF-8 over to UTF-16.
Oh, hey, look, <a href="https://doc.rust-lang.org/std/primitive.str.html#method.encode_utf16">that's in the standard library</a>, isn't it neat?
The only slight problem is that we can't use that in a <code>const</code> context (yet).
It's not the worst to do a little runtime data mucking here and there, so we'll accept the overhead.
The UTF-16 conversion is kinda just an &quot;unfortunate but accepted&quot; part of working with Windows.</p>
<h3><a class="header" href="#reading-a-c-struct-declaration" id="reading-a-c-struct-declaration">Reading a C struct declaration</a></h3>
<p>Okay, so now we've picked that we're going to use <code>WNDCLASSW</code>.
Let's look at the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw">MSDN definition</a>:</p>
<pre><code class="language-c">typedef struct tagWNDCLASSW {
  UINT      style;
  WNDPROC   lpfnWndProc;
  int       cbClsExtra;
  int       cbWndExtra;
  HINSTANCE hInstance;
  HICON     hIcon;
  HCURSOR   hCursor;
  HBRUSH    hbrBackground;
  LPCWSTR   lpszMenuName;
  LPCWSTR   lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;
</code></pre>
<p>Oh, gross, what the heck?
What's going on here?
Let's take it one part at a time.</p>
<ul>
<li><code>typedef</code> says that we're making a &quot;type definition&quot;.
The way it works is that first you give a base type, and then you list one or more other names you want to have as aliases.</li>
<li><code>struct tagWNDCLASSW</code> this names the first type, that we're making the aliases for.</li>
<li><code>{ ... }</code> the part in braces lists the fields of the struct.
Each line has the field's type, then the name of the field, then a <code>;</code></li>
<li><code>WNDCLASSW,</code> is the first alias we're making.
From now on, if you refer to a <code>WNDCLASSW</code>, then it's the same as if you'd referred to the whole <code>struct tagWNDCLASSW { ... }</code> declaration.
This is really good, because writing out all the fields any time we just want to talk about the type is just a pain.</li>
<li><code>*PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;</code> these are more aliases as well.
The <code>*</code> makes these pointer types, so a <code>PWNDCLASSW</code> is the same as <code>struct tagWNDCLASSW { ... } *</code> or <code>WNDCLASSW*</code>.
The prefixes on each name variant stand for &quot;Pointer&quot;, &quot;Near Pointer&quot;, and &quot;Long Pointer&quot;.
Long ago when computers had segmented memory there were differences in the pointer types.
These days computers aren't set up for that, so they're all just a normal pointer.
The different names are still around for legacy compatability.</li>
</ul>
<h3><a class="header" href="#starting-our-rust-code" id="starting-our-rust-code">Starting Our Rust Code</a></h3>
<p>I think we've got enough on our plate to start writing things down in Rust.</p>
<pre><code>Microsoft Windows [Version 10.0.19041.685]
(c) 2020 Microsoft Corporation. All rights reserved.

D:\dev\triangle-from-scratch&gt;cargo init --bin
     Created binary (application) package

D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.65s
     Running `target\debug\triangle-from-scratch.exe`
Hello, world!
</code></pre>
<p>Great.
Later on we'll put some of this into a library,
sort it into modules,
all that sort of housekeeping stuff.
For now, we'll just write into <code>main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct WNDCLASSW {
  style: UINT,
  lpfnWndProc: WNDPROC,
  cbClsExtra: int,
  cbWndExtra: int,
  hInstance: HINSTANCE,
  hIcon: HICON,
  hCursor: HCURSOR,
  hbrBackground: HBRUSH,
  lpszMenuName: LPCWSTR,
  lpszClassName: LPCWSTR,
}
<span class="boring">}
</span></code></pre></pre>
<p>Oh, excellent, and we're sure to put that little <code>repr(C)</code> at the top.
This makes sure it has the right <a href="https://doc.rust-lang.org/reference/type-layout.html">memory layout</a> for interacting with foreign code.</p>
<p>Let's give that a try:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
error[E0412]: cannot find type `UINT` in this scope
 --&gt; src\main.rs:9:10
  |
9 |   style: UINT,
  |          ^^^^ not found in this scope

error[E0412]: cannot find type `WNDPROC` in this scope
  --&gt; src\main.rs:10:16
   |
10 |   lpfnWndProc: WNDPROC,
   |                ^^^^^^^ not found in this scope

...you get the idea
</code></pre>
<p>Okay, so, that should be obvious enough in terms of the error message.
We can't declare a struct to have fields with types Rust doesn't know about.
It's just not gonna fly.</p>
<h3><a class="header" href="#how-big-is-an-int" id="how-big-is-an-int">How Big Is An Int?</a></h3>
<p>Okay, start with just the first field on the list of missing types.
Another web search for <a href="https://duckduckgo.com/?q=msdn+uint">&quot;msdn uint&quot;</a>,
and we find a handy page of <a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a>.</p>
<pre><code>UINT: An unsigned INT. The range is 0 through 4294967295 decimal.

This type is declared in WinDef.h as follows:

typedef unsigned int UINT;
</code></pre>
<p>Alright, closer to an answer.
Now we just ask <a href="https://duckduckgo.com/?q=how+big+is+an+int+on+windows">&quot;how big is an int on windows&quot;</a>,
which doesn't have any pages that immediately look useful.
What if we ask <a href="https://duckduckgo.com/?q=how+big+is+an+int+on+windows+msdn">&quot;how big is an int on windows msdn&quot;</a>?
Ah, here we go, <a href="https://docs.microsoft.com/en-us/cpp/cpp/data-type-ranges">Data Type Ranges</a>
gives us all the info we need about the size of different C types.</p>
<p>An <code>unsigned int</code> is 4 bytes, so in Rust terms it's a <code>u32</code>.
We could call our type <code>unsigned_int</code>, but the rust convention is to give C types a <code>c_</code> prefix, and also to just say <code>u</code> for &quot;unsigned&quot;.
In other words, <code>unsigned int</code> in C becomes <a href="https://doc.rust-lang.org/std/os/raw/type.c_uint.html">c_uint</a> in the Rust convention.
There's no strong reason to <em>not</em> keep with this naming convention, so we'll go with that.</p>
<p>Now we can add definitions that get us up to <code>UINT</code>,
and we can do signed ints as well while we're at it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct WNDCLASSW {
  style: UINT,
  lpfnWndProc: WNDPROC,
  cbClsExtra: c_int,
  cbWndExtra: c_int,
  hInstance: HINSTANCE,
  hIcon: HICON,
  hCursor: HCURSOR,
  hbrBackground: HBRUSH,
  lpszMenuName: LPCWSTR,
  lpszClassName: LPCWSTR,
}
type UINT = c_uint;
type c_uint = u32;
type c_int = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Three of the fields aren't underlined in red already!</p>
<h3><a class="header" href="#reading-a-c-function-declaration" id="reading-a-c-function-declaration">Reading a C function declaration</a></h3>
<p>Now we <a href="https://duckduckgo.com/?q=WNDPROC+msdn">look up WNDPROC</a>,
which is a <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc callback function</a>:</p>
<pre><code class="language-c">LRESULT CALLBACK WindowProc(
  _In_ HWND   hwnd,
  _In_ UINT   uMsg,
  _In_ WPARAM wParam,
  _In_ LPARAM lParam
);
</code></pre>
<p>Oh, no, we're back to the weird stuff again!</p>
<p>Really, it's not too bad.
We do need a few hints though:</p>
<ul>
<li><code>_In_</code> is just a note on the intended usage of that function argument.
It's a C macro which gets replaced with nothing later on, so it's basically a code comment.
These arguments move data &quot;in&quot; to the function.
Sometimes there's &quot;out&quot; arguments,
or even &quot;in-out&quot; arguments.
We'll worry about those later.</li>
<li><code>CALLBACK</code> is a C macro that gets replaced with the &quot;callback&quot; ABI attribute.
In this case, that's <code>__stdcall</code>.
How do I know that?
Well, I had to look directly in the windows include files.
Unfortunate, but occasionally necessary.
If you have visual studio installed, it should be in something like <code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0</code>.
Then I just did a grep to look for <code>CALLBACK</code> and looked around.
Lots of false hits, but the only one where <code>CALLBACK</code> gets defined as a function attribute is
<code>127:#define CALLBACK    __stdcall</code>, so that's our winner.
(NOTE: later on I found that <code>CALLBACK</code> is discussed on the
<a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a> page,
so it's much less mysterious than I thought at first.
Still, it's good to have a note on where to find the headers,
so I'm leaving this bit in here.)</li>
</ul>
<p>Alright, get that junk out of the way and what do we see?</p>
<pre><code class="language-c">LRESULT WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
</code></pre>
<p>Oh, hey, <em>we can almost read that</em>.
It helps to remember that C puts the function output type to the left of the function's name,
and also the function argument types are to the left of each argument name.
When we think back to how strut fields were declared,
this is all fairly consistent.</p>
<p>The final <em>very</em> important thing to know is that C function pointers are nullable,
while Rust <code>fn</code> pointers are always non-null.
If we want to have a nullable value on the Rust side,
we have to use <code>Option&lt;fn()&gt;</code> instead of just <code>fn()</code>.</p>
<p>So let's finally add that <code>WNDPROC</code> definition:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type WNDPROC = Option&lt;
  unsafe extern &quot;system&quot; fn(
    hwnd: HWND,
    uMsg: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
  ) -&gt; LRESULT,
&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>VS Code says we're at 12 errors. Not so bad.</p>
<h3><a class="header" href="#void-pointers" id="void-pointers">Void Pointers</a></h3>
<p>Now that we understand what we're supposed to be doing,
it's just a matter of filling in definition after definition until all the errors go away.
A lot of them are over on that <a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a> page,
so we don't even have to look too many places.</p>
<p>Next up is <code>HINSTANCE</code>:</p>
<pre><code>HINSTANCE: A handle to an instance. This is the base address of the module in memory.

HMODULE and HINSTANCE are the same today, but represented different things in 16-bit Windows.

This type is declared in WinDef.h as follows:

typedef HANDLE HINSTANCE;
</code></pre>
<p>So</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type HINSTANCE = HANDLE;
<span class="boring">}
</span></code></pre></pre>
<p>Next, <code>HANDLE</code>:</p>
<pre><code>HANDLE: A handle to an object.

This type is declared in WinNT.h as follows:

typedef PVOID HANDLE;
</code></pre>
<p>This is where it gets interesting, because now we need to have <code>PVOID</code>:</p>
<pre><code>PVOID: A pointer to any type.

This type is declared in WinNT.h as follows:

typedef void *PVOID;
</code></pre>
<p>Remember that the <code>*</code> after the type makes it a pointer variant of the type.
It also has the <code>P</code> prefix we saw before.</p>
<p>The <code>void</code> type name in C performs a sort of double duty,
but in Rust we actually don't see it very often.</p>
<ul>
<li>When <code>void</code> is used as a <em>return type</em> it means that there's no return value from a function.
In Rust we instead use the <code>()</code> type for functions that return nothing.</li>
<li>When <code>void</code> is used as a <em>pointer target type</em> it means that the pointer points to just some opaque memory.
In Rust, we don't really care for mysterious opaque memory,
and we have generics,
so we essentially never end up using void pointers.</li>
</ul>
<p>Because the <code>void*</code> type (and the <code>const void *</code> type) are the special memory handling types in C,
LLVM has particular knowledge and opinions about how they work.
To ensure that Rust has the correct type mapping for void pointers,
there's a <a href="https://doc.rust-lang.org/core/ffi/enum.c_void.html">c_void</a> type provided in the standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PVOID = *mut core::ffi::c_void;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pointer-sized-types" id="pointer-sized-types">Pointer Sized Types</a></h3>
<p>As we proceed down the list of errors,
filling them in one at a time,
things are fairly simple based on what we know to do so far,
and we get this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type HICON = HANDLE;
type HCURSOR = HICON;
type HBRUSH = HANDLE;
type LPCWSTR = *const WCHAR;
type WCHAR = wchar_t;
type wchar_t = u16;
type HWND = HANDLE;
type WPARAM = UINT_PTR;
<span class="boring">}
</span></code></pre></pre>
<p>Then we get to <code>UINT_PTR</code>, which has a slightly funny description:</p>
<pre><code>UINT_PTR: An unsigned INT_PTR.

This type is declared in BaseTsd.h as follows:

// C++
#if defined(_WIN64)
 typedef unsigned __int64 UINT_PTR;
#else
 typedef unsigned int UINT_PTR;
#endif
</code></pre>
<p>Hmm, a little confusing.
So far the types haven't cared about the architecture size.
Maybe something is up.
Let's see what <code>INT_PTR</code> says:</p>
<pre><code>INT_PTR	
A signed integer type for pointer precision. Use when casting a pointer to an integer to perform pointer arithmetic.

This type is declared in BaseTsd.h as follows:

// C++
#if defined(_WIN64) 
 typedef __int64 INT_PTR; 
#else 
 typedef int INT_PTR;
#endif
</code></pre>
<p>Ah ha, so <code>INT_PTR</code> is the signed integer type used for <em>pointer arithmetic</em>,
and <code>UINT_PTR</code> is the unsigned version of course.
Well, if they're for pointer math, that's why they care about the size of a pointer.
If you know your Rust types then you already know what we need to use.
That's right, <code>isize</code> and <code>usize</code>.
They're naturally the size of a pointer, and there's the signed and unsigned variants and everything.</p>
<p>And now we can finally get no errors with our struct declaration!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type c_int = i32;
type c_uint = u32;
type HANDLE = PVOID;
type HBRUSH = HANDLE;
type HCURSOR = HICON;
type HICON = HANDLE;
type HINSTANCE = HANDLE;
type HWND = HANDLE;
type LONG_PTR = isize;
type LPARAM = LONG_PTR;
type LPCWSTR = *const WCHAR;
type LRESULT = LONG_PTR;
type PVOID = *mut core::ffi::c_void;
type UINT = c_uint;
type UINT_PTR = usize;
type WCHAR = wchar_t;
type wchar_t = u16;
type WPARAM = UINT_PTR;

type WNDPROC = Option&lt;
  unsafe extern &quot;system&quot; fn(
    hwnd: HWND,
    uMsg: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
  ) -&gt; LRESULT,
&gt;;

#[repr(C)]
pub struct WNDCLASSW {
  style: UINT,
  lpfnWndProc: WNDPROC,
  cbClsExtra: c_int,
  cbWndExtra: c_int,
  hInstance: HINSTANCE,
  hIcon: HICON,
  hCursor: HCURSOR,
  hbrBackground: HBRUSH,
  lpszMenuName: LPCWSTR,
  lpszClassName: LPCWSTR,
}
<span class="boring">}
</span></code></pre></pre>
<p>Phew.</p>
<h2><a class="header" href="#continuing-the-windowing-tutorial" id="continuing-the-windowing-tutorial">Continuing The Windowing Tutorial</a></h2>
<p>I don't know if you recall,
but like a decade ago when this article started we had a <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window">windowing tutorial</a>
that we were working on.</p>
<h3><a class="header" href="#making-a-wndclassw-value" id="making-a-wndclassw-value">Making a <code>WNDCLASSW</code> value</a></h3>
<p>It says that we need to fill in the window procedure, the hinstance, and the class name.
The other stuff is optional, but those are essential.</p>
<p>In the sample C++ code, we see this interesting line:</p>
<pre><code class="language-cpp">WNDCLASS wc = { };
</code></pre>
<p>That's a little odd looking, it might not be obvious what's happening.
It's declaring a variable <code>wc</code>, of type <code>WNDCLASS</code>, and then zeroing the entire struct.
Keeping in mind that <code>WNDCLASS</code> is an alias for either <code>WNDCLASSA</code> or <code>WNDCLASSW</code>,
depending on how you're building the C++ program,
and also keeping in mind that we're always going to be using the <code>W</code> versions of things,
then the equivalent Rust would be something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main () {
  let mut wc: WNDCLASSW = unsafe { core::mem::zeroed() };
}
</code></pre></pre>
<p>We haven't even called the OS and we've already got <code>unsafe</code> stuff going on.</p>
<p>But... does this need to be <code>unsafe</code> that everyone thinks about?
Is this the kind of unsafe action that we need to evaluate the correctness of every type we do it?
No, not at all.
It's always safe to make a default <code>WNDCLASSW</code> by zeroing the memory.
We know that right now, and that doesn't change based on the situation.
So we'll just give a <code>Default</code> impl to our type that does this for us.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WNDCLASSW {
  #[inline]
  #[must_use]
  fn default() -&gt; Self {
    unsafe { core::mem::zeroed() }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In fact, this is going to be true for all the foreign C structs we declare.
We'll just make a macro to handle this for us consistently.
When you're making a lot of bindings by hand, consistency is king.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! unsafe_impl_default_zeroed {
  ($t:ty) =&gt; {
    impl Default for $t {
      #[inline]
      #[must_use]
      fn default() -&gt; Self {
        unsafe { core::mem::zeroed() }
      }
    }
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>&quot;Lokathor, why did you put unsafe in that macro name? Default isn't an unsafe trait.&quot;
Good question.
It's because the macro <em>could</em> be used improperly.
The <code>unsafe</code> block around the call to <code>zeroed</code> tells the compiler &quot;no, hush, it's fine, I checked.&quot;
So if you were to use the macro to make a <code>Default</code> impl for a type that can't be safely zeroed,
then you'd sure have a problem on your hand.</p>
<p>Any time a macro hides away some sort of unsafe thing, you should put unsafe in the name.
It's a simple convention, but it keeps it obvious that the macro can go wrong if misused.</p>
<p>Now our rust can look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let mut wc = WNDCLASSW::default();
}
</code></pre></pre>
<p>And that's so much nicer, at least to my eyes.</p>
<h3><a class="header" href="#writing-a-window-procedure" id="writing-a-window-procedure">Writing a Window Procedure</a></h3>
<p>The guide says</p>
<blockquote>
<p>We'll examine the window procedure in detail later. For now, just treat this as a forward reference.</p>
</blockquote>
<p>So, for now we'll just make a dummy window procedure that panics if it's actually called.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern &quot;system&quot; fn dummy_window_procedure(
  hwnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  unimplemented!()
}
<span class="boring">}
</span></code></pre></pre>
<p>And we can start filling in the <code>wc</code> value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = todo!();
  wc.lpszClassName = todo!();
}
</code></pre></pre>
<h3><a class="header" href="#getting-the-hinstance" id="getting-the-hinstance">Getting the HINSTANCE</a></h3>
<p>This next part is a hair tricky to solve on your own.</p>
<p>What the tutorial wants us to do is pass the <code>hInstance</code> value that we were given at the start of the <code>WinMain</code> function.
Except the problem is that we're not writing a Windows C++ program so we don't have a WinMain function at all.
We're writing a Rust program, and the Rust program starts at <code>fn main()</code>, with no instance argument.</p>
<p>If we just ask the internet about <a href="https://duckduckgo.com/?q=msdn+get+my+instance">&quot;msdn get my instance&quot;</a>
then there's not too much help.
However, if we phrase it more like <a href="https://duckduckgo.com/?q=msdn+get+my+hinstance+c%2B%2B">&quot;msdn get my hinstance c++&quot;</a>
then there's a lovely <a href="https://stackoverflow.com/questions/1749972/determine-the-current-hinstance">StackOverflow</a>
asking about this very situation.
If we call <code>GetModuleHandle(NULL)</code> we can get the <code>HINSTANCE</code> of our exe.</p>
<p>Interestingly, one of the comments on the question also says that we can just plain pass <code>NULL</code> as our instance value and it'll be fine.
However, the MSDN tutorial says to pass an <code>HINSTANCE</code>,
and this pushes us to learn a bit and try a new thing,
so we'll at least try the <code>GetModuleHandle</code> way first.</p>
<p>If we look up <code>GetModuleHandle</code>, we see that it has an <code>A</code>-form and <code>W</code>-form, since it takes a name, and the name is textual.
We want to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew">GetModuleHandleW</a>, as discussed.</p>
<blockquote>
<p>If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).</p>
</blockquote>
<p>Sounds good.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = GetModuleHandleW(core::ptr::null());

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = todo!();
}
</code></pre></pre>
<p>Well, obviously this won't work, but let's check that error message for fun:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
error[E0425]: cannot find function, tuple struct or tuple variant `GetModuleHandleW` in this scope
  --&gt; src\main.rs:18:19
   |
18 |   let hInstance = GetModuleHandleW(core::ptr::null());
   |                   ^^^^^^^^^^^^^^^^ not found in this scope
</code></pre>
<p>Okay, so we need to declare the function before we can use it.
We do this with an <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">external block</a>.</p>
<p>An external block just declares the signature of a function, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// EXAMPLE USAGE
extern ABI {
  fn NAME1(args) -&gt; output;
  
  fn NAME2(args) -&gt; output;

  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The actual function is &quot;external&quot; to the program.
To perform compilation, all the compiler really needs is the correct function signature.
This allows it to perform type checking, and ensure the correct call ABI is used.
Later on, the linker sorts it all out.
If it turns out that a function can't be linked after all,
you get a link error rather than a compile error.</p>
<p>But who tells the linker what to link with to find the external functions?
Well, you can use a build script, or you can put it right on the extern block.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// EXAMPLE USAGE
#[link(name = &quot;LibraryName&quot;)]
extern ABI {
  fn NAME1(args) -&gt; output;
}
<span class="boring">}
</span></code></pre></pre>
<p>If the library is some sort of common system library that the linker will already know about,
then it's perfectly fine to just use the attribute.
In other cases, like if a library name varies by operating system, you might need the build script.</p>
<p>Where do we find <code>GetModuleHandleW</code> though?
MSDN tells us right there on the page.
If we look in the <strong>Requirements</strong> section we'll see:</p>
<blockquote>
<p>DLL:	Kernel32.dll</p>
</blockquote>
<p>So in our Rust we have our declaration like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`GetModuleHandleW`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew)
  pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -&gt; HMODULE;
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can call <code>GetModuleHandleW</code> without error (if we put an <code>unsafe</code> block around the call):</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = todo!();
}
</code></pre></pre>
<h3><a class="header" href="#wide-strings" id="wide-strings">Wide Strings</a></h3>
<p>The last thing we need is one of those fancy <code>LPCWSTR</code> things.
A &quot;long pointer to a C-style wide string&quot;.
Well a long pointer is just a pointer.
And a wide string, to Windows, means a UTF-16 string.
The only thing we haven't mentioned yet is the C-style thing.</p>
<p>There's two basic ways to handle strings.</p>
<ul>
<li>&quot;Null terminated&quot;, where the string is just a pointer, but it isn't allowed to contain 0.
To determine the string's length you have to walk the string until you see a 0, and that's the end of the string.</li>
<li>&quot;ptr+len&quot;, where the string is a pointer and a length, and the string can contain any value.
To determine the length, you just check the length value.</li>
</ul>
<p>Rust uses the ptr+len style for strings, as well as for slices in general.
C and C++ use the null terminated style for strings.</p>
<p>It's not <em>too</em> difficult to convert a ptr+len string into a null terminated string,
but it's also not entirely free.
Pushing an extra 0 onto the end of the string is only cheap if there's spare capacity to do it.
In the case of string literals, for example,
you'd have to allocate a separate string, because the literal is kept in read-only memory.</p>
<p>The basic form of this is very simple code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Turns a Rust string slice into a null-terminated utf-16 vector.
pub fn wide_null(s: &amp;str) -&gt; Vec&lt;u16&gt; {
  s.encode_utf16().chain(Some(0)).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>.encode_utf16()</code> makes the basic encoding iterator,
then <code>.chain(Some(0))</code> puts a 0 on the end of the iteration,
and we just <code>.collect()</code> it into a totally normal <code>Vec&lt;u16&gt;</code>.</p>
<p>Long term, if we were using a lot of UTF-16,
we might want to build a way to have these &quot;C wide strings&quot; computed as compile time and stored as literals.
It lets the program allocate a little less as it performs its startup stuff.
However, the code for that is a little hairy, and a bit of a side story compared to the current goal.</p>
<p>Soooo.... we can just write it like this, right?</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  // BAD, WRONG, NO
  wc.lpszClassName = wide_null(&quot;Sample Window Class&quot;).as_ptr();
}
</code></pre></pre>
<p>Ah, we can't do that!
This is a classic beginner's mistake, but it must be avoided.</p>
<p>If we wrote it like that, the vec of utf-16 would get allocated, then we'd call <code>as_ptr</code>,
assign that pointer to <code>wc.lpszClassName</code>, and then... the expression would end.
And the vector would drop, and clean up, and deallocate the memory we wanted to point to.
We'd have a dangling pointer, horrible.
Maybe it'd even sometimes work anyway.
The allocator might not re-use the memory right away, so it might still hold useful data for a while.
It's still some nasty Undefined Behavior though.</p>
<p>Here's the correct way to do it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };
  let sample_window_class_wn = wide_null(&quot;Sample Window Class&quot;);

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();
}
</code></pre></pre>
<p>This way, the <code>sample_window_class_wn</code> binding holds the vector live,
and the pointer can be used for as long as that binding lasts.
In this case, to the end of the <code>main</code> function.</p>
<h3><a class="header" href="#registering-the-window-class" id="registering-the-window-class">Registering The Window Class</a></h3>
<p>Okay, so our widow class request is all filled out, we just have to register it using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw">RegisterClassW</a>:</p>
<pre><code class="language-cpp">ATOM RegisterClassW(
  const WNDCLASSW *lpWndClass
);
</code></pre>
<p>And in Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type ATOM = WORD;
type WORD = c_ushort;
type c_ushort = u16;
#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`RegisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw)
  pub fn RegisterClassW(lpWndClass: *const WNDCLASSW) -&gt; ATOM;
}
<span class="boring">}
</span></code></pre></pre>
<p>It's a little weird sometimes to see that the <code>const</code> and <code>*</code> part are &quot;around&quot; the target type in C,
and then both on the same side of the type in Rust,
but that's genuinely the correct translation.</p>
<p>So now we can make the register call:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };
  let sample_window_class_wn = wide_null(&quot;Sample Window Class&quot;);

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();

  unsafe { RegisterClassW(&amp;wc) };
}
</code></pre></pre>
<p>But we don't know if it worked or not.
Almost any call to the operating system can fail.
Cosmic rays and stuff.
If we check the <strong>Return value</strong> part of the MSDN page it says:</p>
<blockquote>
<p>If the function fails, the return value is zero. To get extended error information, call <code>GetLastError</code>.</p>
</blockquote>
<p>Hmm, let's check <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>,
that sounds like a thing we'll want to use a lot.</p>
<p>yada yada... thead local error code...
yada yada... some functions set an error code and <em>then</em> succeed...
okay... &quot;To obtain an error string for system error codes, use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function.&quot;
Oof, we'd have a whole extra layer to dive into if we went down that path.
&quot;For a complete list of error codes provided by the operating system, see <a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes">System Error Codes</a>.&quot;
Okay, well that's not too bad.
For now, we can show an error code and then look it up by hand.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type DWORD = c_ulong;
type c_ulong = u32;
#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`GetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
  pub fn GetLastError() -&gt; DWORD;
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we have basic error checking / reporting:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hInstance = unsafe { GetModuleHandleW(core::ptr::null()) };
  let sample_window_class_wn = wide_null(&quot;Sample Window Class&quot;);

  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(dummy_window_procedure);
  wc.hInstance = hInstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();

  let atom = unsafe { RegisterClassW(&amp;wc) };
  if atom == 0 {
    let last_error = unsafe { GetLastError() };
    panic!(&quot;Could not register the window class, error code: {}&quot;, last_error);
  }
}
</code></pre></pre>
<h2><a class="header" href="#creating-the-window" id="creating-the-window">Creating The Window</a></h2>
<p>VS Code says I'm at like 4500 words already, and we haven't even made our Window yet.</p>
<blockquote>
<p>To create a new instance of a window, call the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw">CreateWindowEx</a> function:</p>
</blockquote>
<p>Okay, sure, that'll be nice and easy, no proble--</p>
<pre><code class="language-cpp">HWND CreateWindowExW(
  DWORD     dwExStyle,
  LPCWSTR   lpClassName,
  LPCWSTR   lpWindowName,
  DWORD     dwStyle,
  int       X,
  int       Y,
  int       nWidth,
  int       nHeight,
  HWND      hWndParent,
  HMENU     hMenu,
  HINSTANCE hInstance,
  LPVOID    lpParam
);
</code></pre>
<p>oof!</p>
<p>Okay, actually most of these we've seen before.
This is getting easier the more we do.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type HMENU = HANDLE;
type LPVOID = *mut core::ffi::c_void;
#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`CreateWindowExW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw)
  pub fn CreateWindowExW(
    dwExStyle: DWORD, lpClassName: LPCWSTR, lpWindowName: LPCWSTR,
    dwStyle: DWORD, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int,
    hWndParent: HWND, hMenu: HMENU, hInstance: HINSTANCE, lpParam: LPVOID,
  ) -&gt; HWND;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>CreateWindowEx</code> returns a handle to the new window, or zero if the function fails.
To show the window—that is, make the window visible —pass the window handle to the
<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a> function</p>
</blockquote>
<p>Hey, look, the MSDN docs are using some of that extended typography we mentioned before.</p>
<p>Apparently we want our window creation to look something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // first register the class, as before

  let sample_window_name_wn = wide_null(&quot;Sample Window Name&quot;);
  let hwnd = unsafe {
    CreateWindowExW(
      0,
      sample_window_class_wn.as_ptr(),
      sample_window_name_wn.as_ptr(),
      WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      core::ptr::null_mut(),
      core::ptr::null_mut(),
      hInstance,
      core::ptr::null_mut(),
    )
  };
}
</code></pre></pre>
<p>Now we just have to define <code>WS_OVERLAPPEDWINDOW</code> and <code>CW_USEDEFAULT</code>.
These are defined in the header files as C macro values, which expand to literals.
In Rust, we <em>could</em> define them as macros, but it'd be a little silly.
We probably want to define them as <code>const</code> values instead.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WS_OVERLAPPED: u32 = 0x00000000;
const WS_CAPTION: u32 = 0x00C00000;
const WS_SYSMENU: u32 = 0x00080000;
const WS_THICKFRAME: u32 = 0x00040000;
const WS_MINIMIZEBOX: u32 = 0x00020000;
const WS_MAXIMIZEBOX: u32 = 0x00010000;
const WS_OVERLAPPEDWINDOW: u32 = WS_OVERLAPPED
  | WS_CAPTION
  | WS_SYSMENU
  | WS_THICKFRAME
  | WS_MINIMIZEBOX
  | WS_MAXIMIZEBOX;
const CW_USEDEFAULT: c_int = 0x80000000_u32 as c_int;
<span class="boring">}
</span></code></pre></pre>
<p>There's more <code>WS_</code> values you could define, but that's enough to start.</p>
<p>Oh, and heck, we probably want to just import <code>null</code> and <code>null_mut</code> since we'll be using them a lot.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ptr::{null, null_mut};
<span class="boring">}
</span></code></pre></pre>
<p>For calling <code>ShowWindow</code>, we have a <code>HWND</code> already,
but the show parameter is apparently another one of those WinMain arguments.
Instead we'll just look at the list of what the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>
docs say, and I guess we can pick <code>SW_SHOW</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SW_SHOW: c_int = 5;
type BOOL = c_int;
#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`ShowWindow`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow)
  pub fn ShowWindow(hWnd: HWND, nCmdShow: c_int) -&gt; BOOL;
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, now we can at least make the window and the program will close.
We expect it to like, flicker on screen really fast and then disappear, or something.</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target\debug\triangle-from-scratch.exe`
thread 'main' panicked at 'not implemented', src\main.rs:60:3
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\triangle-from-scratch.exe` (exit code: 0xc0000409, STATUS_STACK_BUFFER_OVERRUN)
</code></pre>
<p>Whoops!
Haha, remember how we had that dummy window procedure?
It's actually <em>not</em> supposed to panic and unwind the stack during the callback.
Bad things end up happening.
We just did it to fill in a little bit so the compiler would be cool.</p>
<p>Now that we're tying to turn on the program on for real (even for a second),
we need a real window procedure.
But we don't know how to write one yet.
Never fear, there's a function called <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowprocw">DefWindowProcW</a>.
It's the &quot;Default Window Procedure&quot;, that you can use to handle any messages you don't want to handle.
Right now, for us, that's all of them.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // ...
  wc.lpfnWndProc = Some(DefWindowProcW);
  // ...
}

#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`DefWindowProcW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowprocw)
  pub fn DefWindowProcW(
    hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -&gt; LRESULT;
}
</code></pre></pre>
<p>And, finally, we can get a window to flicker on the screen!</p>
<h2><a class="header" href="#handling-window-messages" id="handling-window-messages">Handling Window Messages</a></h2>
<p>We're on to the next page of the tutorial!</p>
<p>Now we get to learn all about <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/window-messages">Window Messages</a></p>
<p>First we need to define this great <code>MSG</code> struct:</p>
<pre><code class="language-cpp">typedef struct tagMSG {
  HWND   hwnd;
  UINT   message;
  WPARAM wParam;
  LPARAM lParam;
  DWORD  time;
  POINT  pt;
  DWORD  lPrivate;
} MSG, *PMSG, *NPMSG, *LPMSG;
</code></pre>
<p>In Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct MSG {
  hwnd: HWND,
  message: UINT,
  wParam: WPARAM,
  lParam: LPARAM,
  time: DWORD,
  pt: POINT,
  lPrivate: DWORD,
}
unsafe_impl_default_zeroed!(MSG);
<span class="boring">}
</span></code></pre></pre>
<p>Hey look, we have nearly all of that defined already.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type LONG = c_long;
type c_long = i32;
#[repr(C)]
pub struct POINT {
  x: LONG,
  y: LONG,
}
unsafe_impl_default_zeroed!(POINT);
<span class="boring">}
</span></code></pre></pre>
<p>And now we can get our window messages.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`GetMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew)
  pub fn GetMessageW(
    lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT,
  ) -&gt; BOOL;
}
<span class="boring">}
</span></code></pre></pre>
<p>We have to get them in a loop of course, because we'll be getting a whole lot of them.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // first open the window

  let mut msg = MSG::default();
  loop {
    let message_return = unsafe { GetMessageW(&amp;mut msg, null_mut(), 0, 0) };
    if message_return == 0 {
      break;
    } else if message_return == -1 {
      let last_error = unsafe { GetLastError() };
      panic!(&quot;Error with `GetMessageW`, error code: {}&quot;, last_error);
    }
  }
}
</code></pre></pre>
<p>Except we're missing <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">TranslateMessage</a>
and <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagew">DispatchMessageW</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`TranslateMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage)
  pub fn TranslateMessage(lpMsg: *const MSG) -&gt; BOOL;

  /// [`DispatchMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagew)
  pub fn DispatchMessageW(lpMsg: *const MSG) -&gt; LRESULT;
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay so then we put those into our <code>loop</code>, if there's no problem with getting the message:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  loop {
    let message_return = unsafe { GetMessageW(&amp;mut msg, null_mut(), 0, 0) };
    if message_return == 0 {
      break;
    } else if message_return == -1 {
      let last_error = unsafe { GetLastError() };
      panic!(&quot;Error with `GetMessageW`, error code: {}&quot;, last_error);
    } else {
      unsafe {
        TranslateMessage(&amp;msg);
        DispatchMessageW(&amp;msg);
      }
    }
  }
<span class="boring">}
</span></code></pre></pre>
<p>There's a lot of good info on the page about window messages,
but that's all we have to do here in terms of our code.</p>
<p>By now, our program can open a window.
However, we also see an eternally spinning mouse once it's open.
We also <em>don't</em> see our program close when we close the window.
It just continues to spin in the <code>loop</code>,
and we have to exit it by pressing Ctrl+C in the command line.</p>
<h2><a class="header" href="#writing-the-window-procedure" id="writing-the-window-procedure">Writing The Window Procedure</a></h2>
<p>Next up is <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/writing-the-window-procedure">Writing the Window Procedure</a>.</p>
<p>That default window procedure we've been using so far is fine for most events.
Usually it just ignores every event.
However, a few event types can't just be ignored.
One of them is that window closing situation.
Another is that thing with the mouse cursor.</p>
<p>First let's do the window closing and cleanup.
If we look at MSDN page for the <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-close">WM_CLOSE</a>
message, we can see that we'll need to be able to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow">DestroyWindow</a>
and <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a>.
We also need to respond to <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-destroy">WM_DESTROY</a> as well.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const WM_CLOSE: u32 = 0x0010;
pub const WM_DESTROY: u32 = 0x0002;

#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`DestroyWindow`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow)
  pub fn DestroyWindow(hWnd: HWND) -&gt; BOOL;

  /// [`PostQuitMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage)
  pub fn PostQuitMessage(nExitCode: c_int);
}
<span class="boring">}
</span></code></pre></pre>
<p>And we have to write our own procedure.
This time, no panics.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>There's a few different ways we can arrange the branching here,
and it comes down to taste in the end,
but most of the messages should return 0 when you've processed them.
We'll assume that 0 is the &quot;normal&quot; response and build our setup around that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; DestroyWindow(hWnd),
    WM_DESTROY =&gt; PostQuitMessage(0),
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>One little problem here is that <code>DestroyWindow</code> and <code>PostQuitMessage</code> have different return types.
Even though we're ignoring the output of <code>DestroyWindow</code>, it's a type error to have it like this.
We can suppress the output of <code>DestroyWindow</code> by putting it in a block and having a <code>;</code> after it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; {
      DestroyWindow(hWnd);
    }
    WM_DESTROY =&gt; PostQuitMessage(0),
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Ehhhhhh, I'm not sure if I'm a fan of <code>rustfmt</code> making it look like that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; drop(DestroyWindow(hWnd)),
    WM_DESTROY =&gt; PostQuitMessage(0),
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Oh, yeah, that's the good stuff.
We can use <code>drop</code> to throw away the <code>i32</code> value,
so then we don't need the <code>;</code> and braces,
so rustfmt keeps it on a single line.
I am <em>all about</em> that compact code stuff.</p>
<p>Now we can open the window and click for it to close and the program actually terminates.</p>
<h2><a class="header" href="#fixing-the-cursor-maybe" id="fixing-the-cursor-maybe">Fixing The Cursor (maybe?)</a></h2>
<p>The mouse cursor is still kinda funky.
It gets kinda... <em>stuck</em> with different icons.
If you move the mouse into the window area from different sides,
the little &quot;adjust window size&quot; cursors don't change to the normal cursor once the mouse is in the middle of the window.
That's mostly our fault, we left the cursor for our Window Class as null.</p>
<p>Instead, if we use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw">LoadCursorW</a>
we can assign a cursor to our window class,
and then the default window procedure will set the cursor to be the right image at the right time.</p>
<p>We're supposed to call it with something like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  // ...
  wc.hCursor = unsafe { LoadCursorW(hInstance, IDC_ARROW) };
  // ...
}
</code></pre></pre>
<p>And the extern function is easy to do:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`LoadCursorW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw)
  pub fn LoadCursorW(hInstance: HINSTANCE, lpCursorName: LPCWSTR) -&gt; HCURSOR;
}
<span class="boring">}
</span></code></pre></pre>
<p>But how do we make that <code>IDC_ARROW</code> thing?
In the docs for <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw">LoadCursorW</a>
they're all listed as <code>MAKEINTRESOURCE(number)</code>.
Okay so we look up <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-makeintresourcew">MAKEINTRESOURCEW</a>
and... it's a C macro. Blast.
Okay so we can't link to it and call it,
instead we'll have to grep the windows includes to see what's happening.</p>
<pre><code>C:\Program Files (x86)\Windows Kits\10\Include&gt;rg &quot;#define MAKEINTRESOURCE&quot;
10.0.16299.0\um\WinUser.h
215:#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
216:#define MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
218:#define MAKEINTRESOURCE  MAKEINTRESOURCEW
220:#define MAKEINTRESOURCE  MAKEINTRESOURCEA

10.0.16299.0\shared\ks.h
4464:#define MAKEINTRESOURCE( res ) ((ULONG_PTR) (USHORT) res)
</code></pre>
<p>Hm, so.. the input value is cast to a <code>WORD</code>,
then cast directly to a <code>ULONG_PTR</code>,
then cast directly to a string pointer (either ansi or wide).
That's not too hard at all.</p>
<p>We <em>could</em> do this as a Rust macro,
but I feel like we might want to use a <code>const fn</code> instead.
I just like having the types be a little more checked when possible.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type LPWSTR = *mut WCHAR;
type ULONG_PTR = usize;
/// [`MAKEINTRESOURCEW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-makeintresourcew)
pub const fn MAKEINTRESOURCEW(i: WORD) -&gt; LPWSTR {
  i as ULONG_PTR as LPWSTR
}
const IDC_ARROW: LPCWSTR = MAKEINTRESOURCEW(32512);
<span class="boring">}
</span></code></pre></pre>
<p>Did that fix it?
Huh. Nope.</p>
<p>Sometimes you're really sure that you know what's wrong,
it's just <em>so</em> obvious,
but you didn't know at all,
and you basically wasted your time with some dead end.
This is frustrating, but it's okay.
We all make mistakes.</p>
<p>In some web searches about this problem,
I've heard that the mouse cursor sometimes is heuristic in Windows,
and once Windows thinks that your app is behaving properly,
it'll make the mouse cursor so the right thing for you.
I don't have any idea if this is true or not.
If it is true, then maybe once we add more to our program the mouse cursor will start working right.
Let's move on, we can come back to this later.</p>
<h2><a class="header" href="#painting-the-window" id="painting-the-window">Painting The Window</a></h2>
<p>The tutorial wants to tell us about <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/painting-the-window">Painting The Window</a> next.</p>
<p>So we have to accept a <code>WM_PAINT</code> message:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WM_PAINT: u32 = 0x000F;
<span class="boring">}
</span></code></pre></pre>
<p>And then do a little dance with a <code>PAINTSTRUCT</code>,
as well as the additional types it depends on:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct PAINTSTRUCT {
  hdc: HDC,
  fErase: BOOL,
  rcPaint: RECT,
  fRestore: BOOL,
  fIncUpdate: BOOL,
  rgbReserved: [BYTE; 32],
}
unsafe_impl_default_zeroed!(PAINTSTRUCT);
type HDC = HANDLE;
type BYTE = u8;
#[repr(C)]
pub struct RECT {
  left: LONG,
  top: LONG,
  right: LONG,
  bottom: LONG,
}
unsafe_impl_default_zeroed!(RECT);
<span class="boring">}
</span></code></pre></pre>
<p>This is all becoming routine by now, I hope.</p>
<p>They want us to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint">BeginPaint</a>,
then <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect">FillRect</a> on the whole canvas,
then <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint">EndPaint</a>.
Sounds easy enough to do.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`BeginPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint)
  pub fn BeginPaint(hWnd: HWND, lpPaint: LPPAINTSTRUCT) -&gt; HDC;

  /// [`FillRect`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect)
  pub fn FillRect(hDC: HDC, lprc: *const RECT, hbr: HBRUSH) -&gt; c_int;

  /// [`EndPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint)
  pub fn EndPaint(hWnd: HWND, lpPaint: *const PAINTSTRUCT) -&gt; BOOL;
}
const COLOR_WINDOW: u32 = 5;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>COLOR_WINDOW</code> constant I had to look up in the headers.</p>
<p>Now we adjust the window procedure a bit to do the painting:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe extern &quot;system&quot; fn window_procedure(
  hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
) -&gt; LRESULT {
  match Msg {
    WM_CLOSE =&gt; drop(DestroyWindow(hWnd)),
    WM_DESTROY =&gt; PostQuitMessage(0),
    WM_PAINT =&gt; {
      let mut ps = PAINTSTRUCT::default();
      let hdc = BeginPaint(hWnd, &amp;mut ps);
      let _success = FillRect(hdc, &amp;ps.rcPaint, (COLOR_WINDOW + 1) as HBRUSH);
      EndPaint(hWnd, &amp;ps);
    }
    _ =&gt; return DefWindowProcW(hWnd, Msg, wParam, lParam),
  }
  0
}
<span class="boring">}
</span></code></pre></pre>
<p>Window looks the same as before,
but if we fiddle with the brush value we can see it'll draw using other colors.
Doesn't seem to fix the mouse though.</p>
<h2><a class="header" href="#closing-the-window" id="closing-the-window">Closing The Window</a></h2>
<p>The tutorial page about <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/closing-the-window">Closing The Window</a>
has a fun part where we can open a message box.
I like the occasional message box, let's do that.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`MessageBoxW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxw)
  pub fn MessageBoxW(
    hWnd: HWND, lpText: LPCWSTR, lpCaption: LPCWSTR, uType: UINT,
  ) -&gt; c_int;
}
const MB_OKCANCEL: u32 = 1;
const IDOK: c_int = 1;
<span class="boring">}
</span></code></pre></pre>
<p>So here's a fun question, how do we decide when a constant should be <code>u32</code> or <code>c_int</code> or whatever type of int?
The correct answer is that there's no correct answer.
I just pick based on how I see the API using it most of the time.
That is, if it's a <code>const</code> that gets compared to a return from a function,
we use the function's return type.
If it's a <code>const</code> we pass to a function, we use the function's argument type.
Sometimes a value will be used as more than one type of number, then you'll have to just pick one.
In C the number types can just automatically convert, so they don't really care.
In Rust, that's not the case, so I just try to pick a default type for the value.
So that most of the time I can write <code>MY_CONST</code> and not <code>MY_CONST as _</code>.</p>
<h2><a class="header" href="#managing-application-state" id="managing-application-state">Managing Application State</a></h2>
<p>Ah, we're back to a slightly tricky part of things.
In <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-application-state-">Managing Application State</a>
we get some notions thrown around like &quot;use just global variables until it gets too complicated!&quot;
Well, no thanks MSDN. I'll go directly to the stage where there's no global variables.</p>
<p>First, we need to be ready to handle <code>WM_NCCREATE</code> and <code>WM_CREATE</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WM_NCCREATE: u32 = 0x0081;
const WM_CREATE: u32 = 0x0001;
<span class="boring">}
</span></code></pre></pre>
<p>And we check for them in our window procedure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in the window_procedure
  match Msg {
    WM_NCCREATE =&gt; {
      println!(&quot;NC Create&quot;);
      return 1;
    }
    WM_CREATE =&gt; println!(&quot;Create&quot;),
<span class="boring">}
</span></code></pre></pre>
<p>Let's see those messages print out...</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
     Running `target\debug\triangle-from-scratch.exe`
NC Create
thread 'main' panicked at 'Failed to create a window.', src\main.rs:53:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\triangle-from-scratch.exe` (exit code: 101)
</code></pre>
<p>Nani!?
Something already went wrong.
Better check the full docs for <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-nccreate">WM_NCCREATE</a>.
Ah, see, it's right there.</p>
<blockquote>
<p>Return Value: If an application processes this message, it should return TRUE to continue creation of the window.
If the application returns FALSE, the CreateWindow or CreateWindowEx function will return a NULL handle.</p>
</blockquote>
<p>Okay, so far all of our messages have asked us to just <em>always</em> return 0 when the message was handled,
and this is the first message we've been handling that we had to decide to return 0 or not.
Well, right now our window creation should always proceed, so here we go:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in the window_procedure
WM_NCCREATE =&gt; {
  println!(&quot;NC Create&quot;);
  return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>And give this a test now:</p>
<pre><code>D:\dev\triangle-from-scratch&gt;cargo run
   Compiling triangle-from-scratch v0.1.0 (D:\dev\triangle-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
     Running `target\debug\triangle-from-scratch.exe`
NC Create
Create
</code></pre>
<p>Naisu!</p>
<p>Hey, better check on <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-create">WM_CREATE</a>
to see if it has any return stuff we just got right on accident:</p>
<blockquote>
<p><strong>Return value:</strong> If an application processes this message, it should return zero to continue creation of the window.
If the application returns –1, the window is destroyed and the CreateWindowEx or CreateWindow function returns a NULL handle.</p>
</blockquote>
<p>Ah, yeah, we were getting it right sorta on accident.
Gotta always read those docs.</p>
<p>Okay now we continue the tutorial:</p>
<blockquote>
<p>The last parameter of CreateWindowEx is a pointer of type <code>void*</code>.
You can pass any pointer value that you want in this parameter.
When the window procedure handles the <code>WM_NCCREATE</code> or <code>WM_CREATE</code> message,
it can extract this value from the message data.</p>
</blockquote>
<p>Right, so, we have to have a void pointer to pass to the message.
Uh, just to pick something, let's pass our message a pointer to the number 5.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in main
let lparam: *mut i32 = Box::leak(Box::new(5_i32));
let hwnd = unsafe {
  CreateWindowExW(
    0,
    sample_window_class_wn.as_ptr(),
    sample_window_name_wn.as_ptr(),
    WS_OVERLAPPEDWINDOW,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    null_mut(),
    null_mut(),
    hInstance,
    lparam.cast(),
  )
};
<span class="boring">}
</span></code></pre></pre>
<p>So we're making a boxed <code>i32</code>,
then we leak the box because we don't want Rust to drop this box based on scope.
Instead, we'll clean up the box as part of the window destruction.</p>
<blockquote>
<p>When you receive the <code>WM_NCCREATE</code> and <code>WM_CREATE</code> messages,
the lParam parameter of each message is a pointer to a <code>CREATESTRUCT</code> structure.</p>
</blockquote>
<p>The <code>CREATESTRUCT</code> type has <code>A</code> and <code>W</code> forms.
Since we're using <code>CreateWindowExW</code>, we'll assume that we use <code>CREATESTRUCTW</code> here.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct CREATESTRUCTW {
  lpCreateParams: LPVOID,
  hInstance: HINSTANCE,
  hMenu: HMENU,
  hwndParent: HWND,
  cy: c_int,
  cx: c_int,
  y: c_int,
  x: c_int,
  style: LONG,
  lpszName: LPCWSTR,
  lpszClass: LPCWSTR,
  dwExStyle: DWORD,
}
unsafe_impl_default_zeroed!(CREATESTRUCTW);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can get out the boxed pointer thing from the create struct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_NCCREATE =&gt; {
  println!(&quot;NC Create&quot;);
  let createstruct: *mut CREATESTRUCTW = lParam as *mut _;
  if createstruct.is_null() {
    return 0;
  }
  let boxed_i32_ptr: *mut i32 = (*createstruct).lpCreateParams.cast();
  return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw">SetWindowLongPtrW</a>
to connect this create struct pointer to the window itself.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`SetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw)
  pub fn SetWindowLongPtrW(
    hWnd: HWND, nIndex: c_int, dwNewLong: LONG_PTR,
  ) -&gt; LONG_PTR;
}
const GWLP_USERDATA: c_int = -21;
<span class="boring">}
</span></code></pre></pre>
<p>And it's fairly simple to call, but we have to put a manual cast to <code>LONG_PTR</code> in:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_NCCREATE =&gt; {
  println!(&quot;NC Create&quot;);
  let createstruct: *mut CREATESTRUCTW = lParam as *mut _;
  if createstruct.is_null() {
    return 0;
  }
  let boxed_i32_ptr = (*createstruct).lpCreateParams;
  SetWindowLongPtrW(hWnd, GWLP_USERDATA, boxed_i32_ptr as LONG_PTR);
  return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we can use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw">GetWindowLongPtrW</a>
to get our windows's custom user data:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`GetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw)
  pub fn GetWindowLongPtrW(hWnd: HWND, nIndex: c_int) -&gt; LONG_PTR;
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, uh, we'll print out the current value or something.
I guess, each time we go to <code>WM_PAINT</code> we'll print the value and add 1 to it.
Just any old thing to see that it's working.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_PAINT =&gt; {
  let ptr = GetWindowLongPtrW(hWnd, GWLP_USERDATA) as *mut i32;
  println!(&quot;Current ptr: {}&quot;, *ptr);
  *ptr += 1;
  let mut ps = PAINTSTRUCT::default();
  let hdc = BeginPaint(hWnd, &amp;mut ps);
  let _success = FillRect(hdc, &amp;ps.rcPaint, (COLOR_WINDOW + 1) as HBRUSH);
  EndPaint(hWnd, &amp;ps);
}
<span class="boring">}
</span></code></pre></pre>
<p>That'll print 5, and then if you force a bunch of paint messages you can see it count up.
The easiest way to do that is to adjust the window's size so that it's small,
then drag it to be bigger.
Each time the window's size expands it triggers new paint messages.</p>
<p>Of course, we also can't forget that cleanup code we promised.
The way we do the cleanup is to just turn the raw pointer back into a <code>Box&lt;i32&gt;</code>.
The drop code for the Box type will handle the rest for us.
Of course, we should only do this right as the window is being destroyed.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WM_DESTROY =&gt; {
  let ptr = GetWindowLongPtrW(hWnd, GWLP_USERDATA) as *mut i32;
  Box::from_raw(ptr);
  println!(&quot;Cleaned up the box.&quot;);
  PostQuitMessage(0);
}
<span class="boring">}
</span></code></pre></pre>
<p>And finally, I think we're done!</p>
<h2><a class="header" href="#hey-what-about-the-triangle" id="hey-what-about-the-triangle">Hey, What About The Triangle?</a></h2>
<p>Well, there's several ways to draw a triangle in windows.
You can use DirectX, OpenGL, Vulkan, probably some other ways I don't even know about.
This lesson is going to stop at <em>just</em> the window creation part.
Then, each other lesson on a particular Windows drawing API can assume you've read this as a baseline level of understanding.</p>
<h2><a class="header" href="#fixing-that-stupid-cursor" id="fixing-that-stupid-cursor">Fixing That Stupid Cursor</a></h2>
<p>Before I finished this, I really wanted to figure out what was going on with that cursor.</p>
<p>So what I did was, first we want to handle the <code>WM_SETCURSOR</code> event,
and then in the event we call the <code>SetCursor</code> function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
    WM_SETCURSOR =&gt; {
      let hInstance = GetModuleHandleW(null());
      let cursor = LoadCursorW(hInstance, IDC_ARROW);
      let _old_cursor = SetCursor(cursor);
      //
      return 1;
    }
// ...

#[link(name = &quot;User32&quot;)]
extern &quot;system&quot; {
  /// [`SetCursor`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setcursor)
  pub fn SetCursor(hCursor: HCURSOR) -&gt; HCURSOR;
}
const WM_SETCURSOR: u32 = 0x0020;
<span class="boring">}
</span></code></pre></pre>
<p>Alright, so, what happens if you do that?
Well, the cursor disappears entirely.
What? Why?
Well, let's check the docs for <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setcursor">SetCursor</a>.
Hm, hmm, hmmmm, yeah.</p>
<blockquote>
<p>If this parameter is NULL, the cursor is removed from the screen.</p>
</blockquote>
<p>Okay, so we must be getting null for <code>cursor</code>.
So <code>LoadCursorW(hInstance, IDC_ARROW)</code> is returning null...
and that's how we're setting <code>wc.hCursor</code> during startup!
So we must have been setting null <em>this whole time</em>.
What fools we've been.</p>
<p>Okay let's check out the MSDN guide on <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/setting-the-cursor-image">Setting the Cursor Image</a>.
They've got some sample code:</p>
<pre><code class="language-cpp">hCursor = LoadCursor(NULL, cursor);
SetCursor(hCursor);
</code></pre>
<p>Oh. Huh. So, you're supposed to pass null to the load call?
I guess that makes sense.
I mean we had an HINSTANCE sitting around and we just used it,
but whe you think about it,
our own executable file probably <em>doesn't</em> contain the <code>IDC_ARROW</code> cursor.</p>
<p>So if we delete the cursor handling code from the window procedure,
and just adjust the startup code to be correct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut wc = WNDCLASSW::default();
wc.lpfnWndProc = Some(window_procedure);
wc.hInstance = hInstance;
wc.lpszClassName = sample_window_class_wn.as_ptr();
wc.hCursor = unsafe { LoadCursorW(null_mut(), IDC_ARROW) };
<span class="boring">}
</span></code></pre></pre>
<p>Well now our cursor works just fine!</p>
<p>The day is saved!</p>
<h1><a class="header" href="#win32-window-cleanup" id="win32-window-cleanup">Win32 Window Cleanup</a></h1>
<p>During our introduction to Win32 I said that we'd just write all our code into <code>main.rs</code>,
and then we could sort it into the library later.</p>
<p>Well, later is now.</p>
<h2><a class="header" href="#new-files" id="new-files">New Files</a></h2>
<p>This isn't very hard.
Cargo follows a &quot;convention over configuration&quot; style,
so as long as we do what it expects we won't even have to change <code>Cargo.toml</code> or anything.</p>
<p>First we copy <code>src/main.rs</code> into <code>examples/win32_window_standalone.rs</code>,
so that we can keep our nice small version that's all in one file.
Over time our library will build up,
and later lessons will refer to things we've put in our library already.
However, this first example can be understood in a single file,
without a person having to know what we've put into our library.
I think that's pretty valuable, so we will preserve this first draft for later viewing.</p>
<p>Then we make <code>src/lib.rs</code>.
This holds the top level items of the library.
Within the crate's module hierarchy, <code>lib.rs</code> is a module is <em>above</em> the other modules of the crate.
Within the filesystem on disk, <code>lib.rs</code> is a file <em>beside</em> the other files that make up the crate.
With <em>all other</em> modules, the default filesystem location for a module matches the module's logical crate location.
With <code>lib.rs</code> it's just slightly magical, so it has a different default filesystem location.
Sometimes people find this one exception confusing,
so I'm trying to be extra clear about what's going on regarding this point.</p>
<p>Next, since this is all Win32 specific stuff we'll be putting in the library right now,
which obviously doesn't work on all targets,
we'll make a <code>src/win32.rs</code> file,
and then declare it as a conditional module within the library.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

#[cfg(windows)]
pub mod win32;
<span class="boring">}
</span></code></pre></pre>
<p>Now, if we're on windows, we'll be able to use our nice <code>win32</code> module.</p>
<h2><a class="header" href="#put-the-declarations-in-the-library" id="put-the-declarations-in-the-library">Put The Declarations In The Library</a></h2>
<p>Okay first we put every single type, struct, const, and extern declaration into <code>win32.rs</code>.
We also have to make sure that all the fields and types are marked as <code>pub</code>.</p>
<p>Then we put a <code>use triangle_from_scratch::win32::*;</code> in our program.</p>
<p>The <code>main.rs</code> should only be left with <code>main</code> and <code>window_procedure</code>,
but the program should build and run exactly as before.</p>
<p>Also, I'm going to remove the <code>allow</code> attributes at the top of the <code>main.rs</code>,
and then convert the file to standard Rust naming for all the variables.
This doesn't make the program do better things, but it helps people read it.</p>
<h2><a class="header" href="#we-got-too-much-unsafe" id="we-got-too-much-unsafe">We Got Too Much Unsafe</a></h2>
<p>All this <code>unsafe</code> code isn't great.
Having <code>unsafe</code> code around means that if we aren't careful we don't get &quot;just&quot; a wrong output or an unexpected panic,
instead we get some sort of <em>Undefined Behavior</em> (UB).
UB <em>might</em> do what you expected, or it <em>might</em> segfault, or it <em>might</em> be a security vulnerability.
I'd rather not have a security vulnerability in my program,
so I'd like to reduce the amount of <code>unsafe</code> code in the program as much as I can.</p>
<p><code>/rant start</code></p>
<p>Let's be very plain: You cannot fully eliminate <code>unsafe</code>.</p>
<p>Fundamentally, interacting with the outside world is <code>unsafe</code>.
If your program doesn't have any <code>unsafe</code> <em>anywhere</em> in the call stack,
then it's not actually interacting with the world at all,
and that's a pretty useless program to be running.</p>
<p>Operating systems and device drivers aren't designed to be free of UB.
They are designed for you to pay attention, and ask for the right thing at the right time.
We have to run <code>unsafe</code> code to get <em>anything</em> useful done.</p>
<p>However, <code>unsafe</code> code is <strong>not</strong> automatically the end of everything.
It's code that <em>can</em> go wrong, but that doesn't means it <em>must</em> go wrong.</p>
<p>Fire can burn down your house, but you also need it to forge metal.</p>
<p><code>/rant end</code></p>
<p>Our job, every time we use an <code>unsafe</code> block, is to make sure,
either with compile time checks or runtime checks,
that we don't call any <code>unsafe</code> functions improperly.</p>
<p>It's &quot;that simple&quot;.
You know, &quot;just&quot; get good.</p>
<p>Every time we have an <code>unsafe</code> block, that block needs to be audited for correctness.
The less <code>unsafe</code> blocks we have, the less we need to audit.</p>
<p>Our strategy is that we want to put our <code>unsafe</code> blocks inside of safe functions,
and then the safe function performs whatever checks it needs to before actually making the <code>unsafe</code> function call.
That might mean a runtime check,
or the type system might even allow for static correctness to be known without a runtime check.
Either way, we get it right <em>once</em> in the safe wrapper function,
and then all other code only calls the safe function from there on.
Then we only have to audit the <code>unsafe</code> block in one location,
not everywhere all over the codebase.</p>
<p>I know, &quot;put it in a function&quot; is a very basic concept.
You could have thought of that too, I'm sure.
Still, sometimes it helps just to put the plan into words, even if it seems obvious.</p>
<h2><a class="header" href="#safe-wrapping-getmodulehandlew" id="safe-wrapping-getmodulehandlew">Safe Wrapping <code>GetModuleHandleW</code></a></h2>
<p>Alright so what can we <em>actually</em> make into safe functions?</p>
<p>Well the first thing the program does is call <code>GetModuleHandleW(null())</code>.
Is that legal?
I mean we can at least say that it seems intentional, that doesn't mean it's correct.
Let's checks the docs for <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew">GetModuleHandleW</a>.</p>
<blockquote>
<p>lpModuleName: ... If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).</p>
</blockquote>
<p>Okay, not only are we allowed to pass null, but if we do then we get a special sort of default-ish return value.</p>
<p>In terms of an interface for a wrapper function for this,
I think it'd be a little awkward to try and accept both null and non-null arguments and have it be ergonomic and stuff.
Thankfully, <em>we don't actually have to do that</em>.
We're just using the null argument style,
and if we use the non-null argument variant later we can just make it a totally separate function later.
So let's write a function for calling <code>GetModuleHandleW(null())</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns a handle to the file used to create the calling process (.exe file)
///
/// See [`GetModuleHandleW`](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew)
pub fn get_process_handle() -&gt; HMODULE {
  // Safety: as per the MSDN docs.
  unsafe { GetModuleHandleW(null()) }
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can call that at the start of our <code>fn main()</code> in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  let hinstance = get_process_handle();
  // ...
</code></pre></pre>
<p>No <code>unsafe</code> block! One less thing to audit!</p>
<h2><a class="header" href="#safe-wrapping-loadcursorw" id="safe-wrapping-loadcursorw">Safe Wrapping <code>LoadCursorW</code></a></h2>
<p>So we go down a bit, the next <code>unsafe</code> function is <code>LoadCursorW</code>.
That one gave us some trouble for quite a while.
I was passing the wrong argument in the first position,
and then getting a null back without realizing it.
It wasn't actually UB, it was an allowed function call to make,
but I should have been checking the function's output and handling the error.
Forgetting to handle the error case is what was causing my downfall.</p>
<p>Let's have a look at <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw">LoadCursorW</a>.</p>
<p>We see that the <code>HINSTANCE</code> we pass has to be an executable file with a cursor in it.
That's a thing, did you know that?
You can put cursors and icons <em>inside</em> of executables and then programs can pick them out and use them.
I knew you could do that with icons for desktop shortcuts,
but I guess it works with cursors too.
Neat.</p>
<p>Right now the program says <code>LoadCursorW(null_mut(), IDC_ARROW)</code>, so can we pass null?
It doesn't say anything about null in the description for <code>hInstance</code>,
but lower down in the description for <code>lpCursorName</code> it says if you pass an <code>IDC_</code> value from the list as the <code>lpCursorName</code>,
then in that case you should set <code>hInstance</code> to null.</p>
<p>Like with how we wrapped <code>GetModuleHandleW</code>,
we don't need to make a <em>single</em> wrapper function that handles every possible case that <code>LoadCursorW</code> does.
Here, lets just make a function for loading the <code>IDC_</code> cursors.
If we want to load cursors out of non-null instances later on that can be a separate function.</p>
<p>And let's not forget to check that Return Value error case information:</p>
<blockquote>
<p>If the function succeeds, the return value is the handle to the newly loaded cursor.
If the function fails, the return value is NULL. To get extended error information, call <code>GetLastError</code>.</p>
</blockquote>
<p>Simple enough. What do the Remarks have to say? Ah, this part sounds important:</p>
<blockquote>
<p>This function returns a valid cursor handle only if the lpCursorName parameter is a pointer to a cursor resource.
If lpCursorName is a pointer to any type of resource other than a cursor (such as an icon),
the return value is not NULL, even though it is not a valid cursor handle.</p>
</blockquote>
<p>Yikes, so we want to be very sure that we're passing a value from that list of allowed values.</p>
<p>Okay, so what if we make an enum of what you're allowed to pass in.
On the Rust side, you can only have an enum of a real variant.
Constructing an improper enum is already UB, so we don't even have to think about that case.
If we define our enum properly then we know people will only be allowed to pass correct values.</p>
<p>And since things can error, let's use a <code>Result</code> type for the output.
For now, the error will just be the <code>()</code> type.
We'll come back here once we've looked at <code>GetLastError</code>,
and made ourselves a useful error code type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The predefined cursor styles.
pub enum IDCursor {
  /// Standard arrow and small hourglass
  AppStarting = 32650,
  /// Standard arrow
  Arrow = 32512,
  /// Crosshair
  Cross = 32515,
  /// Hand
  Hand = 32649,
  /// Arrow and question mark
  Help = 32651,
  /// I-beam
  IBeam = 32513,
  /// Slashed circle
  No = 32648,
  /// Four-pointed arrow pointing north, south, east, and west
  SizeAll = 32646,
  /// Double-pointed arrow pointing northeast and southwest
  SizeNeSw = 32643,
  /// Double-pointed arrow pointing north and south
  SizeNS = 32645,
  /// Double-pointed arrow pointing northwest and southeast
  SizeNwSe = 32642,
  /// Double-pointed arrow pointing west and east
  SizeWE = 32644,
  /// Vertical arrow
  UpArrow = 32516,
  /// Hourglass
  Wait = 32514,
}

/// Load one of the predefined cursors.
///
/// See [`LoadCursorW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw)
pub fn load_predefined_cursor(cursor: IDCursor) -&gt; Result&lt;HCURSOR, ()&gt; {
  // Safety: The enum only allows values from the approved list. See MSDN.
  let hcursor =
    unsafe { LoadCursorW(null_mut(), MAKEINTRESOURCEW(cursor as WORD)) };
  if hcursor.is_null() {
    Err(())
  } else {
    Ok(hcursor)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>That's a lot of variants, but the wrapper function is still very simple.
The tag values of the enum are each set to the <code>MAKEINTRESOURCEW</code> input shown in the documentation.
When an enum is passed in, <code>cursor as WORD</code> will give us the tag value.
We pass that value to <code>MAKEINTRESOURCEW</code>, then it goes off to <code>LoadCursorW</code>.</p>
<p>Also, remember that <code>MAKEINTRESOURCEW</code> is just some type casting stuff,
it's not actually making any resources we have to free up later.</p>
<p>Let's check our <code>fn main</code> with this update:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut wc = WNDCLASSW::default();
  wc.lpfnWndProc = Some(window_procedure);
  wc.hInstance = hinstance;
  wc.lpszClassName = sample_window_class_wn.as_ptr();
  wc.hCursor = load_predefined_cursor(IDCursor::Arrow).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Ah ha! Now it's clear that we're going for a predefined cursor,
<em>and</em> it's clear that the call could fail.
Of course, using <code>unwrap</code> isn't a very robust way to solve problems.
It's <em>absolutely</em> not allowed in a good library (always pass the error back up!),
but in a binary it's &quot;sorta okay, I guess&quot;, particularly since this is a demo.</p>
<h2><a class="header" href="#partial-wrapping-registerclassw" id="partial-wrapping-registerclassw">Partial Wrapping <code>RegisterClassW</code></a></h2>
<p><em>Partial</em> wrapping?
I can hear you asking.</p>
<p>Yeah, you can't always make it safe.
But you can at least <em>almost</em> always make it better typed.</p>
<p>If we have a look at the docs of our next <code>unsafe</code> function call,
<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw">RegisterClassW</a>,
It says &quot;You must fill the structure with the appropriate class attributes before passing it to the function.&quot;</p>
<p>But the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw">WNDCLASSW</a>
type is full of pointers to strings and stuff.
There's like three things that <em>aren't</em> pointers,
and then all the rest is a pile of pointers.
We don't have any easy way to track the validity of all the fields.
I'm sure it's possible to do something here to make sure that all fields are valid all the time,
but I'm also sure that the amount of effort that it would take would exceed the effort to just use an <code>unsafe</code> block and audit that code every so often.</p>
<p>So we're going to make a wrapper function,
but we'll leave it as an <code>unsafe</code> function.
Even then, we can give a better input and output type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Registers a window class struct.
///
/// ## Safety
///
/// All pointer fields of the struct must be valid.
///
/// See [`RegisterClassW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw)
pub unsafe fn register_class(window_class: &amp;WNDCLASSW) -&gt; Result&lt;ATOM, ()&gt; {
  let atom = RegisterClassW(window_class);
  if atom == 0 {
    Err(())
  } else {
    Ok(atom)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, and then the usage code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let atom = unsafe { register_class(&amp;wc) }.unwrap_or_else(|()| {
    let last_error = unsafe { GetLastError() };
    panic!(&quot;Could not register the window class, error code: {}&quot;, last_error);
  });
<span class="boring">}
</span></code></pre></pre>
<p>Hmm.
At first glance, things didn't improve as much as we might have wanted.
Ah, but here's an interesting thing.
Now <code>atom</code> is marked as a <em>totally unused</em> variable.
We can't even forget to check for an error any more,
someone else already did that for us.</p>
<p>Still, the error case is very wonky.
That needs a fix.</p>
<h2><a class="header" href="#safe-wrapping-getlasterror" id="safe-wrapping-getlasterror">Safe Wrapping <code>GetLastError</code></a></h2>
<p>I'm pretty sure I remember how <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>
worked.
It was super simple, right?
Yeah, it just gives you the thread-local last-error value.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the thread-local last-error code value.
///
/// See [`GetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
pub fn get_last_error() -&gt; DWORD {
  unsafe { GetLastError() }
}
<span class="boring">}
</span></code></pre></pre>
<p>Done.
Right?</p>
<p>Naw, of course not.
Keep reading.</p>
<blockquote>
<p>To obtain an error string for system error codes, use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function.
For a complete list of error codes provided by the operating system, see <a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes">System Error Codes</a>.</p>
</blockquote>
<p>So we want to be able to print out the error string.
Really, the least we can do for our users.
Let's just have a quick look at <code>FormatMessage</code> and... oh... oh my...
You see that function signature?
There's flags, there's pointers, there's even a <code>va_list</code> thing we don't know about.
Oof.</p>
<h2><a class="header" href="#a-newtype-for-the-error-code" id="a-newtype-for-the-error-code">A Newtype For The Error Code</a></h2>
<p>Okay, okay.
When there's a lot to do, one step at a time is usually the best way to do it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct Win32Error(pub DWORD);
<span class="boring">}
</span></code></pre></pre>
<p>But, unlike the other types so far, this type is really intended to be shown to people.
For this, there's two main traits that Rust supports:</p>
<ul>
<li><code>Debug</code> is for when you want to show the value <em>to a Rust programmer</em>.</li>
<li><code>Display</code> is for when you want to show the value <em>to the general public</em>.</li>
</ul>
<p>So for our Debug impl, it can just show &quot;Win32Error(12)&quot; or similar.
This is exactly what a derived <code>Debug</code> impl will do, so we'll use the derive:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
#[repr(transparent)]
pub struct Win32Error(pub DWORD);
<span class="boring">}
</span></code></pre></pre>
<p>For Display we can't derive an implementation.
I don't mean that we <em>shouldn't</em> derive an implementation,
but that we literally cannot.
The standard library literally doesn't offer a derive for the <code>Display</code> trait.
That's because the standard library is managed by people who are very silly.
They have a silly concern that a derived Display impl &quot;might&quot; not show the right sort of info.
Instead of saying &quot;if the derive doesn't do the right thing for you, write the impl by hand&quot;,
they just completely refuse to offer a derive at all.
Like I said, completely silly.</p>
<p>But we won't dwell on that too much,
because even if the derive was there, we wouldn't be able to use it in this case.</p>
<p>Instead... we get to use everyone's favorite function.... <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagew">FormatMessageW</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl core::fmt::Display for Win32Error {
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    todo!(&quot;call FormatMessageW&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>First we define the extern we need:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type LPCVOID = *const core::ffi::c_void;
pub type va_list = *mut c_char;
pub type c_char = i8;
#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`FormatMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagew)
  pub fn FormatMessageW(
    dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD,
    lpBuffer: LPWSTR, nSize: DWORD, Arguments: va_list,
  ) -&gt; DWORD;
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's go through each argument one by one.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl core::fmt::Display for Win32Error {
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    let dwFlags = todo!();
    let lpSource = todo!();
    let dwMessageId = todo!();
    let dwLanguageId = todo!();
    let lpBuffer = todo!();
    let nSize = todo!();
    let Arguments = todo!();
    let dword = unsafe {
      FormatMessageW(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        lpBuffer,
        nSize,
        Arguments,
      )
    };
    todo!(&quot;call FormatMessageW&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>dwFlags</code> lets us control a lot of options.
Looking carefully, it seems like we want <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>,
which makes <code>FormatMessageW</code> perform the allocation of a large enough buffer.
But then... if we use this <code>lpBuffer</code> gets a little odd.
More on that in a moment.
We also want <code>FORMAT_MESSAGE_FROM_SYSTEM</code>, since these are system errors.
All done? Not quite.
If we skip ahead down the page to &quot;Security Remarks&quot; then we see that we need <code>FORMAT_MESSAGE_IGNORE_INSERTS</code> too.
<em>Now</em> are we done?
Hmm, if we set the low-order byte we can fiddle the line length, but we don't need that.
We'll leave it as 0.</li>
<li><code>lpSource</code> is the location of the message definition.
It's only used if our message is from an hmodule or a string.
Since our message is from the system the argument is ignored,
so we'll leave this as null.</li>
<li><code>dwMessageId</code> is the identifier of the requested message.
That means the error code, so we'll set <code>self.0</code> here.</li>
<li><code>dwLanguageId</code> is the language identifier of the message.
Happily, if we just pass 0, then it'll basically look up the best message it can,
and then format that. So we'll just pass 0.</li>
<li><code>lpBuffer</code> is... hey we had to remember something about this!
Okay so because we're using <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>...
well <em>normally</em> this would be interpreted as <code>LPWSTR</code> (pointer to a null-terminated wide string).
However, since we're using <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>,
instead the function will use our pointer as a pointer to the start of a buffer.
The <code>lpBuffer</code> is written with the buffer start info,
and then we read it back after the function completes,
and we get our allocation that way.
So, in our use case, the <code>lpBuffer</code> arg is a pointer <em>to a pointer</em>.
We have to be careful about this point.</li>
<li><code>nSize</code> is the size of the output buffer, if you're providing the output buffer,
or it's the minimum output buffer size you want if you're using <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code>.
We don't have any minimum needs, so we'll give 0.</li>
<li><code>Arguments</code> is the insert arguments for the formatting.
However, we're using <code>FORMAT_MESSAGE_IGNORE_INSERTS</code>, so we'll pass null.</li>
</ul>
<p><strong>Returns:</strong> what we get back is the number of <code>TCHAR</code> values stored in the buffer,
<em>excluding</em> the final null character.
A <code>TCHAR</code> is either an <code>i8</code> (for <code>A</code> functions) or a <code>u16</code> (for <code>W</code> functions).</p>
<p>Okay, so, let's review what we've got so far, because this is a lot of little things:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl core::fmt::Display for Win32Error {
  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    let dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER
      | FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS;
    let lpSource = null_mut();
    let dwMessageId = self.0;
    let dwLanguageId = 0;
    let mut buffer: *mut u16 = null_mut();
    let lpBuffer = &amp;mut buffer as *mut *mut u16 as *mut u16;
    let nSize = 0;
    let Arguments = null_mut();
    let tchar_count_excluding_null = unsafe {
      FormatMessageW(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        lpBuffer,
        nSize,
        Arguments,
      )
    };
    todo!(&quot;read the buffer&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>So if we got a count of 0, of if the buffer is still null,
then there was some sort of problem.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if tchar_count_excluding_null == 0 || buffer.is_null() {
  // some sort of problem happened. we can't usefully get_last_error since
  // Display formatting doesn't let you give an error value.
  return Err(core::fmt::Error);
} else {
  todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>If there was no problem then we need to access the buffer.
The simplest way is to turn it into a slice:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    } else {
      let buffer_slice: &amp;[u16] = unsafe {
        core::slice::from_raw_parts(buffer, tchar_count_excluding_null as usize)
      };
      todo!()
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now we can decode the data with <a href="https://doc.rust-lang.org/core/char/fn.decode_utf16.html">decode_utf16</a>.
This iterates over the <code>u16</code> values, producing <code>Result&lt;char, DecodeUtf16Error&gt;</code> as it goes.
If there was any decoding error, let's just use the standard <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">Unicode Replacement Character</a> instead.
Then we put whatever character we've got into the output.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for decode_result in
  core::char::decode_utf16(buffer_slice.iter().copied())
{
  let ch = decode_result.unwrap_or('�');
  write!(f, &quot;{}&quot;, ch)?;
}
<span class="boring">}
</span></code></pre></pre>
<p>Cool.
All done?
Ah, not quite.</p>
<p>Remember how we had <code>FormatMessageW</code> allocate the buffer for us?
We need to free that buffer or we'll have a memory leak.
A memory leak is <em>safe</em>, but it's still <em>bad</em>.</p>
<p>There's more than one allocation system within Windows.
To free this memory, <code>FormatMessageW</code> says that we need to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree">LocalFree</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type HLOCAL = HANDLE;
#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`LocalFree`](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree)
  pub fn LocalFree(hMem: HLOCAL) -&gt; HLOCAL;
}
<span class="boring">}
</span></code></pre></pre>
<p>So where's our call to <code>FreeLocal</code> go?
At the end, right?
Except we also have all those <code>?</code> operators on the writing.
Any of those can early return from the function.</p>
<p>Let's use the magic of <code>Drop</code> to solve our problem.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OnDropLocalFree(HLOCAL);
impl Drop for OnDropLocalFree {
  fn drop(&amp;mut self) {
    unsafe { LocalFree(self.0) };
  }
}
let _on_drop = OnDropLocalFree(buffer as HLOCAL);
let buffer_slice: &amp;[u16] = unsafe {
  core::slice::from_raw_parts(buffer, tchar_count_excluding_null as usize)
};
for decode_result in
  core::char::decode_utf16(buffer_slice.iter().copied())
{
  let ch = decode_result.unwrap_or('�');
  write!(f, &quot;{}&quot;, ch)?;
}
Ok(())
<span class="boring">}
</span></code></pre></pre>
<p>Isn't that cool?
I think it's pretty cool.</p>
<p>One small note: we have to be sure to bind it to a local variable.
If we didn't bind it to a local variable, or if we bound it to the special <code>_</code> variable,
then the struct would drop <em>immediately</em> (before we read the buffer),
and then things would go very wrong.</p>
<p>If we test it out with error code 0, we can see &quot;The operation completed successfully.\r\n&quot;.
Hmm, let's eat up those newline characters though. We didn't want those.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match decode_result {
  Ok('\r') | Ok('\n') =&gt; write!(f, &quot; &quot;)?,
  Ok(ch) =&gt; write!(f, &quot;{}&quot;, ch)?,
  Err(_) =&gt; write!(f, &quot;�&quot;)?,
}
<span class="boring">}
</span></code></pre></pre>
<p>that's better.</p>
<p>One other note: if the 29th bit is set, then it's an application error.
The system doesn't know how to format those, so we won't even ask it.
Instead, we'll just show display that and return early.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter) -&gt; core::fmt::Result {
    if self.0 &amp; (1 &lt;&lt; 29) &gt; 0 {
      return write!(f, &quot;Win32ApplicationError({})&quot;, self.0);
    }
<span class="boring">}
</span></code></pre></pre>
<p>We want our error getting function to use this great new type we worked on:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the thread-local last-error code value.
///
/// See [`GetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
pub fn get_last_error() -&gt; Win32Error {
  Win32Error(unsafe { GetLastError() })
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we can update our stuff that returns <code>Result</code> types to use this error type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_predefined_cursor(cursor: IDCursor) -&gt; Result&lt;HCURSOR, Win32Error&gt; {
  // ...
}

pub unsafe fn register_class(
  window_class: &amp;WNDCLASSW,
) -&gt; Result&lt;ATOM, Win32Error&gt; {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>There's also the <a href="https://doc.rust-lang.org/std/error/trait.Error.html">std::error::Error</a> trait.
It's a bit of a mess right now, but there's a Working Group trying to develop things to be better in the future.
At the moment, we might as well implement <code>std::error::Error</code> for our error type,
just to be potentially more compatible with the rest of the Rust ecosystem.
It's not like we even have to do anything, it's all default methods:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::error::Error for Win32Error {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#window-creation" id="window-creation">Window Creation</a></h2>
<p>The next <code>unsafe</code> function that our <code>main</code> calls is <code>CreateWindowExW</code>.
This one is one heck of a swiss-army-chainsaw of a function.
See, it turns out that, in Win32, not only are the things we think of as windows &quot;windows&quot;,
but <em>tons</em> of the GUI elements are &quot;windows&quot; too.
It's all windows, everywhere, all over the place.</p>
<p>So <code>CreateWindowExW</code> has like a million options it can do.
It also has a ton of arguments that can't be easily verified.
It's just as bad as <code>register_class</code>,
the only difference is that the arguments are passed as arguments,
instead of being stuffed into a struct and then passed as a single struct.</p>
<p>Like we did with with <code>register_class</code>,
we're gonna basically skip on the verification and leave it as <code>unsafe</code>.
What we will do is give it a <code>Result</code> for the output,
so that we enforce the error handling on ourselves.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Creates a window.
///
/// See [`CreateWindowExW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw)
pub unsafe fn create_window_ex_w(
  ex_style: DWORD, class_name: LPCWSTR, window_name: LPCWSTR, style: DWORD,
  x: c_int, y: c_int, width: c_int, height: c_int, parent: HWND, menu: HMENU,
  instance: HINSTANCE, param: LPVOID,
) -&gt; Result&lt;HWND, Win32Error&gt; {
  let hwnd = CreateWindowExW(
    ex_style,
    class_name,
    window_name,
    style,
    x,
    y,
    width,
    height,
    parent,
    menu,
    instance,
    param,
  );
  if hwnd.is_null() {
    Err(get_last_error())
  } else {
    Ok(hwnd)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ugh.
Are we really adding value here?
Isn't the point to like, you know, cut down on accidents?
Let's simplify this.</p>
<ul>
<li>First of all, we'll just accept <code>&amp;str</code> and then make wide strings ourselves.
This lets us use string literals, and the extra allocation isn't a huge deal.
We're already calling the OS to make a window, so this isn't a &quot;hot path&quot; function.</li>
<li>Next, we won't accept <code>ex_style</code> or <code>style</code> values.
We'll just pick some &quot;good default&quot; values to use.
Since a user can always just bypass our decision if they really want to
(by calling <code>CreateWindowExW</code> themselves), it's fine.</li>
<li>Instead of accepting <code>x</code> and <code>y</code>, we'll just take an <code>Option&lt;[i32;2]&gt;</code> as the position.
If you give a <code>Some</code> then it uses the two array values as the <code>x</code> and <code>y</code>.
If you give a <code>None</code> then both <code>x</code> and <code>y</code> will be <code>CW_USEDEFAULT</code>, which gives a default position.
This is <em>much</em> simpler than the normal rules for how <code>CW_USEDEFAULT</code> works.
The normal rules seriously take up about two paragraphs of the <code>CreateWindowExW</code> documentation.</li>
<li>Also, the window size can be <code>[i32; 2]</code>.
It doesn't seem particularly useful to keep the ability to have a default size.
It's not a huge burden to have the caller always pick a size.</li>
<li>We don't need to specify a parent window.
We'll always pass null, so that's one less thing for the caller to think about.</li>
<li>We don't need to specify a custom menu to use.
A null argument here means to use the class window,
so if we wanna change the menu we'd change it on the window class.
Again, one less thing for the caller to think about in the 99% case.</li>
<li>The instance isn't useful to pass in,
we can just have <code>create_app_window</code> look up the instance itself.</li>
<li>We'll rename <code>param</code> to <code>create_param</code>.
Normally, the styles used can change the meaning of this pointer.
With the styles we're using, this will be the argument to the <code>WM_NCCREATE</code> event.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn create_app_window(
  class_name: &amp;str, window_name: &amp;str, position: Option&lt;[i32; 2]&gt;,
  [width, height]: [i32; 2], create_param: LPVOID,
) -&gt; Result&lt;HWND, Win32Error&gt; {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>That's a <em>lot</em> less for the caller to think about.
We can call it at moderate improvement.</p>
<h2><a class="header" href="#messages" id="messages">Messages</a></h2>
<p>Next would be <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>,
but I'm not sure we can provide much help there.
We don't have a general window abstraction where we can be sure that a <code>HWND</code> is real or not.
So even if we made an enum for the second arg, it'd be an <code>unsafe</code> function overall.
There's also no error value to help fix up into an <code>Option</code> or <code>Result</code>.
I suppose we'll skip over it for now.</p>
<p>Instead, let's have a look at <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew">GetMessageW</a>.
Here's a function where I think we can make some improvements.</p>
<p>The basic output of <code>GetMessageW</code> is 0 for a quit event,
or non-zero for anything else,
and if the &quot;anything else&quot; was an error, then it's specifically -1.
That's because it's <em>kinda</em> intended to be used with C's looping constructs,
where test expressions evaluating to 0 will cancel the loop.
Except, it doesn't work well with C loops because you end up missing the error when you get -1
(which isn't 0, so you'd continue the loop).
In fact MSDN <em>specifically</em> tells you to not write <code>while (GetMessage(lpMsg, hWnd, 0, 0)) {</code>,
because it does the wrong thing,
and presumably enough people wrote that and asked why it went wrong that they put it on the docs to not do that.
So I think we can easily say that they picked the wrong sentinel values for <code>GetMessageW</code> to use.
Still, they are what they are,
we'll just adapt a bit.
Instead, let's focus on if we got a message or not,
and then we can worry about if it was a quit event in the calling code.
What we want is something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets a message from the thread's message queue.
///
/// The message can be for any window from this thread,
/// or it can be a non-window message as well.
///
/// See [`GetMessageW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew)
#[inline(always)]
pub fn get_any_message() -&gt; Result&lt;MSG, Win32Error&gt; {
  let mut msg = MSG::default();
  let output = unsafe { GetMessageW(&amp;mut msg, null_mut(), 0, 0) };
  if output == -1 {
    Err(get_last_error())
  } else {
    Ok(msg)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then in <code>main</code> adjust how we call it just a bit:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
  match get_any_message() {
    Ok(msg) =&gt; {
      if msg.message == WM_QUIT {
        break;
      }
      unsafe {
        TranslateMessage(&amp;msg);
        DispatchMessageW(&amp;msg);
      }
    }
    Err(e) =&gt; panic!(&quot;Error when getting from the message queue: {}&quot;, e),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, we can make <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> safe too.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Translates virtual-key messages into character messages.
///
/// The character messages go into your thread's message queue,
/// and you'll see them if you continue to consume messages.
///
/// **Returns:**
/// * `true` if the message was `WM_KEYDOWN`, `WM_KEYUP`, `WM_SYSKEYDOWN`, or
///   `WM_SYSKEYUP`.
/// * `true` for any other message type that generated a character message.
/// * otherwise `false`
///
/// See [`TranslateMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage)
pub fn translate_message(msg: &amp;MSG) -&gt; bool {
  0 != unsafe { TranslateMessage(msg) }
}
<span class="boring">}
</span></code></pre></pre>
<p>Can we make <code>DispatchMessageW</code> safe just as easily?
Sadly, no.
Using <code>DispatchMessageW</code> causes the window procedure to be called,
<em>or</em> it can cause a timer callback to be called.
Since a call to <code>DispatchMessageW</code> with a funky <code>MSG</code> value could make arbitrary functions get called,
and with arbitrary arguments,
then we cannot wrap <code>DispatchMessageW</code> in a safe way.
In the case of <code>main</code>, we can see that we're not messing with the fields of the message,
everything in the message is what the operating system said,
so we know the message content is &quot;real&quot; content.
However, if we put a safe version of <code>DispatchMessageW</code> into our library,
that library code wouldn't actually be correct for all possible message inputs.</p>
<h2><a class="header" href="#getset-window-long-pointer" id="getset-window-long-pointer">Get/Set Window Long Pointer</a></h2>
<p>When we're using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw">SetWindowLongPtrW</a>,
and also the <code>Get</code> version,
there's a lot of options going on.
Also, we're also not checking the error values properly at the moment.</p>
<p>What's supposed to happen with the <em>setter</em> is that you set a value,
and the return value is the previous value.
If there's an error, then you get 0 back (and you call <code>GetLastError</code>).
Except, if the previous value was 0, then you can't tell if things are wrong or not.
So what you do is you first call <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>,
which we haven't used yet,
and you set the error code to 0.
Then you do <code>SetWindowLongPtrW</code> and if you do get a 0,
then you can check the error code.
If the error code is still the 0 that you set it to,
then actually you had a &quot;successful&quot; 0.
The <code>GetWindowLongPtrW</code> behaves basically the same.</p>
<p>For now, we'll <em>only</em> support getting/setting the userdata pointer.
This simplifies the problem immensely.</p>
<p>First we need to declare that we'll be using <code>SetLastError</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;Kernel32&quot;)]
extern &quot;system&quot; {
  /// [`SetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror)
  pub fn SetLastError(dwErrCode: DWORD);
}
<span class="boring">}
</span></code></pre></pre>
<p>And we'll make this callable as a safe operation,</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets the thread-local last-error code value.
///
/// See [`SetLastError`](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror)
pub fn set_last_error(e: Win32Error) {
  unsafe { SetLastError(e.0) }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can make an unsafe function for setting the userdata pointer:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets the &quot;userdata&quot; pointer of the window (`GWLP_USERDATA`).
///
/// **Returns:** The previous userdata pointer.
///
/// [`SetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw)
pub unsafe fn set_window_userdata(
  hwnd: HWND, ptr: *mut c_void,
) -&gt; Result&lt;*mut c_void, Win32Error&gt; {
  set_last_error(Win32Error(0));
  let out = SetWindowLongPtrW(hwnd, GWLP_USERDATA, ptr as LONG_PTR);
  if out == 0 {
    // if output is 0, it's only a &quot;real&quot; error if the last_error is non-zero
    let last_error = get_last_error();
    if last_error.0 != 0 {
      Err(last_error)
    } else {
      Ok(out as *mut c_void)
    }
  } else {
    Ok(out as *mut c_void)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>And this lets us upgrade our window creation process a bit:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
    WM_NCCREATE =&gt; {
      println!(&quot;NC Create&quot;);
      let createstruct: *mut CREATESTRUCTW = lparam as *mut _;
      if createstruct.is_null() {
        return 0;
      }
      let boxed_i32_ptr = (*createstruct).lpCreateParams;
      return set_window_userdata(hwnd, boxed_i32_ptr).is_ok() as LRESULT;
    }
<span class="boring">}
</span></code></pre></pre>
<p>The getter for the userdata pointer is basically the same deal:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gets the &quot;userdata&quot; pointer of the window (`GWLP_USERDATA`).
///
/// **Returns:** The userdata pointer.
///
/// [`GetWindowLongPtrW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw)
pub unsafe fn get_window_userdata(
  hwnd: HWND,
) -&gt; Result&lt;*mut c_void, Win32Error&gt; {
  set_last_error(Win32Error(0));
  let out = GetWindowLongPtrW(hwnd, GWLP_USERDATA);
  if out == 0 {
    // if output is 0, it's only a &quot;real&quot; error if the last_error is non-zero
    let last_error = get_last_error();
    if last_error.0 != 0 {
      Err(last_error)
    } else {
      Ok(out as *mut c_void)
    }
  } else {
    Ok(out as *mut c_void)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can adjust how WM_DESTROY and WM_PAINT are handled.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
    WM_DESTROY =&gt; {
      match get_window_userdata(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          Box::from_raw(ptr);
          println!(&quot;Cleaned up the box.&quot;);
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null, no cleanup&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr to clean it up: {}&quot;, e)
        }
      }
      PostQuitMessage(0);
    }
    WM_PAINT =&gt; {
      match get_window_userdata(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          let ptr = ptr as *mut i32;
          println!(&quot;Current ptr: {}&quot;, *ptr);
          *ptr += 1;
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr: {}&quot;, e)
        }
      }
      let mut ps = PAINTSTRUCT::default();
      let hdc = BeginPaint(hwnd, &amp;mut ps);
      let _success = FillRect(hdc, &amp;ps.rcPaint, (COLOR_WINDOW + 1) as HBRUSH);
      EndPaint(hwnd, &amp;ps);
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#postquitmessage" id="postquitmessage">PostQuitMessage</a></h2>
<p>This one is easy to make safe:
you give it an exit code, and that exit code goes with the WM_QUIT message you get back later on.</p>
<p>There's nothing that can go wrong, so we just wrap it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Indicates to the system that a thread has made a request to terminate
/// (quit).
///
/// The exit code becomes the `wparam` of the [`WM_QUIT`] message your message
/// loop eventually gets.
///
/// [`PostQuitMessage`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage)
pub fn post_quit_message(exit_code: c_int) {
  unsafe { PostQuitMessage(exit_code) }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then we just put that as the last line of the <code>WM_DESTROY</code> branch.</p>
<h2><a class="header" href="#beginpaint" id="beginpaint">BeginPaint</a></h2>
<p>Our next target is <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint">BeginPaint</a>,
which is another thing that's simple to make easier to use when you've got Rust types available.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Prepares the specified window for painting.
///
/// On success: you get back both the [`HDC`] and [`PAINTSTRUCT`]
/// that you'll need for future painting calls (including [`EndPaint`]).
///
/// [`BeginPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint)
pub unsafe fn begin_paint(
  hwnd: HWND,
) -&gt; Result&lt;(HDC, PAINTSTRUCT), Win32Error&gt; {
  let mut ps = PAINTSTRUCT::default();
  let hdc = BeginPaint(hwnd, &amp;mut ps);
  if hdc.is_null() {
    Err(get_last_error())
  } else {
    Ok((hdc, ps))
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#fillrect" id="fillrect">FillRect</a></h2>
<p>Using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect">FillRect</a>
you can paint using an HBRUSH <em>or</em> a system color.</p>
<p>We only want to support the system color path.
First we make an enum for all the system colors.
This is a little fiddly because some values are named more than once,
and so we have to pick just a single canonical name for each value,
but it's not too bad:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See [`GetSysColor`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getsyscolor)
pub enum SysColor {
  _3dDarkShadow = 21,
  _3dLight = 22,
  ActiveBorder = 10,
  ActiveCaption = 2,
  AppWorkspace = 12,
  /// Button face, also &quot;3D face&quot; color.
  ButtonFace = 15,
  /// Button highlight, also &quot;3D highlight&quot; color.
  ButtonHighlight = 20,
  /// Button shadow, also &quot;3D shadow&quot; color.
  ButtonShadow = 16,
  ButtonText = 18,
  CaptionText = 9,
  /// Desktop background color
  Desktop = 1,
  GradientActiveCaption = 27,
  GradientInactiveCaption = 28,
  GrayText = 17,
  Highlight = 13,
  HighlightText = 14,
  HotLight = 26,
  InactiveBorder = 11,
  InactiveCaption = 3,
  InactiveCaptionText = 19,
  InfoBackground = 24,
  InfoText = 23,
  Menu = 4,
  MenuHighlight = 29,
  MenuBar = 30,
  MenuText = 7,
  ScrollBar = 0,
  Window = 5,
  WindowFrame = 6,
  WindowText = 8,
}
<span class="boring">}
</span></code></pre></pre>
<p>and then we make a function to fill in with a system color:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Fills a rectangle with the given system color.
///
/// When filling the specified rectangle, this does **not** include the
/// rectangle's right and bottom sides. GDI fills a rectangle up to, but not
/// including, the right column and bottom row, regardless of the current
/// mapping mode.
///
/// [`FillRect`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-fillrect)
pub unsafe fn fill_rect_with_sys_color(
  hdc: HDC, rect: &amp;RECT, color: SysColor,
) -&gt; Result&lt;(), ()&gt; {
  if FillRect(hdc, rect, (color as u32 + 1) as HBRUSH) != 0 {
    Ok(())
  } else {
    Err(())
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#endpaint" id="endpaint">EndPaint</a></h2>
<p>You might think that <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint">EndPaint</a>
has some sort of error code we're ignoring.
It returns a BOOL right?
Actually when you check the docs, &quot;The return value is always nonzero&quot;.
In other words, the function might as well return nothing.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See [`EndPaint`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint)
pub unsafe fn end_paint(hwnd: HWND, ps: &amp;PAINTSTRUCT) {
  EndPaint(hwnd, ps);
}
<span class="boring">}
</span></code></pre></pre>
<p>Not a big gain in terms of API quality.
However, this way the caller can at least see they're supposed to pass a real paint struct,
and not possibly a null pointer.
Also, now it's clear that there's no output value.
We'll call it a small win.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
      match begin_paint(hwnd) {
        Ok((hdc, ps)) =&gt; {
          let _ = fill_rect_with_sys_color(hdc, &amp;ps.rcPaint, SysColor::Window);
          end_paint(hwnd, &amp;ps);
        }
        Err(e) =&gt; {
          println!(&quot;Couldn't begin painting: {}&quot;, e)
        }
      }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#a-painting-closure" id="a-painting-closure">A Painting Closure</a></h2>
<p>Is it easy to mess up the whole begin/end painting thing?
Yeah, I could see that going wrong.
One thing we might want to <em>try</em> is having a function that takes closure to do painting.</p>
<p>The function signature for this is pretty gnarly,
because <em>anything</em> with a closure is gnarly.</p>
<p>The closure is going to get three details it needs to know from the <code>PAINTSTRUCT</code>:</p>
<ul>
<li>The HDC.</li>
<li>If the background needs to be erased or not.</li>
<li>The target rectangle for painting.
Everything else in the <code>PAINTSTRUCT</code> is just system reserved info that we don't even care about.</li>
</ul>
<p>Our library function will get the HWND and the closure.
It starts the painting,
runs the closure,
and then ends the painting.
Remember that we want the painting to be ended <em>regardless</em> of success/failure of the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Performs [`begin_paint`] / [`end_paint`] around your closure.
pub unsafe fn do_some_painting&lt;F, T&gt;(hwnd: HWND, f: F) -&gt; Result&lt;T, Win32Error&gt;
where
  F: FnOnce(HDC, bool, RECT) -&gt; Result&lt;T, Win32Error&gt;,
{
  let (hdc, ps) = begin_paint(hwnd)?;
  let output = f(hdc, ps.fErase != 0, ps.rcPaint);
  end_paint(hwnd, &amp;ps);
  output
}
<span class="boring">}
</span></code></pre></pre>
<p>Neat!</p>
<p>Note that, to write this, we needed to make <code>RECT</code> a <code>Copy</code> type.
Most all the C structs we're declaring should be Debug, Clone, Copy, etc.
We just didn't add all the impls at the time.</p>
<p>What's it look like in practice?
Not too bad at all:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `window_procedure`
    WM_PAINT =&gt; {
      match get_window_userdata(hwnd) {
        Ok(ptr) if !ptr.is_null() =&gt; {
          let ptr = ptr as *mut i32;
          println!(&quot;Current ptr: {}&quot;, *ptr);
          *ptr += 1;
        }
        Ok(_) =&gt; {
          println!(&quot;userdata ptr is null&quot;)
        }
        Err(e) =&gt; {
          println!(&quot;Error while getting the userdata ptr: {}&quot;, e)
        }
      }
      do_some_painting(hwnd, |hdc, _erase_bg, target_rect| {
        let _ = fill_rect_with_sys_color(hdc, &amp;target_rect, SysColor::Window);
        Ok(())
      })
      .unwrap_or_else(|e| println!(&quot;error during painting: {}&quot;, e));
    }
<span class="boring">}
</span></code></pre></pre>
<p>What I like the most about this is that the user can still call <code>begin_paint</code> and <code>end_paint</code> on their own if they want.
Because maybe we make some abstraction workflow thing that doesn't work for them,
and they can just skip around our thing if that's the case.</p>
<h2><a class="header" href="#using-the-exit-code" id="using-the-exit-code">Using The Exit Code</a></h2>
<p>One thing we don't do is pass along the <code>wParam</code> from the <code>MSG</code> struct when we see <code>WM_QUIT</code>.
We're <em>supposed</em> to pass that as the exit code of our process.
For this, we can use <code>std::process:exit</code>, and then pass the value, instead of just breaking the loop.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in main
  loop {
    match get_any_message() {
      Ok(msg) =&gt; {
        if msg.message == WM_QUIT {
          std::process::exit(msg.wParam as i32);
        }
        translate_message(&amp;msg);
        unsafe {
          DispatchMessageW(&amp;msg);
        }
      }
      Err(e) =&gt; panic!(&quot;Error when getting from the message queue: {}&quot;, e),
    }
  }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#done" id="done">Done</a></h2>
<p>Is our program perfect?
Naw, but I think it's good enough for now.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
